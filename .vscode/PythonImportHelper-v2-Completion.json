[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "sample",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageEnhance",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageOps",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawDescriptionHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawDescriptionHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawDescriptionHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawDescriptionHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawDescriptionHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawDescriptionHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "Sampler",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "DistributedBatchSampler",
        "importPath": "paddle.io",
        "description": "paddle.io",
        "isExtraImport": true,
        "detail": "paddle.io",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "data_loader.modules",
        "description": "data_loader.modules",
        "isExtraImport": true,
        "detail": "data_loader.modules",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "pformat",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "anyconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "anyconfig",
        "description": "anyconfig",
        "detail": "anyconfig",
        "documentation": {}
    },
    {
        "label": "paddle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddle",
        "description": "paddle",
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "inference",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "reshape",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "transpose",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "reshape",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "transpose",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "ParamAttr",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "inference",
        "importPath": "paddle",
        "description": "paddle",
        "isExtraImport": true,
        "detail": "paddle",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "to_static",
        "importPath": "paddle.jit",
        "description": "paddle.jit",
        "isExtraImport": true,
        "detail": "paddle.jit",
        "documentation": {}
    },
    {
        "label": "to_static",
        "importPath": "paddle.jit",
        "description": "paddle.jit",
        "isExtraImport": true,
        "detail": "paddle.jit",
        "documentation": {}
    },
    {
        "label": "to_static",
        "importPath": "paddle.jit",
        "description": "paddle.jit",
        "isExtraImport": true,
        "detail": "paddle.jit",
        "documentation": {}
    },
    {
        "label": "to_static",
        "importPath": "paddle.jit",
        "description": "paddle.jit",
        "isExtraImport": true,
        "detail": "paddle.jit",
        "documentation": {}
    },
    {
        "label": "to_static",
        "importPath": "paddle.jit",
        "description": "paddle.jit",
        "isExtraImport": true,
        "detail": "paddle.jit",
        "documentation": {}
    },
    {
        "label": "InputSpec",
        "importPath": "paddle.static",
        "description": "paddle.static",
        "isExtraImport": true,
        "detail": "paddle.static",
        "documentation": {}
    },
    {
        "label": "Program",
        "importPath": "paddle.static",
        "description": "paddle.static",
        "isExtraImport": true,
        "detail": "paddle.static",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "order_points_clockwise",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_datalist",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "load",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "expand_polygon",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "runningScore",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "cal_text_score",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "Polynomial",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "profiler",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "order_points_clockwise",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "print_dict",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "exp",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "random_noise",
        "importPath": "skimage.util",
        "description": "skimage.util",
        "isExtraImport": true,
        "detail": "skimage.util",
        "documentation": {}
    },
    {
        "label": "imgaug",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imgaug",
        "description": "imgaug",
        "detail": "imgaug",
        "documentation": {}
    },
    {
        "label": "imgaug.augmenters",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imgaug.augmenters",
        "description": "imgaug.augmenters",
        "detail": "imgaug.augmenters",
        "documentation": {}
    },
    {
        "label": "pyclipper",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyclipper",
        "description": "pyclipper",
        "detail": "pyclipper",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "LineString",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "MultiPoint",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "scipy.io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.io",
        "description": "scipy.io",
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm.auto",
        "description": "tqdm.auto",
        "isExtraImport": true,
        "detail": "tqdm.auto",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm.auto",
        "description": "tqdm.auto",
        "isExtraImport": true,
        "detail": "tqdm.auto",
        "documentation": {}
    },
    {
        "label": "BaseDataSet",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "paddle.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "L1Loss",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "MSELoss",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "SmoothL1Loss",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AdaptiveAvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AdaptiveAvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "MaxPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AdaptiveAvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "MaxPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AdaptiveAvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Hardsigmoid",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Hardswish",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Identity",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AdaptiveAvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "MaxPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "MaxPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "LayerList",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "LayerList",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AdaptiveAvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "MaxPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BatchNorm",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AdaptiveAvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "MaxPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "AvgPool2D",
        "importPath": "paddle.nn",
        "description": "paddle.nn",
        "isExtraImport": true,
        "detail": "paddle.nn",
        "documentation": {}
    },
    {
        "label": "BalanceCrossEntropyLoss",
        "importPath": "models.losses.basic_loss",
        "description": "models.losses.basic_loss",
        "isExtraImport": true,
        "detail": "models.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "MaskL1Loss",
        "importPath": "models.losses.basic_loss",
        "description": "models.losses.basic_loss",
        "isExtraImport": true,
        "detail": "models.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "DiceLoss",
        "importPath": "models.losses.basic_loss",
        "description": "models.losses.basic_loss",
        "isExtraImport": true,
        "detail": "models.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "paddle.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddle.nn.functional",
        "description": "paddle.nn.functional",
        "detail": "paddle.nn.functional",
        "documentation": {}
    },
    {
        "label": "hardswish",
        "importPath": "paddle.nn.functional",
        "description": "paddle.nn.functional",
        "isExtraImport": true,
        "detail": "paddle.nn.functional",
        "documentation": {}
    },
    {
        "label": "hardsigmoid",
        "importPath": "paddle.nn.functional",
        "description": "paddle.nn.functional",
        "isExtraImport": true,
        "detail": "paddle.nn.functional",
        "documentation": {}
    },
    {
        "label": "hardswish",
        "importPath": "paddle.nn.functional",
        "description": "paddle.nn.functional",
        "isExtraImport": true,
        "detail": "paddle.nn.functional",
        "documentation": {}
    },
    {
        "label": "hardsigmoid",
        "importPath": "paddle.nn.functional",
        "description": "paddle.nn.functional",
        "isExtraImport": true,
        "detail": "paddle.nn.functional",
        "documentation": {}
    },
    {
        "label": "ConvBnRelu",
        "importPath": "models.basic",
        "description": "models.basic",
        "isExtraImport": true,
        "detail": "models.basic",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "addict",
        "description": "addict",
        "isExtraImport": true,
        "detail": "addict",
        "documentation": {}
    },
    {
        "label": "build_backbone",
        "importPath": "models.backbone",
        "description": "models.backbone",
        "isExtraImport": true,
        "detail": "models.backbone",
        "documentation": {}
    },
    {
        "label": "build_neck",
        "importPath": "models.neck",
        "description": "models.neck",
        "isExtraImport": true,
        "detail": "models.neck",
        "documentation": {}
    },
    {
        "label": "build_head",
        "importPath": "models.head",
        "description": "models.head",
        "isExtraImport": true,
        "detail": "models.head",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "transforms",
        "importPath": "paddle.vision",
        "description": "paddle.vision",
        "isExtraImport": true,
        "detail": "paddle.vision",
        "documentation": {}
    },
    {
        "label": "resize_image",
        "importPath": "tools.predict",
        "description": "tools.predict",
        "isExtraImport": true,
        "detail": "tools.predict",
        "documentation": {}
    },
    {
        "label": "get_post_processing",
        "importPath": "post_processing",
        "description": "post_processing",
        "isExtraImport": true,
        "detail": "post_processing",
        "documentation": {}
    },
    {
        "label": "get_post_processing",
        "importPath": "post_processing",
        "description": "post_processing",
        "isExtraImport": true,
        "detail": "post_processing",
        "documentation": {}
    },
    {
        "label": "draw_bbox",
        "importPath": "utils.util",
        "description": "utils.util",
        "isExtraImport": true,
        "detail": "utils.util",
        "documentation": {}
    },
    {
        "label": "save_result",
        "importPath": "utils.util",
        "description": "utils.util",
        "isExtraImport": true,
        "detail": "utils.util",
        "documentation": {}
    },
    {
        "label": "get_transforms",
        "importPath": "data_loader",
        "description": "data_loader",
        "isExtraImport": true,
        "detail": "data_loader",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "data_loader",
        "description": "data_loader",
        "isExtraImport": true,
        "detail": "data_loader",
        "documentation": {}
    },
    {
        "label": "paddle.distributed",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddle.distributed",
        "description": "paddle.distributed",
        "detail": "paddle.distributed",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "Polygon",
        "description": "Polygon",
        "detail": "Polygon",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "lr",
        "importPath": "paddle.optimizer",
        "description": "paddle.optimizer",
        "isExtraImport": true,
        "detail": "paddle.optimizer",
        "documentation": {}
    },
    {
        "label": "lr",
        "importPath": "paddle.optimizer",
        "description": "paddle.optimizer",
        "isExtraImport": true,
        "detail": "paddle.optimizer",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "fastdeploy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fastdeploy",
        "description": "fastdeploy",
        "detail": "fastdeploy",
        "documentation": {}
    },
    {
        "label": "RKNN",
        "importPath": "rknn.api",
        "description": "rknn.api",
        "isExtraImport": true,
        "detail": "rknn.api",
        "documentation": {}
    },
    {
        "label": "triton_python_backend_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "triton_python_backend_utils",
        "description": "triton_python_backend_utils",
        "detail": "triton_python_backend_utils",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "tritonclient",
        "description": "tritonclient",
        "isExtraImport": true,
        "detail": "tritonclient",
        "documentation": {}
    },
    {
        "label": "InferenceServerClient",
        "importPath": "tritonclient.grpc",
        "description": "tritonclient.grpc",
        "isExtraImport": true,
        "detail": "tritonclient.grpc",
        "documentation": {}
    },
    {
        "label": "InferInput",
        "importPath": "tritonclient.grpc",
        "description": "tritonclient.grpc",
        "isExtraImport": true,
        "detail": "tritonclient.grpc",
        "documentation": {}
    },
    {
        "label": "InferRequestedOutput",
        "importPath": "tritonclient.grpc",
        "description": "tritonclient.grpc",
        "isExtraImport": true,
        "detail": "tritonclient.grpc",
        "documentation": {}
    },
    {
        "label": "service_pb2_grpc",
        "importPath": "tritonclient.grpc",
        "description": "tritonclient.grpc",
        "isExtraImport": true,
        "detail": "tritonclient.grpc",
        "documentation": {}
    },
    {
        "label": "service_pb2",
        "importPath": "tritonclient.grpc",
        "description": "tritonclient.grpc",
        "isExtraImport": true,
        "detail": "tritonclient.grpc",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "cv2_to_base64",
        "importPath": "fastdeploy.serving.utils",
        "description": "fastdeploy.serving.utils",
        "isExtraImport": true,
        "detail": "fastdeploy.serving.utils",
        "documentation": {}
    },
    {
        "label": "SimpleServer",
        "importPath": "fastdeploy.serving.server",
        "description": "fastdeploy.serving.server",
        "isExtraImport": true,
        "detail": "fastdeploy.serving.server",
        "documentation": {}
    },
    {
        "label": "paddlehub",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddlehub",
        "description": "paddlehub",
        "detail": "paddlehub",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "paddlehub.common.logger",
        "description": "paddlehub.common.logger",
        "isExtraImport": true,
        "detail": "paddlehub.common.logger",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "moduleinfo",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "runnable",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "serving",
        "importPath": "paddlehub.module.module",
        "description": "paddlehub.module.module",
        "isExtraImport": true,
        "detail": "paddlehub.module.module",
        "documentation": {}
    },
    {
        "label": "tools.infer.utility",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "get_rotate_crop_image",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_ocr_box_txt",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "str2int_tuple",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "init_args",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_ocr_box_txt",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "get_rotate_crop_image",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "get_minarea_rect_crop",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_boxes",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_ocr",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_boxes",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_ocr",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "check_gpu",
        "importPath": "tools.infer.utility",
        "description": "tools.infer.utility",
        "isExtraImport": true,
        "detail": "tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "SerPredictor",
        "importPath": "ppstructure.kie.predict_kie_token_ser",
        "description": "ppstructure.kie.predict_kie_token_ser",
        "isExtraImport": true,
        "detail": "ppstructure.kie.predict_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "SerPredictor",
        "importPath": "ppstructure.kie.predict_kie_token_ser",
        "description": "ppstructure.kie.predict_kie_token_ser",
        "isExtraImport": true,
        "detail": "ppstructure.kie.predict_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "draw_structure_result",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "init_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "draw_structure_result",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "draw_structure_result",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "init_args",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "draw_structure_result",
        "importPath": "ppstructure.utility",
        "description": "ppstructure.utility",
        "isExtraImport": true,
        "detail": "ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.kie_ser.params",
        "description": "deploy.hubserving.kie_ser.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.kie_ser.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.ocr_system.params",
        "description": "deploy.hubserving.ocr_system.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.ocr_system.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.ocr_system.params",
        "description": "deploy.hubserving.ocr_system.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.ocr_system.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.ocr_system.params",
        "description": "deploy.hubserving.ocr_system.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.ocr_system.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.ocr_system.params",
        "description": "deploy.hubserving.ocr_system.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.ocr_system.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.ocr_system.params",
        "description": "deploy.hubserving.ocr_system.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.ocr_system.params",
        "documentation": {}
    },
    {
        "label": "SerRePredictor",
        "importPath": "ppstructure.kie.predict_kie_token_ser_re",
        "description": "ppstructure.kie.predict_kie_token_ser_re",
        "isExtraImport": true,
        "detail": "ppstructure.kie.predict_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.kie_ser_re.params",
        "description": "deploy.hubserving.kie_ser_re.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.kie_ser_re.params",
        "documentation": {}
    },
    {
        "label": "tools.infer.predict_cls",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tools.infer.predict_cls",
        "description": "tools.infer.predict_cls",
        "detail": "tools.infer.predict_cls",
        "documentation": {}
    },
    {
        "label": "TextClassifier",
        "importPath": "tools.infer.predict_cls",
        "description": "tools.infer.predict_cls",
        "isExtraImport": true,
        "detail": "tools.infer.predict_cls",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.ocr_cls.params",
        "description": "deploy.hubserving.ocr_cls.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.ocr_cls.params",
        "documentation": {}
    },
    {
        "label": "tools.infer.predict_det",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tools.infer.predict_det",
        "description": "tools.infer.predict_det",
        "detail": "tools.infer.predict_det",
        "documentation": {}
    },
    {
        "label": "TextDetector",
        "importPath": "tools.infer.predict_det",
        "description": "tools.infer.predict_det",
        "isExtraImport": true,
        "detail": "tools.infer.predict_det",
        "documentation": {}
    },
    {
        "label": "tools.infer.predict_rec",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tools.infer.predict_rec",
        "description": "tools.infer.predict_rec",
        "detail": "tools.infer.predict_rec",
        "documentation": {}
    },
    {
        "label": "TextRecognizer",
        "importPath": "tools.infer.predict_rec",
        "description": "tools.infer.predict_rec",
        "isExtraImport": true,
        "detail": "tools.infer.predict_rec",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.ocr_rec.params",
        "description": "deploy.hubserving.ocr_rec.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.ocr_rec.params",
        "documentation": {}
    },
    {
        "label": "TextSystem",
        "importPath": "tools.infer.predict_system",
        "description": "tools.infer.predict_system",
        "isExtraImport": true,
        "detail": "tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "sorted_boxes",
        "importPath": "tools.infer.predict_system",
        "description": "tools.infer.predict_system",
        "isExtraImport": true,
        "detail": "tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "TextSystem",
        "importPath": "tools.infer.predict_system",
        "description": "tools.infer.predict_system",
        "isExtraImport": true,
        "detail": "tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "LayoutPredictor",
        "importPath": "ppstructure.layout.predict_layout",
        "description": "ppstructure.layout.predict_layout",
        "isExtraImport": true,
        "detail": "ppstructure.layout.predict_layout",
        "documentation": {}
    },
    {
        "label": "LayoutPredictor",
        "importPath": "ppstructure.layout.predict_layout",
        "description": "ppstructure.layout.predict_layout",
        "isExtraImport": true,
        "detail": "ppstructure.layout.predict_layout",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.structure_layout.params",
        "description": "deploy.hubserving.structure_layout.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.structure_layout.params",
        "documentation": {}
    },
    {
        "label": "StructureSystem",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "save_structure_res",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "save_structure_res",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "StructureSystem",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "save_structure_res",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "to_excel",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "StructureSystem",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "save_structure_res",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "to_excel",
        "importPath": "ppstructure.predict_system",
        "description": "ppstructure.predict_system",
        "isExtraImport": true,
        "detail": "ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.structure_system.params",
        "description": "deploy.hubserving.structure_system.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.structure_system.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.structure_table.params",
        "description": "deploy.hubserving.structure_table.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.structure_table.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "deploy.hubserving.structure_table.params",
        "description": "deploy.hubserving.structure_table.params",
        "isExtraImport": true,
        "detail": "deploy.hubserving.structure_table.params",
        "documentation": {}
    },
    {
        "label": "TableSystem",
        "importPath": "ppstructure.table.predict_table",
        "description": "ppstructure.table.predict_table",
        "isExtraImport": true,
        "detail": "ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "TableSystem",
        "importPath": "ppstructure.table.predict_table",
        "description": "ppstructure.table.predict_table",
        "isExtraImport": true,
        "detail": "ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "TableSystem",
        "importPath": "ppstructure.table.predict_table",
        "description": "ppstructure.table.predict_table",
        "isExtraImport": true,
        "detail": "ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "to_excel",
        "importPath": "ppstructure.table.predict_table",
        "description": "ppstructure.table.predict_table",
        "isExtraImport": true,
        "detail": "ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "Client",
        "importPath": "paddle_serving_client",
        "description": "paddle_serving_client",
        "isExtraImport": true,
        "detail": "paddle_serving_client",
        "documentation": {}
    },
    {
        "label": "Client",
        "importPath": "paddle_serving_client",
        "description": "paddle_serving_client",
        "isExtraImport": true,
        "detail": "paddle_serving_client",
        "documentation": {}
    },
    {
        "label": "Client",
        "importPath": "paddle_serving_client",
        "description": "paddle_serving_client",
        "isExtraImport": true,
        "detail": "paddle_serving_client",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "URL2Image",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "ResizeByFactor",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Div",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Transpose",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "DBPostProcess",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "FilterBoxes",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "GetRotateCropImage",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "SortedBoxes",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "URL2Image",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "ResizeByFactor",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Div",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Transpose",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "ResizeByFactor",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Div",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Transpose",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "DBPostProcess",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "FilterBoxes",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "GetRotateCropImage",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "SortedBoxes",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "ResizeByFactor",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Div",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Transpose",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "DBPostProcess",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "FilterBoxes",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "GetRotateCropImage",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "SortedBoxes",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "ResizeByFactor",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Div",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "Transpose",
        "importPath": "paddle_serving_app.reader",
        "description": "paddle_serving_app.reader",
        "isExtraImport": true,
        "detail": "paddle_serving_app.reader",
        "documentation": {}
    },
    {
        "label": "OCRReader",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "OCRReader",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "OCRReader",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "DetResizeForTest",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "OCRReader",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "DetResizeForTest",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "OCRReader",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "DetResizeForTest",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "ocr_reader",
        "description": "ocr_reader",
        "isExtraImport": true,
        "detail": "ocr_reader",
        "documentation": {}
    },
    {
        "label": "LocalPredictor",
        "importPath": "paddle_serving_app.local_predict",
        "description": "paddle_serving_app.local_predict",
        "isExtraImport": true,
        "detail": "paddle_serving_app.local_predict",
        "documentation": {}
    },
    {
        "label": "WebService",
        "importPath": "paddle_serving_server.web_service",
        "description": "paddle_serving_server.web_service",
        "isExtraImport": true,
        "detail": "paddle_serving_server.web_service",
        "documentation": {}
    },
    {
        "label": "Op",
        "importPath": "paddle_serving_server.web_service",
        "description": "paddle_serving_server.web_service",
        "isExtraImport": true,
        "detail": "paddle_serving_server.web_service",
        "documentation": {}
    },
    {
        "label": "WebService",
        "importPath": "paddle_serving_server.web_service",
        "description": "paddle_serving_server.web_service",
        "isExtraImport": true,
        "detail": "paddle_serving_server.web_service",
        "documentation": {}
    },
    {
        "label": "Op",
        "importPath": "paddle_serving_server.web_service",
        "description": "paddle_serving_server.web_service",
        "isExtraImport": true,
        "detail": "paddle_serving_server.web_service",
        "documentation": {}
    },
    {
        "label": "WebService",
        "importPath": "paddle_serving_server.web_service",
        "description": "paddle_serving_server.web_service",
        "isExtraImport": true,
        "detail": "paddle_serving_server.web_service",
        "documentation": {}
    },
    {
        "label": "Op",
        "importPath": "paddle_serving_server.web_service",
        "description": "paddle_serving_server.web_service",
        "isExtraImport": true,
        "detail": "paddle_serving_server.web_service",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "set_signal_handlers",
        "importPath": "ppocr.data",
        "description": "ppocr.data",
        "isExtraImport": true,
        "detail": "ppocr.data",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "apply_to_static",
        "importPath": "ppocr.modeling.architectures",
        "description": "ppocr.modeling.architectures",
        "isExtraImport": true,
        "detail": "ppocr.modeling.architectures",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_post_process",
        "importPath": "ppocr.postprocess",
        "description": "ppocr.postprocess",
        "isExtraImport": true,
        "detail": "ppocr.postprocess",
        "documentation": {}
    },
    {
        "label": "build_metric",
        "importPath": "ppocr.metrics",
        "description": "ppocr.metrics",
        "isExtraImport": true,
        "detail": "ppocr.metrics",
        "documentation": {}
    },
    {
        "label": "build_metric",
        "importPath": "ppocr.metrics",
        "description": "ppocr.metrics",
        "isExtraImport": true,
        "detail": "ppocr.metrics",
        "documentation": {}
    },
    {
        "label": "build_metric",
        "importPath": "ppocr.metrics",
        "description": "ppocr.metrics",
        "isExtraImport": true,
        "detail": "ppocr.metrics",
        "documentation": {}
    },
    {
        "label": "build_metric",
        "importPath": "ppocr.metrics",
        "description": "ppocr.metrics",
        "isExtraImport": true,
        "detail": "ppocr.metrics",
        "documentation": {}
    },
    {
        "label": "build_metric",
        "importPath": "ppocr.metrics",
        "description": "ppocr.metrics",
        "isExtraImport": true,
        "detail": "ppocr.metrics",
        "documentation": {}
    },
    {
        "label": "build_metric",
        "importPath": "ppocr.metrics",
        "description": "ppocr.metrics",
        "isExtraImport": true,
        "detail": "ppocr.metrics",
        "documentation": {}
    },
    {
        "label": "build_metric",
        "importPath": "ppocr.metrics",
        "description": "ppocr.metrics",
        "isExtraImport": true,
        "detail": "ppocr.metrics",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_pretrained_params",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "save_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "ppocr.utils.save_load",
        "description": "ppocr.utils.save_load",
        "isExtraImport": true,
        "detail": "ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "tools.program",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tools.program",
        "description": "tools.program",
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "merge_config",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "merge_config",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "merge_config",
        "importPath": "tools.program",
        "description": "tools.program",
        "isExtraImport": true,
        "detail": "tools.program",
        "documentation": {}
    },
    {
        "label": "build_loss",
        "importPath": "ppocr.losses",
        "description": "ppocr.losses",
        "isExtraImport": true,
        "detail": "ppocr.losses",
        "documentation": {}
    },
    {
        "label": "build_loss",
        "importPath": "ppocr.losses",
        "description": "ppocr.losses",
        "isExtraImport": true,
        "detail": "ppocr.losses",
        "documentation": {}
    },
    {
        "label": "build_loss",
        "importPath": "ppocr.losses",
        "description": "ppocr.losses",
        "isExtraImport": true,
        "detail": "ppocr.losses",
        "documentation": {}
    },
    {
        "label": "build_loss",
        "importPath": "ppocr.losses",
        "description": "ppocr.losses",
        "isExtraImport": true,
        "detail": "ppocr.losses",
        "documentation": {}
    },
    {
        "label": "build_optimizer",
        "importPath": "ppocr.optimizer",
        "description": "ppocr.optimizer",
        "isExtraImport": true,
        "detail": "ppocr.optimizer",
        "documentation": {}
    },
    {
        "label": "build_optimizer",
        "importPath": "ppocr.optimizer",
        "description": "ppocr.optimizer",
        "isExtraImport": true,
        "detail": "ppocr.optimizer",
        "documentation": {}
    },
    {
        "label": "build_optimizer",
        "importPath": "ppocr.optimizer",
        "description": "ppocr.optimizer",
        "isExtraImport": true,
        "detail": "ppocr.optimizer",
        "documentation": {}
    },
    {
        "label": "build_optimizer",
        "importPath": "ppocr.optimizer",
        "description": "ppocr.optimizer",
        "isExtraImport": true,
        "detail": "ppocr.optimizer",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "ppocr.utils.logging",
        "description": "ppocr.utils.logging",
        "isExtraImport": true,
        "detail": "ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "QAT",
        "importPath": "paddleslim.dygraph.quant",
        "description": "paddleslim.dygraph.quant",
        "isExtraImport": true,
        "detail": "paddleslim.dygraph.quant",
        "documentation": {}
    },
    {
        "label": "QAT",
        "importPath": "paddleslim.dygraph.quant",
        "description": "paddleslim.dygraph.quant",
        "isExtraImport": true,
        "detail": "paddleslim.dygraph.quant",
        "documentation": {}
    },
    {
        "label": "QAT",
        "importPath": "paddleslim.dygraph.quant",
        "description": "paddleslim.dygraph.quant",
        "isExtraImport": true,
        "detail": "paddleslim.dygraph.quant",
        "documentation": {}
    },
    {
        "label": "QAT",
        "importPath": "paddleslim.dygraph.quant",
        "description": "paddleslim.dygraph.quant",
        "isExtraImport": true,
        "detail": "paddleslim.dygraph.quant",
        "documentation": {}
    },
    {
        "label": "export_single_model",
        "importPath": "tools.export_model",
        "description": "tools.export_model",
        "isExtraImport": true,
        "detail": "tools.export_model",
        "documentation": {}
    },
    {
        "label": "paddleslim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddleslim",
        "description": "paddleslim",
        "detail": "paddleslim",
        "documentation": {}
    },
    {
        "label": "paddle.vision.transforms",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "Compose",
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "isExtraImport": true,
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "ColorJitter",
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "isExtraImport": true,
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "ColorJitter",
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "isExtraImport": true,
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "Compose",
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "isExtraImport": true,
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "Compose",
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "isExtraImport": true,
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "isExtraImport": true,
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "paddle.vision.transforms",
        "description": "paddle.vision.transforms",
        "isExtraImport": true,
        "detail": "paddle.vision.transforms",
        "documentation": {}
    },
    {
        "label": "IaaAugment",
        "importPath": "ppocr.data.imaug.iaa_augment",
        "description": "ppocr.data.imaug.iaa_augment",
        "isExtraImport": true,
        "detail": "ppocr.data.imaug.iaa_augment",
        "documentation": {}
    },
    {
        "label": "is_poly_outside_rect",
        "importPath": "ppocr.data.imaug.random_crop_data",
        "description": "ppocr.data.imaug.random_crop_data",
        "isExtraImport": true,
        "detail": "ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "check_install",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_install",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_install",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "load_vqa_bio_label_maps",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_install",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "print_dict",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "load_vqa_bio_label_maps",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "load_vqa_bio_label_maps",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "print_dict",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "print_dict",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "AverageMeter",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "set_seed",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "alpha_to_color",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "binarize_img",
        "importPath": "ppocr.utils.utility",
        "description": "ppocr.utils.utility",
        "isExtraImport": true,
        "detail": "ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "numpy.linalg",
        "description": "numpy.linalg",
        "isExtraImport": true,
        "detail": "numpy.linalg",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "numpy.linalg",
        "description": "numpy.linalg",
        "isExtraImport": true,
        "detail": "numpy.linalg",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "numpy.linalg",
        "description": "numpy.linalg",
        "isExtraImport": true,
        "detail": "numpy.linalg",
        "documentation": {}
    },
    {
        "label": "poly_intersection",
        "importPath": "ppocr.utils.poly_nms",
        "description": "ppocr.utils.poly_nms",
        "isExtraImport": true,
        "detail": "ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "poly_nms",
        "importPath": "ppocr.utils.poly_nms",
        "description": "ppocr.utils.poly_nms",
        "isExtraImport": true,
        "detail": "ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "valid_boundary",
        "importPath": "ppocr.utils.poly_nms",
        "description": "ppocr.utils.poly_nms",
        "isExtraImport": true,
        "detail": "ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "fft",
        "importPath": "numpy.fft",
        "description": "numpy.fft",
        "isExtraImport": true,
        "detail": "numpy.fft",
        "documentation": {}
    },
    {
        "label": "ifft",
        "importPath": "numpy.fft",
        "description": "numpy.fft",
        "isExtraImport": true,
        "detail": "numpy.fft",
        "documentation": {}
    },
    {
        "label": "order_by_tbyx",
        "importPath": "ppocr.data.imaug.vqa.augment",
        "description": "ppocr.data.imaug.vqa.augment",
        "isExtraImport": true,
        "detail": "ppocr.data.imaug.vqa.augment",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "six",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "six",
        "description": "six",
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "thin",
        "importPath": "skimage.morphology._skeletonize",
        "description": "skimage.morphology._skeletonize",
        "isExtraImport": true,
        "detail": "skimage.morphology._skeletonize",
        "documentation": {}
    },
    {
        "label": "thin",
        "importPath": "skimage.morphology._skeletonize",
        "description": "skimage.morphology._skeletonize",
        "isExtraImport": true,
        "detail": "skimage.morphology._skeletonize",
        "documentation": {}
    },
    {
        "label": "thin",
        "importPath": "skimage.morphology._skeletonize",
        "description": "skimage.morphology._skeletonize",
        "isExtraImport": true,
        "detail": "skimage.morphology._skeletonize",
        "documentation": {}
    },
    {
        "label": "sort_and_expand_with_direction_v2",
        "importPath": "ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "ppocr.utils.e2e_utils.extract_textpoint_fast",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "lmdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lmdb",
        "description": "lmdb",
        "detail": "lmdb",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "load",
        "importPath": "paddle.utils.cpp_extension",
        "description": "paddle.utils.cpp_extension",
        "isExtraImport": true,
        "detail": "paddle.utils.cpp_extension",
        "documentation": {}
    },
    {
        "label": "load",
        "importPath": "paddle.utils.cpp_extension",
        "description": "paddle.utils.cpp_extension",
        "isExtraImport": true,
        "detail": "paddle.utils.cpp_extension",
        "documentation": {}
    },
    {
        "label": "load",
        "importPath": "paddle.utils.cpp_extension",
        "description": "paddle.utils.cpp_extension",
        "isExtraImport": true,
        "detail": "paddle.utils.cpp_extension",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "iou",
        "importPath": "ppocr.utils.iou",
        "description": "ppocr.utils.iou",
        "isExtraImport": true,
        "detail": "ppocr.utils.iou",
        "documentation": {}
    },
    {
        "label": "pre_process",
        "importPath": "ppocr.utils.e2e_utils.extract_batchsize",
        "description": "ppocr.utils.e2e_utils.extract_batchsize",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_utils.extract_batchsize",
        "documentation": {}
    },
    {
        "label": "DMLLoss",
        "importPath": "ppocr.losses.basic_loss",
        "description": "ppocr.losses.basic_loss",
        "isExtraImport": true,
        "detail": "ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "io",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "combine_results",
        "importPath": "ppocr.utils.e2e_metric.Deteval",
        "description": "ppocr.utils.e2e_metric.Deteval",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "get_score_C",
        "importPath": "ppocr.utils.e2e_metric.Deteval",
        "description": "ppocr.utils.e2e_metric.Deteval",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "get_socre_A",
        "importPath": "ppocr.utils.e2e_metric.Deteval",
        "description": "ppocr.utils.e2e_metric.Deteval",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "get_socre_B",
        "importPath": "ppocr.utils.e2e_metric.Deteval",
        "description": "ppocr.utils.e2e_metric.Deteval",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "combine_results",
        "importPath": "ppocr.utils.e2e_metric.Deteval",
        "description": "ppocr.utils.e2e_metric.Deteval",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "get_dict",
        "importPath": "ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "ppocr.utils.e2e_utils.extract_textpoint_slow",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "Levenshtein",
        "importPath": "rapidfuzz.distance",
        "description": "rapidfuzz.distance",
        "isExtraImport": true,
        "detail": "rapidfuzz.distance",
        "documentation": {}
    },
    {
        "label": "Levenshtein",
        "importPath": "rapidfuzz.distance",
        "description": "rapidfuzz.distance",
        "isExtraImport": true,
        "detail": "rapidfuzz.distance",
        "documentation": {}
    },
    {
        "label": "Levenshtein",
        "importPath": "rapidfuzz.distance",
        "description": "rapidfuzz.distance",
        "isExtraImport": true,
        "detail": "rapidfuzz.distance",
        "documentation": {}
    },
    {
        "label": "SequenceMatcher",
        "importPath": "difflib",
        "description": "difflib",
        "isExtraImport": true,
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "DetMetric",
        "importPath": "ppocr.metrics.det_metric",
        "description": "ppocr.metrics.det_metric",
        "isExtraImport": true,
        "detail": "ppocr.metrics.det_metric",
        "documentation": {}
    },
    {
        "label": "build_transform",
        "importPath": "ppocr.modeling.transforms",
        "description": "ppocr.modeling.transforms",
        "isExtraImport": true,
        "detail": "ppocr.modeling.transforms",
        "documentation": {}
    },
    {
        "label": "build_transform",
        "importPath": "ppocr.modeling.transforms",
        "description": "ppocr.modeling.transforms",
        "isExtraImport": true,
        "detail": "ppocr.modeling.transforms",
        "documentation": {}
    },
    {
        "label": "build_backbone",
        "importPath": "ppocr.modeling.backbones",
        "description": "ppocr.modeling.backbones",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones",
        "documentation": {}
    },
    {
        "label": "build_backbone",
        "importPath": "ppocr.modeling.backbones",
        "description": "ppocr.modeling.backbones",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones",
        "documentation": {}
    },
    {
        "label": "build_neck",
        "importPath": "ppocr.modeling.necks",
        "description": "ppocr.modeling.necks",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks",
        "documentation": {}
    },
    {
        "label": "build_neck",
        "importPath": "ppocr.modeling.necks",
        "description": "ppocr.modeling.necks",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks",
        "documentation": {}
    },
    {
        "label": "build_head",
        "importPath": "ppocr.modeling.heads",
        "description": "ppocr.modeling.heads",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads",
        "documentation": {}
    },
    {
        "label": "build_head",
        "importPath": "ppocr.modeling.heads",
        "description": "ppocr.modeling.heads",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads",
        "documentation": {}
    },
    {
        "label": "paddle.regularizer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "importPath": "paddle.regularizer",
        "description": "paddle.regularizer",
        "isExtraImport": true,
        "detail": "paddle.regularizer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Uniform",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "XavierUniform",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "XavierUniform",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "TruncatedNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Uniform",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "TruncatedNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "TruncatedNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "XavierNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "TruncatedNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Uniform",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "XavierNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "TruncatedNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "XavierUniform",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "TruncatedNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Constant",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "KaimingNormal",
        "importPath": "paddle.nn.initializer",
        "description": "paddle.nn.initializer",
        "isExtraImport": true,
        "detail": "paddle.nn.initializer",
        "documentation": {}
    },
    {
        "label": "get_path_from_url",
        "importPath": "paddle.utils.download",
        "description": "paddle.utils.download",
        "isExtraImport": true,
        "detail": "paddle.utils.download",
        "documentation": {}
    },
    {
        "label": "DeformConv2D",
        "importPath": "paddle.vision.ops",
        "description": "paddle.vision.ops",
        "isExtraImport": true,
        "detail": "paddle.vision.ops",
        "documentation": {}
    },
    {
        "label": "DeformConv2D",
        "importPath": "paddle.vision.ops",
        "description": "paddle.vision.ops",
        "isExtraImport": true,
        "detail": "paddle.vision.ops",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "importPath": "ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "ppocr.modeling.backbones.det_mobilenet_v3",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "ResidualUnit",
        "importPath": "ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "ppocr.modeling.backbones.det_mobilenet_v3",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "importPath": "ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "ppocr.modeling.backbones.det_mobilenet_v3",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "importPath": "ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "ppocr.modeling.backbones.det_mobilenet_v3",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "importPath": "ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "ppocr.modeling.backbones.det_mobilenet_v3",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "SEModule",
        "importPath": "ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "ppocr.modeling.backbones.det_mobilenet_v3",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "Block",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "PatchEmbed",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "trunc_normal_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "ones_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "ones_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "Block",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "trunc_normal_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "ones_",
        "importPath": "ppocr.modeling.backbones.rec_svtrnet",
        "description": "ppocr.modeling.backbones.rec_svtrnet",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "LayoutXLMModel",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "LayoutXLMForTokenClassification",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "LayoutXLMForRelationExtraction",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "LayoutLMModel",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "LayoutLMForTokenClassification",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "LayoutLMv2Model",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "LayoutLMv2ForTokenClassification",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "LayoutLMv2ForRelationExtraction",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "paddlenlp.transformers",
        "description": "paddlenlp.transformers",
        "isExtraImport": true,
        "detail": "paddlenlp.transformers",
        "documentation": {}
    },
    {
        "label": "RoIAlignRotated",
        "importPath": "ppocr.ext_op",
        "description": "ppocr.ext_op",
        "isExtraImport": true,
        "detail": "ppocr.ext_op",
        "documentation": {}
    },
    {
        "label": "RoIAlignRotated",
        "importPath": "ppocr.ext_op",
        "description": "ppocr.ext_op",
        "isExtraImport": true,
        "detail": "ppocr.ext_op",
        "documentation": {}
    },
    {
        "label": "merge_quadrangle_n9",
        "importPath": "lanms",
        "description": "lanms",
        "isExtraImport": true,
        "detail": "lanms",
        "documentation": {}
    },
    {
        "label": "TransformerBlock",
        "importPath": "ppocr.modeling.heads.rec_nrtr_head",
        "description": "ppocr.modeling.heads.rec_nrtr_head",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "importPath": "ppocr.modeling.heads.rec_nrtr_head",
        "description": "ppocr.modeling.heads.rec_nrtr_head",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "Im2Seq",
        "importPath": "ppocr.modeling.necks.rnn",
        "description": "ppocr.modeling.necks.rnn",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "EncoderWithRNN",
        "importPath": "ppocr.modeling.necks.rnn",
        "description": "ppocr.modeling.necks.rnn",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "EncoderWithFC",
        "importPath": "ppocr.modeling.necks.rnn",
        "description": "ppocr.modeling.necks.rnn",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "SequenceEncoder",
        "importPath": "ppocr.modeling.necks.rnn",
        "description": "ppocr.modeling.necks.rnn",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "EncoderWithSVTR",
        "importPath": "ppocr.modeling.necks.rnn",
        "description": "ppocr.modeling.necks.rnn",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "ResNetFPN",
        "importPath": "ppocr.modeling.backbones.rec_resnet_fpn",
        "description": "ppocr.modeling.backbones.rec_resnet_fpn",
        "isExtraImport": true,
        "detail": "ppocr.modeling.backbones.rec_resnet_fpn",
        "documentation": {}
    },
    {
        "label": "IntraCLBlock",
        "importPath": "ppocr.modeling.necks.intracl",
        "description": "ppocr.modeling.necks.intracl",
        "isExtraImport": true,
        "detail": "ppocr.modeling.necks.intracl",
        "documentation": {}
    },
    {
        "label": "get_para_bias_attr",
        "importPath": "ppocr.modeling.heads.rec_ctc_head",
        "description": "ppocr.modeling.heads.rec_ctc_head",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads.rec_ctc_head",
        "documentation": {}
    },
    {
        "label": "Transformer",
        "importPath": "ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "ppocr.modeling.heads.sr_rensnet_transformer",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "ppocr.modeling.heads.sr_rensnet_transformer",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "ppocr.modeling.heads.sr_rensnet_transformer",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "Transformer",
        "importPath": "ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "ppocr.modeling.heads.sr_rensnet_transformer",
        "isExtraImport": true,
        "detail": "ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "groupby",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "groupby",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "math,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math.",
        "description": "math.",
        "detail": "math.",
        "documentation": {}
    },
    {
        "label": "LRScheduler",
        "importPath": "paddle.optimizer.lr",
        "description": "paddle.optimizer.lr",
        "isExtraImport": true,
        "detail": "paddle.optimizer.lr",
        "documentation": {}
    },
    {
        "label": "LinearWarmup",
        "importPath": "paddle.optimizer.lr",
        "description": "paddle.optimizer.lr",
        "isExtraImport": true,
        "detail": "paddle.optimizer.lr",
        "documentation": {}
    },
    {
        "label": "PiecewiseDecay",
        "importPath": "paddle.optimizer.lr",
        "description": "paddle.optimizer.lr",
        "isExtraImport": true,
        "detail": "paddle.optimizer.lr",
        "documentation": {}
    },
    {
        "label": "CosineAnnealingDecay",
        "importPath": "paddle.optimizer.lr",
        "description": "paddle.optimizer.lr",
        "isExtraImport": true,
        "detail": "paddle.optimizer.lr",
        "documentation": {}
    },
    {
        "label": "ExponentialDecay",
        "importPath": "paddle.optimizer.lr",
        "description": "paddle.optimizer.lr",
        "isExtraImport": true,
        "detail": "paddle.optimizer.lr",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "pse",
        "importPath": "ppocr.postprocess.pse_postprocess.pse",
        "description": "ppocr.postprocess.pse_postprocess.pse",
        "isExtraImport": true,
        "detail": "ppocr.postprocess.pse_postprocess.pse",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "PGNet_PostProcess",
        "importPath": "ppocr.utils.e2e_utils.pgnet_pp_utils",
        "description": "ppocr.utils.e2e_utils.pgnet_pp_utils",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_utils.pgnet_pp_utils",
        "documentation": {}
    },
    {
        "label": "softmax",
        "importPath": "scipy.special",
        "description": "scipy.special",
        "isExtraImport": true,
        "detail": "scipy.special",
        "documentation": {}
    },
    {
        "label": "iod",
        "importPath": "ppocr.utils.e2e_metric.polygon_fast",
        "description": "ppocr.utils.e2e_metric.polygon_fast",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "area_of_intersection",
        "importPath": "ppocr.utils.e2e_metric.polygon_fast",
        "description": "ppocr.utils.e2e_metric.polygon_fast",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "area",
        "importPath": "ppocr.utils.e2e_metric.polygon_fast",
        "description": "ppocr.utils.e2e_metric.polygon_fast",
        "isExtraImport": true,
        "detail": "ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "extract_textpoint_slow",
        "description": "extract_textpoint_slow",
        "isExtraImport": true,
        "detail": "extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "generate_pivot_list_fast",
        "importPath": "extract_textpoint_fast",
        "description": "extract_textpoint_fast",
        "isExtraImport": true,
        "detail": "extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "restore_poly",
        "importPath": "extract_textpoint_fast",
        "description": "extract_textpoint_fast",
        "isExtraImport": true,
        "detail": "extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "LogWriter",
        "importPath": "visualdl",
        "description": "visualdl",
        "isExtraImport": true,
        "detail": "visualdl",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "paddle.profiler",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "paddle.profiler",
        "description": "paddle.profiler",
        "detail": "paddle.profiler",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "maybe_download_params",
        "importPath": "ppocr.utils.network",
        "description": "ppocr.utils.network",
        "isExtraImport": true,
        "detail": "ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "download_with_progressbar",
        "importPath": "ppocr.utils.network",
        "description": "ppocr.utils.network",
        "isExtraImport": true,
        "detail": "ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "maybe_download",
        "importPath": "ppocr.utils.network",
        "description": "ppocr.utils.network",
        "isExtraImport": true,
        "detail": "ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "download_with_progressbar",
        "importPath": "ppocr.utils.network",
        "description": "ppocr.utils.network",
        "isExtraImport": true,
        "detail": "ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "is_link",
        "importPath": "ppocr.utils.network",
        "description": "ppocr.utils.network",
        "isExtraImport": true,
        "detail": "ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "confirm_model_dir_url",
        "importPath": "ppocr.utils.network",
        "description": "ppocr.utils.network",
        "isExtraImport": true,
        "detail": "ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "imghdr",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imghdr",
        "description": "imghdr",
        "detail": "imghdr",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "newIcon",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "distance",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "newIcon",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "labelValidator",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "newIcon",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "labelValidator",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "distance",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "libs.utils",
        "description": "libs.utils",
        "isExtraImport": true,
        "detail": "libs.utils",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "pyqtSignal",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QPointF",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QPoint",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QModelIndex",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QPointF",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QRegExp",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QT_VERSION_STR",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QSize",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QPoint",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QByteArray",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QTimer",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QFileInfo",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QPointF",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QProcess",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QPainter",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPen",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPainterPath",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QRegExpValidator",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QImage",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QCursor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QImageReader",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMenu",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QListWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QPushButton",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QAction",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMenu",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QListWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QToolButton",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QHBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QDockWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "Shape",
        "importPath": "libs.shape",
        "description": "libs.shape",
        "isExtraImport": true,
        "detail": "libs.shape",
        "documentation": {}
    },
    {
        "label": "Shape",
        "importPath": "libs.shape",
        "description": "libs.shape",
        "isExtraImport": true,
        "detail": "libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LINE_COLOR",
        "importPath": "libs.shape",
        "description": "libs.shape",
        "isExtraImport": true,
        "detail": "libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FILL_COLOR",
        "importPath": "libs.shape",
        "description": "libs.shape",
        "isExtraImport": true,
        "detail": "libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOCK_COLOR",
        "importPath": "libs.shape",
        "description": "libs.shape",
        "isExtraImport": true,
        "detail": "libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENCODING",
        "importPath": "libs.constants",
        "description": "libs.constants",
        "isExtraImport": true,
        "detail": "libs.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENCODING",
        "importPath": "libs.constants",
        "description": "libs.constants",
        "isExtraImport": true,
        "detail": "libs.constants",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "libs.constants",
        "description": "libs.constants",
        "isExtraImport": true,
        "detail": "libs.constants",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QT_VERSION_STR",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "PIL.Image",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PIL.Image",
        "description": "PIL.Image",
        "detail": "PIL.Image",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "ustr",
        "importPath": "libs.ustr",
        "description": "libs.ustr",
        "isExtraImport": true,
        "detail": "libs.ustr",
        "documentation": {}
    },
    {
        "label": "ustr",
        "importPath": "libs.ustr",
        "description": "libs.ustr",
        "isExtraImport": true,
        "detail": "libs.ustr",
        "documentation": {}
    },
    {
        "label": "ustr",
        "importPath": "libs.ustr",
        "description": "libs.ustr",
        "isExtraImport": true,
        "detail": "libs.ustr",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "xlrd",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xlrd",
        "description": "xlrd",
        "detail": "xlrd",
        "documentation": {}
    },
    {
        "label": "PaddleOCR",
        "importPath": "paddleocr",
        "description": "paddleocr",
        "isExtraImport": true,
        "detail": "paddleocr",
        "documentation": {}
    },
    {
        "label": "PPStructure",
        "importPath": "paddleocr",
        "description": "paddleocr",
        "isExtraImport": true,
        "detail": "paddleocr",
        "documentation": {}
    },
    {
        "label": "PaddleOCR",
        "importPath": "paddleocr",
        "description": "paddleocr",
        "isExtraImport": true,
        "detail": "paddleocr",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "importPath": "paddleocr",
        "description": "paddleocr",
        "isExtraImport": true,
        "detail": "paddleocr",
        "documentation": {}
    },
    {
        "label": "label_colormap",
        "importPath": "libs.labelColor",
        "description": "libs.labelColor",
        "isExtraImport": true,
        "detail": "libs.labelColor",
        "documentation": {}
    },
    {
        "label": "Settings",
        "importPath": "libs.settings",
        "description": "libs.settings",
        "isExtraImport": true,
        "detail": "libs.settings",
        "documentation": {}
    },
    {
        "label": "StringBundle",
        "importPath": "libs.stringBundle",
        "description": "libs.stringBundle",
        "isExtraImport": true,
        "detail": "libs.stringBundle",
        "documentation": {}
    },
    {
        "label": "Canvas",
        "importPath": "libs.canvas",
        "description": "libs.canvas",
        "isExtraImport": true,
        "detail": "libs.canvas",
        "documentation": {}
    },
    {
        "label": "ZoomWidget",
        "importPath": "libs.zoomWidget",
        "description": "libs.zoomWidget",
        "isExtraImport": true,
        "detail": "libs.zoomWidget",
        "documentation": {}
    },
    {
        "label": "AutoDialog",
        "importPath": "libs.autoDialog",
        "description": "libs.autoDialog",
        "isExtraImport": true,
        "detail": "libs.autoDialog",
        "documentation": {}
    },
    {
        "label": "LabelDialog",
        "importPath": "libs.labelDialog",
        "description": "libs.labelDialog",
        "isExtraImport": true,
        "detail": "libs.labelDialog",
        "documentation": {}
    },
    {
        "label": "ColorDialog",
        "importPath": "libs.colorDialog",
        "description": "libs.colorDialog",
        "isExtraImport": true,
        "detail": "libs.colorDialog",
        "documentation": {}
    },
    {
        "label": "HashableQListWidgetItem",
        "importPath": "libs.hashableQListWidgetItem",
        "description": "libs.hashableQListWidgetItem",
        "isExtraImport": true,
        "detail": "libs.hashableQListWidgetItem",
        "documentation": {}
    },
    {
        "label": "EditInList",
        "importPath": "libs.editinlist",
        "description": "libs.editinlist",
        "isExtraImport": true,
        "detail": "libs.editinlist",
        "documentation": {}
    },
    {
        "label": "UniqueLabelQListWidget",
        "importPath": "libs.unique_label_qlist_widget",
        "description": "libs.unique_label_qlist_widget",
        "isExtraImport": true,
        "detail": "libs.unique_label_qlist_widget",
        "documentation": {}
    },
    {
        "label": "KeyDialog",
        "importPath": "libs.keyDialog",
        "description": "libs.keyDialog",
        "isExtraImport": true,
        "detail": "libs.keyDialog",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "shapely",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shapely",
        "description": "shapely",
        "detail": "shapely",
        "documentation": {}
    },
    {
        "label": "draw_ser_results",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_ser_results",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_re_results",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_rectangle",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_ser_results",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_re_results",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_ser_results",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_re_results",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_rectangle",
        "importPath": "ppocr.utils.visual",
        "description": "ppocr.utils.visual",
        "isExtraImport": true,
        "detail": "ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "make_input",
        "importPath": "tools.infer_kie_token_ser_re",
        "description": "tools.infer_kie_token_ser_re",
        "isExtraImport": true,
        "detail": "tools.infer_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "PicoDetPostProcess",
        "importPath": "picodet_postprocess",
        "description": "picodet_postprocess",
        "isExtraImport": true,
        "detail": "picodet_postprocess",
        "documentation": {}
    },
    {
        "label": "fitz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fitz",
        "description": "fitz",
        "detail": "fitz",
        "documentation": {}
    },
    {
        "label": "Converter",
        "importPath": "pdf2docx.converter",
        "description": "pdf2docx.converter",
        "isExtraImport": true,
        "detail": "pdf2docx.converter",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "qtpy.QtWidgets",
        "description": "qtpy.QtWidgets",
        "isExtraImport": true,
        "detail": "qtpy.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "qtpy.QtWidgets",
        "description": "qtpy.QtWidgets",
        "isExtraImport": true,
        "detail": "qtpy.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QPushButton",
        "importPath": "qtpy.QtWidgets",
        "description": "qtpy.QtWidgets",
        "isExtraImport": true,
        "detail": "qtpy.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QProgressBar",
        "importPath": "qtpy.QtWidgets",
        "description": "qtpy.QtWidgets",
        "isExtraImport": true,
        "detail": "qtpy.QtWidgets",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "qtpy.QtWidgets",
        "description": "qtpy.QtWidgets",
        "isExtraImport": true,
        "detail": "qtpy.QtWidgets",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "qtpy.QtCore",
        "description": "qtpy.QtCore",
        "isExtraImport": true,
        "detail": "qtpy.QtCore",
        "documentation": {}
    },
    {
        "label": "QThread",
        "importPath": "qtpy.QtCore",
        "description": "qtpy.QtCore",
        "isExtraImport": true,
        "detail": "qtpy.QtCore",
        "documentation": {}
    },
    {
        "label": "QObject",
        "importPath": "qtpy.QtCore",
        "description": "qtpy.QtCore",
        "isExtraImport": true,
        "detail": "qtpy.QtCore",
        "documentation": {}
    },
    {
        "label": "QImage",
        "importPath": "qtpy.QtGui",
        "description": "qtpy.QtGui",
        "isExtraImport": true,
        "detail": "qtpy.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "qtpy.QtGui",
        "description": "qtpy.QtGui",
        "isExtraImport": true,
        "detail": "qtpy.QtGui",
        "documentation": {}
    },
    {
        "label": "QIcon",
        "importPath": "qtpy.QtGui",
        "description": "qtpy.QtGui",
        "isExtraImport": true,
        "detail": "qtpy.QtGui",
        "documentation": {}
    },
    {
        "label": "sorted_layout_boxes",
        "importPath": "ppstructure.recovery.recovery_to_doc",
        "description": "ppstructure.recovery.recovery_to_doc",
        "isExtraImport": true,
        "detail": "ppstructure.recovery.recovery_to_doc",
        "documentation": {}
    },
    {
        "label": "convert_info_docx",
        "importPath": "ppstructure.recovery.recovery_to_doc",
        "description": "ppstructure.recovery.recovery_to_doc",
        "isExtraImport": true,
        "detail": "ppstructure.recovery.recovery_to_doc",
        "documentation": {}
    },
    {
        "label": "docx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "docx",
        "description": "docx",
        "detail": "docx",
        "documentation": {}
    },
    {
        "label": "Document",
        "importPath": "docx",
        "description": "docx",
        "isExtraImport": true,
        "detail": "docx",
        "documentation": {}
    },
    {
        "label": "shared",
        "importPath": "docx",
        "description": "docx",
        "isExtraImport": true,
        "detail": "docx",
        "documentation": {}
    },
    {
        "label": "Document",
        "importPath": "docx",
        "description": "docx",
        "isExtraImport": true,
        "detail": "docx",
        "documentation": {}
    },
    {
        "label": "WD_ALIGN_PARAGRAPH",
        "importPath": "docx.enum.text",
        "description": "docx.enum.text",
        "isExtraImport": true,
        "detail": "docx.enum.text",
        "documentation": {}
    },
    {
        "label": "WD_SECTION",
        "importPath": "docx.enum.section",
        "description": "docx.enum.section",
        "isExtraImport": true,
        "detail": "docx.enum.section",
        "documentation": {}
    },
    {
        "label": "qn",
        "importPath": "docx.oxml.ns",
        "description": "docx.oxml.ns",
        "isExtraImport": true,
        "detail": "docx.oxml.ns",
        "documentation": {}
    },
    {
        "label": "WD_TABLE_ALIGNMENT",
        "importPath": "docx.enum.table",
        "description": "docx.enum.table",
        "isExtraImport": true,
        "detail": "docx.enum.table",
        "documentation": {}
    },
    {
        "label": "HtmlToDocx",
        "importPath": "ppstructure.recovery.table_process",
        "description": "ppstructure.recovery.table_process",
        "isExtraImport": true,
        "detail": "ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "HTMLParser",
        "importPath": "html.parser",
        "description": "html.parser",
        "isExtraImport": true,
        "detail": "html.parser",
        "documentation": {}
    },
    {
        "label": "cell",
        "importPath": "openpyxl.cell",
        "description": "openpyxl.cell",
        "isExtraImport": true,
        "detail": "openpyxl.cell",
        "documentation": {}
    },
    {
        "label": "Font",
        "importPath": "openpyxl.styles",
        "description": "openpyxl.styles",
        "isExtraImport": true,
        "detail": "openpyxl.styles",
        "documentation": {}
    },
    {
        "label": "Alignment",
        "importPath": "openpyxl.styles",
        "description": "openpyxl.styles",
        "isExtraImport": true,
        "detail": "openpyxl.styles",
        "documentation": {}
    },
    {
        "label": "PatternFill",
        "importPath": "openpyxl.styles",
        "description": "openpyxl.styles",
        "isExtraImport": true,
        "detail": "openpyxl.styles",
        "documentation": {}
    },
    {
        "label": "NamedStyle",
        "importPath": "openpyxl.styles",
        "description": "openpyxl.styles",
        "isExtraImport": true,
        "detail": "openpyxl.styles",
        "documentation": {}
    },
    {
        "label": "Border",
        "importPath": "openpyxl.styles",
        "description": "openpyxl.styles",
        "isExtraImport": true,
        "detail": "openpyxl.styles",
        "documentation": {}
    },
    {
        "label": "Side",
        "importPath": "openpyxl.styles",
        "description": "openpyxl.styles",
        "isExtraImport": true,
        "detail": "openpyxl.styles",
        "documentation": {}
    },
    {
        "label": "Color",
        "importPath": "openpyxl.styles",
        "description": "openpyxl.styles",
        "isExtraImport": true,
        "detail": "openpyxl.styles",
        "documentation": {}
    },
    {
        "label": "FILL_SOLID",
        "importPath": "openpyxl.styles.fills",
        "description": "openpyxl.styles.fills",
        "isExtraImport": true,
        "detail": "openpyxl.styles.fills",
        "documentation": {}
    },
    {
        "label": "FORMAT_CURRENCY_USD_SIMPLE",
        "importPath": "openpyxl.styles.numbers",
        "description": "openpyxl.styles.numbers",
        "isExtraImport": true,
        "detail": "openpyxl.styles.numbers",
        "documentation": {}
    },
    {
        "label": "FORMAT_PERCENTAGE",
        "importPath": "openpyxl.styles.numbers",
        "description": "openpyxl.styles.numbers",
        "isExtraImport": true,
        "detail": "openpyxl.styles.numbers",
        "documentation": {}
    },
    {
        "label": "BLACK",
        "importPath": "openpyxl.styles.colors",
        "description": "openpyxl.styles.colors",
        "isExtraImport": true,
        "detail": "openpyxl.styles.colors",
        "documentation": {}
    },
    {
        "label": "html",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "etree",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "html",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "Workbook",
        "importPath": "openpyxl",
        "description": "openpyxl",
        "isExtraImport": true,
        "detail": "openpyxl",
        "documentation": {}
    },
    {
        "label": "get_column_letter",
        "importPath": "openpyxl.utils",
        "description": "openpyxl.utils",
        "isExtraImport": true,
        "detail": "openpyxl.utils",
        "documentation": {}
    },
    {
        "label": "Premailer",
        "importPath": "premailer",
        "description": "premailer",
        "isExtraImport": true,
        "detail": "premailer",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "tablepyxl.style",
        "description": "tablepyxl.style",
        "isExtraImport": true,
        "detail": "tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "ProcessPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "as_completed",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "APTED",
        "importPath": "apted",
        "description": "apted",
        "isExtraImport": true,
        "detail": "apted",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "apted",
        "description": "apted",
        "isExtraImport": true,
        "detail": "apted",
        "documentation": {}
    },
    {
        "label": "Tree",
        "importPath": "apted.helpers",
        "description": "apted.helpers",
        "isExtraImport": true,
        "detail": "apted.helpers",
        "documentation": {}
    },
    {
        "label": "TEDS",
        "importPath": "ppstructure.table.table_metric",
        "description": "ppstructure.table.table_metric",
        "isExtraImport": true,
        "detail": "ppstructure.table.table_metric",
        "documentation": {}
    },
    {
        "label": "deal_eb_token",
        "importPath": "ppstructure.table.table_master_match",
        "description": "ppstructure.table.table_master_match",
        "isExtraImport": true,
        "detail": "ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "deal_bb",
        "importPath": "ppstructure.table.table_master_match",
        "description": "ppstructure.table.table_master_match",
        "isExtraImport": true,
        "detail": "ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "TableMasterMatcher",
        "importPath": "ppstructure.table.table_master_match",
        "description": "ppstructure.table.table_master_match",
        "isExtraImport": true,
        "detail": "ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "TableMatch",
        "importPath": "ppstructure.table.matcher",
        "description": "ppstructure.table.matcher",
        "isExtraImport": true,
        "detail": "ppstructure.table.matcher",
        "documentation": {}
    },
    {
        "label": "ppstructure.table.predict_structure",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ppstructure.table.predict_structure",
        "description": "ppstructure.table.predict_structure",
        "detail": "ppstructure.table.predict_structure",
        "documentation": {}
    },
    {
        "label": "spectral_norm",
        "importPath": "arch.spectral_norm",
        "description": "arch.spectral_norm",
        "isExtraImport": true,
        "detail": "arch.spectral_norm",
        "documentation": {}
    },
    {
        "label": "SNConv",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "SNConvTranspose",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "SNConv",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "SNConvTranspose",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "MiddleNet",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "importPath": "arch.base_module",
        "description": "arch.base_module",
        "isExtraImport": true,
        "detail": "arch.base_module",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "arch.encoder",
        "description": "arch.encoder",
        "isExtraImport": true,
        "detail": "arch.encoder",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "importPath": "arch.decoder",
        "description": "arch.decoder",
        "isExtraImport": true,
        "detail": "arch.decoder",
        "documentation": {}
    },
    {
        "label": "DecoderUnet",
        "importPath": "arch.decoder",
        "description": "arch.decoder",
        "isExtraImport": true,
        "detail": "arch.decoder",
        "documentation": {}
    },
    {
        "label": "SingleDecoder",
        "importPath": "arch.decoder",
        "description": "arch.decoder",
        "isExtraImport": true,
        "detail": "arch.decoder",
        "documentation": {}
    },
    {
        "label": "load_dygraph_pretrain",
        "importPath": "utils.load_params",
        "description": "utils.load_params",
        "isExtraImport": true,
        "detail": "utils.load_params",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "utils.logging",
        "description": "utils.logging",
        "isExtraImport": true,
        "detail": "utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "utils.logging",
        "description": "utils.logging",
        "isExtraImport": true,
        "detail": "utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "utils.logging",
        "description": "utils.logging",
        "isExtraImport": true,
        "detail": "utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "utils.logging",
        "description": "utils.logging",
        "isExtraImport": true,
        "detail": "utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "utils.logging",
        "description": "utils.logging",
        "isExtraImport": true,
        "detail": "utils.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "utils.logging",
        "description": "utils.logging",
        "isExtraImport": true,
        "detail": "utils.logging",
        "documentation": {}
    },
    {
        "label": "style_text_rec",
        "importPath": "arch",
        "description": "arch",
        "isExtraImport": true,
        "detail": "arch",
        "documentation": {}
    },
    {
        "label": "check_gpu",
        "importPath": "utils.sys_funcs",
        "description": "utils.sys_funcs",
        "isExtraImport": true,
        "detail": "utils.sys_funcs",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "override_config",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "style_samplers",
        "importPath": "engine",
        "description": "engine",
        "isExtraImport": true,
        "detail": "engine",
        "documentation": {}
    },
    {
        "label": "corpus_generators",
        "importPath": "engine",
        "description": "engine",
        "isExtraImport": true,
        "detail": "engine",
        "documentation": {}
    },
    {
        "label": "text_drawers",
        "importPath": "engine",
        "description": "engine",
        "isExtraImport": true,
        "detail": "engine",
        "documentation": {}
    },
    {
        "label": "predictors",
        "importPath": "engine",
        "description": "engine",
        "isExtraImport": true,
        "detail": "engine",
        "documentation": {}
    },
    {
        "label": "writers",
        "importPath": "engine",
        "description": "engine",
        "isExtraImport": true,
        "detail": "engine",
        "documentation": {}
    },
    {
        "label": "DatasetSynthesiser",
        "importPath": "engine.synthesisers",
        "description": "engine.synthesisers",
        "isExtraImport": true,
        "detail": "engine.synthesisers",
        "documentation": {}
    },
    {
        "label": "ImageSynthesiser",
        "importPath": "engine.synthesisers",
        "description": "engine.synthesisers",
        "isExtraImport": true,
        "detail": "engine.synthesisers",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "paddle.inference",
        "description": "paddle.inference",
        "isExtraImport": true,
        "detail": "paddle.inference",
        "documentation": {}
    },
    {
        "label": "create_predictor",
        "importPath": "paddle.inference",
        "description": "paddle.inference",
        "isExtraImport": true,
        "detail": "paddle.inference",
        "documentation": {}
    },
    {
        "label": "FPGMFilterPruner",
        "importPath": "paddleslim.dygraph",
        "description": "paddleslim.dygraph",
        "isExtraImport": true,
        "detail": "paddleslim.dygraph",
        "documentation": {}
    },
    {
        "label": "Cifar100",
        "importPath": "paddle.vision.datasets",
        "description": "paddle.vision.datasets",
        "isExtraImport": true,
        "detail": "paddle.vision.datasets",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "build_loss",
        "importPath": "loss",
        "description": "loss",
        "isExtraImport": true,
        "detail": "loss",
        "documentation": {}
    },
    {
        "label": "LossDistill",
        "importPath": "loss",
        "description": "loss",
        "isExtraImport": true,
        "detail": "loss",
        "documentation": {}
    },
    {
        "label": "DMLLoss",
        "importPath": "loss",
        "description": "loss",
        "isExtraImport": true,
        "detail": "loss",
        "documentation": {}
    },
    {
        "label": "KLJSLoss",
        "importPath": "loss",
        "description": "loss",
        "isExtraImport": true,
        "detail": "loss",
        "documentation": {}
    },
    {
        "label": "create_optimizer",
        "importPath": "optimizer",
        "description": "optimizer",
        "isExtraImport": true,
        "detail": "optimizer",
        "documentation": {}
    },
    {
        "label": "create_metric",
        "importPath": "metric",
        "description": "metric",
        "isExtraImport": true,
        "detail": "metric",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_large_x0_5",
        "importPath": "mv3",
        "description": "mv3",
        "isExtraImport": true,
        "detail": "mv3",
        "documentation": {}
    },
    {
        "label": "distillmv3_large_x0_5",
        "importPath": "mv3",
        "description": "mv3",
        "isExtraImport": true,
        "detail": "mv3",
        "documentation": {}
    },
    {
        "label": "build_model",
        "importPath": "mv3",
        "description": "mv3",
        "isExtraImport": true,
        "detail": "mv3",
        "documentation": {}
    },
    {
        "label": "preprocess",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "PACT",
        "importPath": "slim.slim_quant",
        "description": "slim.slim_quant",
        "isExtraImport": true,
        "detail": "slim.slim_quant",
        "documentation": {}
    },
    {
        "label": "quant_config",
        "importPath": "slim.slim_quant",
        "description": "slim.slim_quant",
        "isExtraImport": true,
        "detail": "slim.slim_quant",
        "documentation": {}
    },
    {
        "label": "prune_model",
        "importPath": "slim.slim_fpgm",
        "description": "slim.slim_fpgm",
        "isExtraImport": true,
        "detail": "slim.slim_fpgm",
        "documentation": {}
    },
    {
        "label": "editdistance",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "editdistance",
        "description": "editdistance",
        "detail": "editdistance",
        "documentation": {}
    },
    {
        "label": "SerPredictor",
        "importPath": "tools.infer_kie_token_ser",
        "description": "tools.infer_kie_token_ser",
        "isExtraImport": true,
        "detail": "tools.infer_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "TrainingStats",
        "importPath": "ppocr.utils.stats",
        "description": "ppocr.utils.stats",
        "isExtraImport": true,
        "detail": "ppocr.utils.stats",
        "documentation": {}
    },
    {
        "label": "VDLLogger",
        "importPath": "ppocr.utils.loggers",
        "description": "ppocr.utils.loggers",
        "isExtraImport": true,
        "detail": "ppocr.utils.loggers",
        "documentation": {}
    },
    {
        "label": "WandbLogger",
        "importPath": "ppocr.utils.loggers",
        "description": "ppocr.utils.loggers",
        "isExtraImport": true,
        "detail": "ppocr.utils.loggers",
        "documentation": {}
    },
    {
        "label": "Loggers",
        "importPath": "ppocr.utils.loggers",
        "description": "ppocr.utils.loggers",
        "isExtraImport": true,
        "detail": "ppocr.utils.loggers",
        "documentation": {}
    },
    {
        "label": "profiler",
        "importPath": "ppocr.utils",
        "description": "ppocr.utils",
        "isExtraImport": true,
        "detail": "ppocr.utils",
        "documentation": {}
    },
    {
        "label": "predict_system",
        "importPath": "tools.infer",
        "description": "tools.infer",
        "isExtraImport": true,
        "detail": "tools.infer",
        "documentation": {}
    },
    {
        "label": "get_char_lines",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "description": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "peekOfCode": "def get_char_lines(txt_root_path):\n    \"\"\"\n    desc:get corpus line\n    \"\"\"\n    txt_files = os.listdir(txt_root_path)\n    char_lines = []\n    for txt in txt_files:\n        f = open(os.path.join(txt_root_path, txt), mode='r', encoding='utf-8')\n        lines = f.readlines()\n        f.close()",
        "detail": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "documentation": {}
    },
    {
        "label": "get_horizontal_text_picture",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "description": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "peekOfCode": "def get_horizontal_text_picture(image_file, chars, fonts_list, cf):\n    \"\"\"\n    desc:gen horizontal text picture\n    \"\"\"\n    img = Image.open(image_file)\n    if img.mode != 'RGB':\n        img = img.convert('RGB')\n    img_w, img_h = img.size\n    # random choice font\n    font_path = random.choice(fonts_list)",
        "detail": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "documentation": {}
    },
    {
        "label": "get_vertical_text_picture",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "description": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "peekOfCode": "def get_vertical_text_picture(image_file, chars, fonts_list, cf):\n    \"\"\"\n    desc:gen vertical text picture\n    \"\"\"\n    img = Image.open(image_file)\n    if img.mode != 'RGB':\n        img = img.convert('RGB')\n    img_w, img_h = img.size\n    # random choice font\n    font_path = random.choice(fonts_list)",
        "detail": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "documentation": {}
    },
    {
        "label": "get_fonts",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "description": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "peekOfCode": "def get_fonts(fonts_path):\n    \"\"\"\n    desc: get all fonts\n    \"\"\"\n    font_files = os.listdir(fonts_path)\n    fonts_list=[]\n    for font_file in font_files:\n        font_path=os.path.join(fonts_path, font_file)\n        fonts_list.append(font_path)\n    return fonts_list",
        "detail": "Vision.Paddle.PaddleOCR.applications.PCB字符识别.gen_data.gen",
        "documentation": {}
    },
    {
        "label": "BaseDataSet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.base.base_dataset",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.base.base_dataset",
        "peekOfCode": "class BaseDataSet(Dataset):\n    def __init__(self,\n                 data_path: str,\n                 img_mode,\n                 pre_processes,\n                 filter_keys,\n                 ignore_tags,\n                 transform=None,\n                 target_transform=None):\n        assert img_mode in ['RGB', 'BRG', 'GRAY']",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.base.base_dataset",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.base.base_trainer",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.base.base_trainer",
        "peekOfCode": "class BaseTrainer:\n    def __init__(self,\n                 config,\n                 model,\n                 criterion,\n                 train_loader,\n                 validate_loader,\n                 metric_cls,\n                 post_process=None):\n        config['trainer']['output_dir'] = os.path.join(",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.base.base_trainer",
        "documentation": {}
    },
    {
        "label": "RandomNoise",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "class RandomNoise:\n    def __init__(self, random_rate):\n        self.random_rate = random_rate\n    def __call__(self, data: dict):\n        \"\"\"\n        对图片加噪声\n        :param data: {'img':,'text_polys':,'texts':,'ignore_tags':}\n        :return:\n        \"\"\"\n        if random.random() > self.random_rate:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "RandomScale",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "class RandomScale:\n    def __init__(self, scales, random_rate):\n        \"\"\"\n        :param scales: 尺度\n        :param ramdon_rate: 随机系数\n        :return:\n        \"\"\"\n        self.random_rate = random_rate\n        self.scales = scales\n    def __call__(self, data: dict) -> dict:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "RandomRotateImgBox",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "class RandomRotateImgBox:\n    def __init__(self, degrees, random_rate, same_size=False):\n        \"\"\"\n        :param degrees: 角度，可以是一个数值或者list\n        :param ramdon_rate: 随机系数\n        :param same_size: 是否保持和原图一样大\n        :return:\n        \"\"\"\n        if isinstance(degrees, numbers.Number):\n            if degrees < 0:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "RandomResize",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "class RandomResize:\n    def __init__(self, size, random_rate, keep_ratio=False):\n        \"\"\"\n        :param input_size: resize尺寸,数字或者list的形式，如果为list形式，就是[w,h]\n        :param ramdon_rate: 随机系数\n        :param keep_ratio: 是否保持长宽比\n        :return:\n        \"\"\"\n        if isinstance(size, numbers.Number):\n            if size < 0:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "ResizeShortSize",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "class ResizeShortSize:\n    def __init__(self, short_size, resize_text_polys=True):\n        \"\"\"\n        :param size: resize尺寸,数字或者list的形式，如果为list形式，就是[w,h]\n        :return:\n        \"\"\"\n        self.short_size = short_size\n        self.resize_text_polys = resize_text_polys\n    def __call__(self, data: dict) -> dict:\n        \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "HorizontalFlip",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "class HorizontalFlip:\n    def __init__(self, random_rate):\n        \"\"\"\n        :param random_rate: 随机系数\n        \"\"\"\n        self.random_rate = random_rate\n    def __call__(self, data: dict) -> dict:\n        \"\"\"\n        从scales中随机选择一个尺度，对图片和文本框进行缩放\n        :param data: {'img':,'text_polys':,'texts':,'ignore_tags':}",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "VerticallFlip",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "class VerticallFlip:\n    def __init__(self, random_rate):\n        \"\"\"\n        :param random_rate: 随机系数\n        \"\"\"\n        self.random_rate = random_rate\n    def __call__(self, data: dict) -> dict:\n        \"\"\"\n        从scales中随机选择一个尺度，对图片和文本框进行缩放\n        :param data: {'img':,'text_polys':,'texts':,'ignore_tags':}",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "resize_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "peekOfCode": "def resize_image(img, short_size):\n    height, width, _ = img.shape\n    if height < width:\n        new_height = short_size\n        new_width = new_height / height * width\n    else:\n        new_width = short_size\n        new_height = new_width / width * height\n    new_height = int(round(new_height / 32) * 32)\n    new_width = int(round(new_width / 32) * 32)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.augment",
        "documentation": {}
    },
    {
        "label": "AugmenterBuilder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.iaa_augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.iaa_augment",
        "peekOfCode": "class AugmenterBuilder(object):\n    def __init__(self):\n        pass\n    def build(self, args, root=True):\n        if args is None or len(args) == 0:\n            return None\n        elif isinstance(args, list):\n            if root:\n                sequence = [self.build(value, root=False) for value in args]\n                return iaa.Sequential(sequence)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.iaa_augment",
        "documentation": {}
    },
    {
        "label": "IaaAugment",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.iaa_augment",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.iaa_augment",
        "peekOfCode": "class IaaAugment():\n    def __init__(self, augmenter_args):\n        self.augmenter_args = augmenter_args\n        self.augmenter = AugmenterBuilder().build(self.augmenter_args)\n    def __call__(self, data):\n        image = data['img']\n        shape = image.shape\n        if self.augmenter:\n            aug = self.augmenter.to_deterministic()\n            data['img'] = aug.augment_image(image)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.iaa_augment",
        "documentation": {}
    },
    {
        "label": "MakeBorderMap",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_border_map",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_border_map",
        "peekOfCode": "class MakeBorderMap():\n    def __init__(self, shrink_ratio=0.4, thresh_min=0.3, thresh_max=0.7):\n        self.shrink_ratio = shrink_ratio\n        self.thresh_min = thresh_min\n        self.thresh_max = thresh_max\n    def __call__(self, data: dict) -> dict:\n        \"\"\"\n        从scales中随机选择一个尺度，对图片和文本框进行缩放\n        :param data: {'img':,'text_polys':,'texts':,'ignore_tags':}\n        :return:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_border_map",
        "documentation": {}
    },
    {
        "label": "MakeShrinkMap",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "peekOfCode": "class MakeShrinkMap():\n    r'''\n    Making binary mask from detection data with ICDAR format.\n    Typically following the process of class `MakeICDARData`.\n    '''\n    def __init__(self,\n                 min_text_size=8,\n                 shrink_ratio=0.4,\n                 shrink_type='pyclipper'):\n        shrink_func_dict = {",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "documentation": {}
    },
    {
        "label": "shrink_polygon_py",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "peekOfCode": "def shrink_polygon_py(polygon, shrink_ratio):\n    \"\"\"\n    对框进行缩放，返回去的比例为1/shrink_ratio 即可\n    \"\"\"\n    cx = polygon[:, 0].mean()\n    cy = polygon[:, 1].mean()\n    polygon[:, 0] = cx + (polygon[:, 0] - cx) * shrink_ratio\n    polygon[:, 1] = cy + (polygon[:, 1] - cy) * shrink_ratio\n    return polygon\ndef shrink_polygon_pyclipper(polygon, shrink_ratio):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "documentation": {}
    },
    {
        "label": "shrink_polygon_pyclipper",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "peekOfCode": "def shrink_polygon_pyclipper(polygon, shrink_ratio):\n    from shapely.geometry import Polygon\n    import pyclipper\n    polygon_shape = Polygon(polygon)\n    distance = polygon_shape.area * (\n        1 - np.power(shrink_ratio, 2)) / polygon_shape.length\n    subject = [tuple(l) for l in polygon]\n    padding = pyclipper.PyclipperOffset()\n    padding.AddPath(subject, pyclipper.JT_ROUND, pyclipper.ET_CLOSEDPOLYGON)\n    shrinked = padding.Execute(-distance)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.make_shrink_map",
        "documentation": {}
    },
    {
        "label": "EastRandomCropData",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.random_crop_data",
        "peekOfCode": "class EastRandomCropData():\n    def __init__(self,\n                 size=(640, 640),\n                 max_tries=50,\n                 min_crop_side_ratio=0.1,\n                 require_original_image=False,\n                 keep_ratio=True):\n        self.size = size\n        self.max_tries = max_tries\n        self.min_crop_side_ratio = min_crop_side_ratio",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.random_crop_data",
        "documentation": {}
    },
    {
        "label": "PSERandomCrop",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.random_crop_data",
        "peekOfCode": "class PSERandomCrop():\n    def __init__(self, size):\n        self.size = size\n    def __call__(self, data):\n        imgs = data['imgs']\n        h, w = imgs[0].shape[0:2]\n        th, tw = self.size\n        if w == tw and h == th:\n            return imgs\n        # label中存在文本实例，并且按照概率进行裁剪，使用threshold_label_map控制",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.modules.random_crop_data",
        "documentation": {}
    },
    {
        "label": "ICDAR2015Dataset",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "peekOfCode": "class ICDAR2015Dataset(BaseDataSet):\n    def __init__(self,\n                 data_path: str,\n                 img_mode,\n                 pre_processes,\n                 filter_keys,\n                 ignore_tags,\n                 transform=None,\n                 **kwargs):\n        super().__init__(data_path, img_mode, pre_processes, filter_keys,",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "documentation": {}
    },
    {
        "label": "DetDataset",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "peekOfCode": "class DetDataset(BaseDataSet):\n    def __init__(self,\n                 data_path: str,\n                 img_mode,\n                 pre_processes,\n                 filter_keys,\n                 ignore_tags,\n                 transform=None,\n                 **kwargs):\n        self.load_char_annotation = kwargs['load_char_annotation']",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "documentation": {}
    },
    {
        "label": "SynthTextDataset",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "peekOfCode": "class SynthTextDataset(BaseDataSet):\n    def __init__(self,\n                 data_path: str,\n                 img_mode,\n                 pre_processes,\n                 filter_keys,\n                 transform=None,\n                 **kwargs):\n        self.transform = transform\n        self.dataRoot = pathlib.Path(data_path)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.data_loader.dataset",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    expansion = 1\n    def __init__(self, inplanes, planes, stride=1, downsample=None, dcn=None):\n        super(BasicBlock, self).__init__()\n        self.with_dcn = dcn is not None\n        self.conv1 = conv3x3(inplanes, planes, stride)\n        self.bn1 = BatchNorm2d(planes, momentum=0.1)\n        self.relu = nn.ReLU()\n        self.with_modulated_dcn = False\n        if not self.with_dcn:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "Bottleneck",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "class Bottleneck(nn.Layer):\n    expansion = 4\n    def __init__(self, inplanes, planes, stride=1, downsample=None, dcn=None):\n        super(Bottleneck, self).__init__()\n        self.with_dcn = dcn is not None\n        self.conv1 = nn.Conv2D(inplanes, planes, kernel_size=1, bias_attr=False)\n        self.bn1 = BatchNorm2d(planes, momentum=0.1)\n        self.with_modulated_dcn = False\n        if not self.with_dcn:\n            self.conv2 = nn.Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "ResNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "class ResNet(nn.Layer):\n    def __init__(self, block, layers, in_channels=3, dcn=None):\n        self.dcn = dcn\n        self.inplanes = 64\n        super(ResNet, self).__init__()\n        self.out_channels = []\n        self.conv1 = nn.Conv2D(\n            in_channels,\n            64,\n            kernel_size=7,",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "constant_init",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def constant_init(module, constant, bias=0):\n    module.weight = paddle.create_parameter(\n        shape=module.weight.shape,\n        dtype='float32',\n        default_initializer=paddle.nn.initializer.Constant(constant))\n    if hasattr(module, 'bias'):\n        module.bias = paddle.create_parameter(\n            shape=module.bias.shape,\n            dtype='float32',\n            default_initializer=paddle.nn.initializer.Constant(bias))",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "conv3x3",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def conv3x3(in_planes, out_planes, stride=1):\n    \"\"\"3x3 convolution with padding\"\"\"\n    return nn.Conv2D(\n        in_planes,\n        out_planes,\n        kernel_size=3,\n        stride=stride,\n        padding=1,\n        bias_attr=False)\nclass BasicBlock(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "load_torch_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def load_torch_params(paddle_model, torch_patams):\n    paddle_params = paddle_model.state_dict()\n    fc_names = ['classifier']\n    for key, torch_value in torch_patams.items():\n        if 'num_batches_tracked' in key:\n            continue\n        key = key.replace(\"running_var\", \"_variance\").replace(\n            \"running_mean\", \"_mean\").replace(\"module.\", \"\")\n        torch_value = torch_value.detach().cpu().numpy()\n        if key in paddle_params:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "load_models",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def load_models(model, model_name):\n    import torch.utils.model_zoo as model_zoo\n    torch_patams = model_zoo.load_url(model_urls[model_name])\n    load_torch_params(model, torch_patams)\ndef resnet18(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-18 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(BasicBlock, [2, 2, 2, 2], **kwargs)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "resnet18",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def resnet18(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-18 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(BasicBlock, [2, 2, 2, 2], **kwargs)\n    if pretrained:\n        assert kwargs.get(\n            'in_channels',\n            3) == 3, 'in_channels must be 3 whem pretrained is True'",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "deformable_resnet18",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def deformable_resnet18(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-18 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(\n        BasicBlock, [2, 2, 2, 2], dcn=dict(deformable_groups=1), **kwargs)\n    if pretrained:\n        assert kwargs.get(\n            'in_channels',",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "resnet34",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def resnet34(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-34 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(BasicBlock, [3, 4, 6, 3], **kwargs)\n    if pretrained:\n        assert kwargs.get(\n            'in_channels',\n            3) == 3, 'in_channels must be 3 whem pretrained is True'",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "resnet50",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def resnet50(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-50 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(Bottleneck, [3, 4, 6, 3], **kwargs)\n    if pretrained:\n        assert kwargs.get(\n            'in_channels',\n            3) == 3, 'in_channels must be 3 whem pretrained is True'",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "deformable_resnet50",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def deformable_resnet50(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-50 model with deformable conv.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(\n        Bottleneck, [3, 4, 6, 3], dcn=dict(deformable_groups=1), **kwargs)\n    if pretrained:\n        assert kwargs.get(\n            'in_channels',",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "resnet101",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def resnet101(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-101 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(Bottleneck, [3, 4, 23, 3], **kwargs)\n    if pretrained:\n        assert kwargs.get(\n            'in_channels',\n            3) == 3, 'in_channels must be 3 whem pretrained is True'",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "resnet152",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "def resnet152(pretrained=True, **kwargs):\n    \"\"\"Constructs a ResNet-152 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(Bottleneck, [3, 8, 36, 3], **kwargs)\n    if pretrained:\n        assert kwargs.get(\n            'in_channels',\n            3) == 3, 'in_channels must be 3 whem pretrained is True'",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "BatchNorm2d",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "BatchNorm2d = nn.BatchNorm2D\n__all__ = [\n    'ResNet', 'resnet18', 'resnet34', 'resnet50', 'resnet101',\n    'deformable_resnet18', 'deformable_resnet50', 'resnet152'\n]\nmodel_urls = {\n    'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth',\n    'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth',\n    'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth',\n    'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth',",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "__all__ = [\n    'ResNet', 'resnet18', 'resnet34', 'resnet50', 'resnet101',\n    'deformable_resnet18', 'deformable_resnet50', 'resnet152'\n]\nmodel_urls = {\n    'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth',\n    'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth',\n    'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth',\n    'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth',\n    'resnet152': 'https://download.pytorch.org/models/resnet152-b121ed2d.pth',",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "model_urls",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "peekOfCode": "model_urls = {\n    'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth',\n    'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth',\n    'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth',\n    'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth',\n    'resnet152': 'https://download.pytorch.org/models/resnet152-b121ed2d.pth',\n}\ndef constant_init(module, constant, bias=0):\n    module.weight = paddle.create_parameter(\n        shape=module.weight.shape,",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.backbone.resnet",
        "documentation": {}
    },
    {
        "label": "DBHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.head.DBHead",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.head.DBHead",
        "peekOfCode": "class DBHead(nn.Layer):\n    def __init__(self, in_channels, out_channels, k=50):\n        super().__init__()\n        self.k = k\n        self.binarize = nn.Sequential(\n            nn.Conv2D(\n                in_channels,\n                in_channels // 4,\n                3,\n                padding=1,",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.head.DBHead",
        "documentation": {}
    },
    {
        "label": "BalanceCrossEntropyLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "peekOfCode": "class BalanceCrossEntropyLoss(nn.Layer):\n    '''\n    Balanced cross entropy loss.\n    Shape:\n        - Input: :math:`(N, 1, H, W)`\n        - GT: :math:`(N, 1, H, W)`, same shape as the input\n        - Mask: :math:`(N, H, W)`, same spatial shape as the input\n        - Output: scalar.\n    '''\n    def __init__(self, negative_ratio=3.0, eps=1e-6):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "DiceLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "peekOfCode": "class DiceLoss(nn.Layer):\n    '''\n    Loss function from https://arxiv.org/abs/1707.03237,\n    where iou computation is introduced heatmap manner to measure the\n    diversity bwtween tow heatmaps.\n    '''\n    def __init__(self, eps=1e-6):\n        super(DiceLoss, self).__init__()\n        self.eps = eps\n    def forward(self, pred: paddle.Tensor, gt, mask, weights=None):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "MaskL1Loss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "peekOfCode": "class MaskL1Loss(nn.Layer):\n    def __init__(self, eps=1e-6):\n        super(MaskL1Loss, self).__init__()\n        self.eps = eps\n    def forward(self, pred: paddle.Tensor, gt, mask):\n        loss = (paddle.abs(pred - gt) * mask).sum() / (mask.sum() + self.eps)\n        return loss",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "DBLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.DB_loss",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.DB_loss",
        "peekOfCode": "class DBLoss(paddle.nn.Layer):\n    def __init__(self,\n                 alpha=1.0,\n                 beta=10,\n                 ohem_ratio=3,\n                 reduction='mean',\n                 eps=1e-06):\n        \"\"\"\n        Implement PSE Loss.\n        :param alpha: binary_map loss 前面的系数",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.losses.DB_loss",
        "documentation": {}
    },
    {
        "label": "FPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.neck.FPN",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.neck.FPN",
        "peekOfCode": "class FPN(nn.Layer):\n    def __init__(self, in_channels, inner_channels=256, **kwargs):\n        \"\"\"\n        :param in_channels: 基础网络输出的维度\n        :param kwargs:\n        \"\"\"\n        super().__init__()\n        inplace = True\n        self.conv_out = inner_channels\n        inner_channels = inner_channels // 4",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.neck.FPN",
        "documentation": {}
    },
    {
        "label": "ConvBnRelu",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.basic",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.basic",
        "peekOfCode": "class ConvBnRelu(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 padding=0,\n                 dilation=1,\n                 groups=1,\n                 bias=True,",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.basic",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.model",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.model",
        "peekOfCode": "class Model(nn.Layer):\n    def __init__(self, model_config: dict):\n        \"\"\"\n        PANnet\n        :param model_config: 模型配置\n        \"\"\"\n        super().__init__()\n        model_config = Dict(model_config)\n        backbone_type = model_config.backbone.pop('type')\n        neck_type = model_config.neck.pop('type')",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.models.model",
        "documentation": {}
    },
    {
        "label": "SegDetectorRepresenter",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.post_processing.seg_detector_representer",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.post_processing.seg_detector_representer",
        "peekOfCode": "class SegDetectorRepresenter():\n    def __init__(self,\n                 thresh=0.3,\n                 box_thresh=0.7,\n                 max_candidates=1000,\n                 unclip_ratio=1.5):\n        self.min_size = 3\n        self.thresh = thresh\n        self.box_thresh = box_thresh\n        self.max_candidates = max_candidates",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.post_processing.seg_detector_representer",
        "documentation": {}
    },
    {
        "label": "EVAL",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "peekOfCode": "class EVAL():\n    def __init__(self, model_path, gpu_id=0):\n        from models import build_model\n        from data_loader import get_dataloader\n        from post_processing import get_post_processing\n        from utils import get_metric\n        self.gpu_id = gpu_id\n        if self.gpu_id is not None and isinstance(\n                self.gpu_id, int) and paddle.device.is_compiled_with_cuda():\n            paddle.device.set_device(\"gpu:{}\".format(self.gpu_id))",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "peekOfCode": "def init_args():\n    parser = argparse.ArgumentParser(description='DBNet.paddle')\n    parser.add_argument(\n        '--model_path',\n        required=False,\n        default='output/DBNet_resnet18_FPN_DBHead/checkpoint/1.pth',\n        type=str)\n    args = parser.parse_args()\n    return args\nif __name__ == '__main__':",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "peekOfCode": "__dir__ = pathlib.Path(os.path.abspath(__file__))\nsys.path.append(str(__dir__))\nsys.path.append(str(__dir__.parent.parent))\nimport argparse\nimport time\nimport paddle\nfrom tqdm.auto import tqdm\nclass EVAL():\n    def __init__(self, model_path, gpu_id=0):\n        from models import build_model",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.eval",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "peekOfCode": "def init_args():\n    parser = ArgsParser()\n    args = parser.parse_args()\n    return args\ndef load_checkpoint(model, checkpoint_path):\n    \"\"\"\n    load checkpoints\n    :param checkpoint_path: Checkpoint path to be loaded\n    \"\"\"\n    checkpoint = paddle.load(checkpoint_path)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "documentation": {}
    },
    {
        "label": "load_checkpoint",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "peekOfCode": "def load_checkpoint(model, checkpoint_path):\n    \"\"\"\n    load checkpoints\n    :param checkpoint_path: Checkpoint path to be loaded\n    \"\"\"\n    checkpoint = paddle.load(checkpoint_path)\n    model.set_state_dict(checkpoint['state_dict'])\n    print('load checkpoint from {}'.format(checkpoint_path))\ndef main(config):\n    model = build_model(config['arch'])",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "peekOfCode": "def main(config):\n    model = build_model(config['arch'])\n    load_checkpoint(model, config['trainer']['resume_checkpoint'])\n    model.eval()\n    save_path = config[\"trainer\"][\"output_dir\"]\n    save_path = os.path.join(save_path, \"inference\")\n    infer_shape = [3, -1, -1]\n    model = to_static(\n        model,\n        input_spec=[",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, \"..\")))\nimport argparse\nimport paddle\nfrom paddle.jit import to_static\nfrom models import build_model\nfrom utils import Config, ArgsParser\ndef init_args():\n    parser = ArgsParser()",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.export_model",
        "documentation": {}
    },
    {
        "label": "InferenceEngine",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "peekOfCode": "class InferenceEngine(object):\n    \"\"\"InferenceEngine\n    Inference engina class which contains preprocess, run, postprocess\n    \"\"\"\n    def __init__(self, args):\n        \"\"\"\n        Args:\n            args: Parameters generated using argparser.\n        Returns: None\n        \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "documentation": {}
    },
    {
        "label": "get_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "peekOfCode": "def get_args(add_help=True):\n    \"\"\"\n    parse args\n    \"\"\"\n    import argparse\n    def str2bool(v):\n        return v.lower() in (\"true\", \"t\", \"1\")\n    parser = argparse.ArgumentParser(\n        description=\"PaddlePaddle Classification Training\", add_help=add_help)\n    parser.add_argument(\"--model_dir\", default=None, help=\"inference model dir\")",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "peekOfCode": "def main(args):\n    \"\"\"\n    Main inference function.\n    Args:\n        args: Parameters generated using argparser.\n    Returns:\n        class_id: Class index of the input.\n        prob: : Probability of the input.\n    \"\"\"\n    inference_engine = InferenceEngine(args)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "peekOfCode": "__dir__ = pathlib.Path(os.path.abspath(__file__))\nsys.path.append(str(__dir__))\nsys.path.append(str(__dir__.parent.parent))\nimport cv2\nimport paddle\nfrom paddle import inference\nimport numpy as np\nfrom PIL import Image\nfrom paddle.vision import transforms\nfrom tools.predict import resize_image",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.infer",
        "documentation": {}
    },
    {
        "label": "PaddleModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "peekOfCode": "class PaddleModel:\n    def __init__(self, model_path, post_p_thre=0.7, gpu_id=None):\n        '''\n        初始化模型\n        :param model_path: 模型地址(可以是模型的参数或者参数和计算图一起保存的文件)\n        :param gpu_id: 在哪一块gpu上运行\n        '''\n        self.gpu_id = gpu_id\n        if self.gpu_id is not None and isinstance(\n                self.gpu_id, int) and paddle.device.is_compiled_with_cuda():",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "documentation": {}
    },
    {
        "label": "resize_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "peekOfCode": "def resize_image(img, short_size):\n    height, width, _ = img.shape\n    if height < width:\n        new_height = short_size\n        new_width = new_height / height * width\n    else:\n        new_width = short_size\n        new_height = new_width / width * height\n    new_height = int(round(new_height / 32) * 32)\n    new_width = int(round(new_width / 32) * 32)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "documentation": {}
    },
    {
        "label": "save_depoly",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "peekOfCode": "def save_depoly(net, input, save_path):\n    input_spec = [\n        paddle.static.InputSpec(\n            shape=[None, 3, None, None], dtype=\"float32\")\n    ]\n    net = paddle.jit.to_static(net, input_spec=input_spec)\n    # save static model for inference directly\n    paddle.jit.save(net, save_path)\ndef init_args():\n    import argparse",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "peekOfCode": "def init_args():\n    import argparse\n    parser = argparse.ArgumentParser(description='DBNet.paddle')\n    parser.add_argument('--model_path', default=r'model_best.pth', type=str)\n    parser.add_argument(\n        '--input_folder',\n        default='./test/input',\n        type=str,\n        help='img path for predict')\n    parser.add_argument(",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "peekOfCode": "__dir__ = pathlib.Path(os.path.abspath(__file__))\nsys.path.append(str(__dir__))\nsys.path.append(str(__dir__.parent.parent))\nimport time\nimport cv2\nimport paddle\nfrom data_loader import get_transforms\nfrom models import build_model\nfrom post_processing import get_post_processing\ndef resize_image(img, short_size):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.predict",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "peekOfCode": "def init_args():\n    parser = ArgsParser()\n    args = parser.parse_args()\n    return args\ndef main(config, profiler_options):\n    from models import build_model, build_loss\n    from data_loader import get_dataloader\n    from trainer import Trainer\n    from post_processing import get_post_processing\n    from utils import get_metric",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "peekOfCode": "def main(config, profiler_options):\n    from models import build_model, build_loss\n    from data_loader import get_dataloader\n    from trainer import Trainer\n    from post_processing import get_post_processing\n    from utils import get_metric\n    if paddle.device.cuda.device_count() > 1:\n        dist.init_parallel_env()\n        config['distributed'] = True\n    else:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "peekOfCode": "__dir__ = pathlib.Path(os.path.abspath(__file__))\nsys.path.append(str(__dir__))\nsys.path.append(str(__dir__.parent.parent))\nimport paddle\nimport paddle.distributed as dist\nfrom utils import Config, ArgsParser\ndef init_args():\n    parser = ArgsParser()\n    args = parser.parse_args()\n    return args",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.tools.train",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.trainer.trainer",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.trainer.trainer",
        "peekOfCode": "class Trainer(BaseTrainer):\n    def __init__(self,\n                 config,\n                 model,\n                 criterion,\n                 train_loader,\n                 validate_loader,\n                 metric_cls,\n                 post_process=None,\n                 profiler_options=None):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.trainer.trainer",
        "documentation": {}
    },
    {
        "label": "print_help",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def print_help():\n    sys.stdout.write(\n        'Usage: python %s.py -g=<gtFile> -s=<submFile> [-o=<outputFolder> -p=<jsonParams>]'\n        % sys.argv[0])\n    sys.exit(2)\ndef load_zip_file_keys(file, fileNameRegExp=''):\n    \"\"\"\n    Returns an array with the entries of the ZIP file that match with the regular expression.\n    The key's are the names or the file or the capturing group definied in the fileNameRegExp\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "load_zip_file_keys",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def load_zip_file_keys(file, fileNameRegExp=''):\n    \"\"\"\n    Returns an array with the entries of the ZIP file that match with the regular expression.\n    The key's are the names or the file or the capturing group definied in the fileNameRegExp\n    \"\"\"\n    try:\n        archive = zipfile.ZipFile(file, mode='r', allowZip64=True)\n    except:\n        raise Exception('Error loading the ZIP archive.')\n    pairs = []",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "load_zip_file",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def load_zip_file(file, fileNameRegExp='', allEntries=False):\n    \"\"\"\n    Returns an array with the contents (filtered by fileNameRegExp) of a ZIP file.\n    The key's are the names or the file or the capturing group definied in the fileNameRegExp\n    allEntries validates that all entries in the ZIP file pass the fileNameRegExp\n    \"\"\"\n    try:\n        archive = zipfile.ZipFile(file, mode='r', allowZip64=True)\n    except:\n        raise Exception('Error loading the ZIP archive')",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "load_folder_file",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def load_folder_file(file, fileNameRegExp='', allEntries=False):\n    \"\"\"\n    Returns an array with the contents (filtered by fileNameRegExp) of a ZIP file.\n    The key's are the names or the file or the capturing group definied in the fileNameRegExp\n    allEntries validates that all entries in the ZIP file pass the fileNameRegExp\n    \"\"\"\n    pairs = []\n    for name in os.listdir(file):\n        addFile = True\n        keyName = name",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "decode_utf8",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def decode_utf8(raw):\n    \"\"\"\n    Returns a Unicode object on success, or None on failure\n    \"\"\"\n    try:\n        raw = codecs.decode(raw, 'utf-8', 'replace')\n        #extracts BOM if exists\n        raw = raw.encode('utf8')\n        if raw.startswith(codecs.BOM_UTF8):\n            raw = raw.replace(codecs.BOM_UTF8, '', 1)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "validate_lines_in_file",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def validate_lines_in_file(fileName,\n                           file_contents,\n                           CRLF=True,\n                           LTRB=True,\n                           withTranscription=False,\n                           withConfidence=False,\n                           imWidth=0,\n                           imHeight=0):\n    \"\"\"\n    This function validates that all lines of the file calling the Line validation function for each line",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "validate_tl_line",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def validate_tl_line(line,\n                     LTRB=True,\n                     withTranscription=True,\n                     withConfidence=True,\n                     imWidth=0,\n                     imHeight=0):\n    \"\"\"\n    Validate the format of the line. If the line is not valid an exception will be raised.\n    If maxWidth and maxHeight are specified, all points must be inside the imgage bounds.\n    Posible values are:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "get_tl_line_values",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def get_tl_line_values(line,\n                       LTRB=True,\n                       withTranscription=False,\n                       withConfidence=False,\n                       imWidth=0,\n                       imHeight=0):\n    \"\"\"\n    Validate the format of the line. If the line is not valid an exception will be raised.\n    If maxWidth and maxHeight are specified, all points must be inside the imgage bounds.\n    Posible values are:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "validate_point_inside_bounds",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def validate_point_inside_bounds(x, y, imWidth, imHeight):\n    if (x < 0 or x > imWidth):\n        raise Exception(\"X value (%s) not valid. Image dimensions: (%s,%s)\" %\n                        (xmin, imWidth, imHeight))\n    if (y < 0 or y > imHeight):\n        raise Exception(\n            \"Y value (%s)  not valid. Image dimensions: (%s,%s) Sample: %s Line:%s\"\n            % (ymin, imWidth, imHeight))\ndef validate_clockwise_points(points):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "validate_clockwise_points",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def validate_clockwise_points(points):\n    \"\"\"\n    Validates that the points that the 4 points that dlimite a polygon are in clockwise order.\n    \"\"\"\n    if len(points) != 8:\n        raise Exception(\"Points list not valid.\" + str(len(points)))\n    point = [[int(points[0]), int(points[1])],\n             [int(points[2]), int(points[3])],\n             [int(points[4]), int(points[5])],\n             [int(points[6]), int(points[7])]]",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "get_tl_line_values_from_file_contents",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def get_tl_line_values_from_file_contents(content,\n                                          CRLF=True,\n                                          LTRB=True,\n                                          withTranscription=False,\n                                          withConfidence=False,\n                                          imWidth=0,\n                                          imHeight=0,\n                                          sort_by_confidences=True):\n    \"\"\"\n    Returns all points, confindences and transcriptions of a file in lists. Valid line formats:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "main_evaluation",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def main_evaluation(p,\n                    default_evaluation_params_fn,\n                    validate_data_fn,\n                    evaluate_method_fn,\n                    show_result=True,\n                    per_sample=True):\n    \"\"\"\n    This process validates a method, evaluates it and if it succed generates a ZIP file with a JSON entry for each sample.\n    Params:\n    p: Dictionary of parmeters with the GT/submission locations. If None is passed, the parameters send by the system are used.",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "main_validation",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "peekOfCode": "def main_validation(default_evaluation_params_fn, validate_data_fn):\n    \"\"\"\n    This process validates a method\n    Params:\n    default_evaluation_params_fn: points to a function that returns a dictionary with the default parameters used for the evaluation\n    validate_data_fn: points to a method that validates the corrct format of the submission\n    \"\"\"\n    try:\n        p = dict([s[1:].split('=') for s in sys.argv[1:]])\n        evalParams = default_evaluation_params_fn()",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.rrc_evaluation_funcs",
        "documentation": {}
    },
    {
        "label": "default_evaluation_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "peekOfCode": "def default_evaluation_params():\n    \"\"\"\n    default_evaluation_params: Default parameters to use for the validation and evaluation.\n    \"\"\"\n    return {\n        'IOU_CONSTRAINT': 0.5,\n        'AREA_PRECISION_CONSTRAINT': 0.5,\n        'GT_SAMPLE_NAME_2_ID': 'gt_img_([0-9]+).txt',\n        'DET_SAMPLE_NAME_2_ID': 'res_img_([0-9]+).txt',\n        'LTRB':",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "documentation": {}
    },
    {
        "label": "validate_data",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "peekOfCode": "def validate_data(gtFilePath, submFilePath, evaluationParams):\n    \"\"\"\n    Method validate_data: validates that all files in the results folder are correct (have the correct name contents).\n                            Validates also that there are no missing files in the folder.\n                            If some error detected, the method raises the error\n    \"\"\"\n    gt = rrc_evaluation_funcs.load_folder_file(\n        gtFilePath, evaluationParams['GT_SAMPLE_NAME_2_ID'])\n    subm = rrc_evaluation_funcs.load_folder_file(\n        submFilePath, evaluationParams['DET_SAMPLE_NAME_2_ID'], True)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "documentation": {}
    },
    {
        "label": "evaluate_method",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "peekOfCode": "def evaluate_method(gtFilePath, submFilePath, evaluationParams):\n    \"\"\"\n    Method evaluate_method: evaluate method and returns the results\n        Results. Dictionary with the following values:\n        - method (required)  Global method metrics. Ex: { 'Precision':0.8,'Recall':0.9 }\n        - samples (optional) Per sample metrics. Ex: {'sample1' : { 'Precision':0.8,'Recall':0.9 } , 'sample2' : { 'Precision':0.8,'Recall':0.9 }\n    \"\"\"\n    def polygon_from_points(points):\n        \"\"\"\n        Returns a Polygon object to use with the Polygon2 class from a list of 8 points: x1,y1,x2,y2,x3,y3,x4,y4",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "documentation": {}
    },
    {
        "label": "cal_recall_precison_f1",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "peekOfCode": "def cal_recall_precison_f1(gt_path, result_path, show_result=False):\n    p = {'g': gt_path, 's': result_path}\n    result = rrc_evaluation_funcs.main_evaluation(p, default_evaluation_params,\n                                                  validate_data,\n                                                  evaluate_method, show_result)\n    return result['method']",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.cal_recall.script",
        "documentation": {}
    },
    {
        "label": "DetectionDetEvalEvaluator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.deteval",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.deteval",
        "peekOfCode": "class DetectionDetEvalEvaluator(object):\n    def __init__(self,\n                 area_recall_constraint=0.8,\n                 area_precision_constraint=0.4,\n                 ev_param_ind_center_diff_thr=1,\n                 mtype_oo_o=1.0,\n                 mtype_om_o=0.8,\n                 mtype_om_m=1.0):\n        self.area_recall_constraint = area_recall_constraint\n        self.area_precision_constraint = area_precision_constraint",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.deteval",
        "documentation": {}
    },
    {
        "label": "DetectionICDAR2013Evaluator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.icdar2013",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.icdar2013",
        "peekOfCode": "class DetectionICDAR2013Evaluator(object):\n    def __init__(self,\n                 area_recall_constraint=0.8,\n                 area_precision_constraint=0.4,\n                 ev_param_ind_center_diff_thr=1,\n                 mtype_oo_o=1.0,\n                 mtype_om_o=0.8,\n                 mtype_om_m=1.0):\n        self.area_recall_constraint = area_recall_constraint\n        self.area_precision_constraint = area_precision_constraint",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.icdar2013",
        "documentation": {}
    },
    {
        "label": "DetectionIoUEvaluator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.iou",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.iou",
        "peekOfCode": "class DetectionIoUEvaluator(object):\n    def __init__(self,\n                 is_output_polygon=False,\n                 iou_constraint=0.5,\n                 area_precision_constraint=0.5):\n        self.is_output_polygon = is_output_polygon\n        self.iou_constraint = iou_constraint\n        self.area_precision_constraint = area_precision_constraint\n    def evaluate_image(self, gt, pred):\n        def get_union(pD, pG):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.iou",
        "documentation": {}
    },
    {
        "label": "iou_rotate",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.iou",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.iou",
        "peekOfCode": "def iou_rotate(box_a, box_b, method='union'):\n    rect_a = cv2.minAreaRect(box_a)\n    rect_b = cv2.minAreaRect(box_b)\n    r1 = cv2.rotatedRectangleIntersection(rect_a, rect_b)\n    if r1[0] == 0:\n        return 0\n    else:\n        inter_area = cv2.contourArea(r1[1])\n        area_a = cv2.contourArea(box_a)\n        area_b = cv2.contourArea(box_b)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.iou",
        "documentation": {}
    },
    {
        "label": "DetectionMTWI2018Evaluator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.mtwi2018",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.mtwi2018",
        "peekOfCode": "class DetectionMTWI2018Evaluator(object):\n    def __init__(\n            self,\n            area_recall_constraint=0.7,\n            area_precision_constraint=0.7,\n            ev_param_ind_center_diff_thr=1, ):\n        self.area_recall_constraint = area_recall_constraint\n        self.area_precision_constraint = area_precision_constraint\n        self.ev_param_ind_center_diff_thr = ev_param_ind_center_diff_thr\n    def evaluate_image(self, gt, pred):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.detection.mtwi2018",
        "documentation": {}
    },
    {
        "label": "AverageMeter",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.quad_metric",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.quad_metric",
        "peekOfCode": "class AverageMeter(object):\n    \"\"\"Computes and stores the average and current value\"\"\"\n    def __init__(self):\n        self.reset()\n    def reset(self):\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n    def update(self, val, n=1):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.quad_metric",
        "documentation": {}
    },
    {
        "label": "QuadMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.quad_metric",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.quad_metric",
        "peekOfCode": "class QuadMetric():\n    def __init__(self, is_output_polygon=False):\n        self.is_output_polygon = is_output_polygon\n        self.evaluator = DetectionIoUEvaluator(\n            is_output_polygon=is_output_polygon)\n    def measure(self, batch, output, box_thresh=0.6):\n        '''\n        batch: (image, polygons, ignore_tags\n        batch: a dict produced by dataloaders.\n            image: tensor of shape (N, C, H, W).",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.ocr_metric.icdar2015.quad_metric",
        "documentation": {}
    },
    {
        "label": "train_txt_path",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "peekOfCode": "train_txt_path = './train_val_list.txt'\nCNum = 10000  # 挑选多少图片进行计算\nimg_h, img_w = 640, 640\nimgs = np.zeros([img_w, img_h, 3, 1])\nmeans, stdevs = [], []\nwith open(train_txt_path, 'r') as f:\n    lines = f.readlines()\n    random.shuffle(lines)  # shuffle , 随机挑选图片\n    for i in tqdm(range(CNum)):\n        img_path = lines[i].split('\\t')[0]",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "documentation": {}
    },
    {
        "label": "CNum",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "peekOfCode": "CNum = 10000  # 挑选多少图片进行计算\nimg_h, img_w = 640, 640\nimgs = np.zeros([img_w, img_h, 3, 1])\nmeans, stdevs = [], []\nwith open(train_txt_path, 'r') as f:\n    lines = f.readlines()\n    random.shuffle(lines)  # shuffle , 随机挑选图片\n    for i in tqdm(range(CNum)):\n        img_path = lines[i].split('\\t')[0]\n        img = cv2.imread(img_path)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "documentation": {}
    },
    {
        "label": "imgs",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "peekOfCode": "imgs = np.zeros([img_w, img_h, 3, 1])\nmeans, stdevs = [], []\nwith open(train_txt_path, 'r') as f:\n    lines = f.readlines()\n    random.shuffle(lines)  # shuffle , 随机挑选图片\n    for i in tqdm(range(CNum)):\n        img_path = lines[i].split('\\t')[0]\n        img = cv2.imread(img_path)\n        img = cv2.resize(img, (img_h, img_w))\n        img = img[:, :, :, np.newaxis]",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "documentation": {}
    },
    {
        "label": "imgs",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "peekOfCode": "imgs = imgs.astype(np.float32) / 255.\nfor i in tqdm(range(3)):\n    pixels = imgs[:, :, i, :].ravel()  # 拉成一行\n    means.append(np.mean(pixels))\n    stdevs.append(np.std(pixels))\n# cv2 读取的图像格式为BGR，PIL/Skimage读取到的都是RGB不用转\nmeans.reverse()  # BGR --> RGB\nstdevs.reverse()\nprint(\"normMean = {}\".format(means))\nprint(\"normStd = {}\".format(stdevs))",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "documentation": {}
    },
    {
        "label": "print(\"normMean",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "peekOfCode": "print(\"normMean = {}\".format(means))\nprint(\"normStd = {}\".format(stdevs))\nprint('transforms.Normalize(normMean = {}, normStd = {})'.format(means, stdevs))",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "documentation": {}
    },
    {
        "label": "print(\"normStd",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "peekOfCode": "print(\"normStd = {}\".format(stdevs))\nprint('transforms.Normalize(normMean = {}, normStd = {})'.format(means, stdevs))",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "documentation": {}
    },
    {
        "label": "print('transforms.Normalize(normMean",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "peekOfCode": "print('transforms.Normalize(normMean = {}, normStd = {})'.format(means, stdevs))",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.compute_mean_std",
        "documentation": {}
    },
    {
        "label": "data_path",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.make_trainfile",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.make_trainfile",
        "peekOfCode": "data_path = r'test'\n# data_path/img 存放图片\n# data_path/gt 存放标签文件\nf_w = open(os.path.join(data_path, 'test.txt'), 'w', encoding='utf8')\nfor img_path in glob.glob(data_path + '/img/*.jpg', recursive=True):\n    d = pathlib.Path(img_path)\n    label_path = os.path.join(data_path, 'gt', ('gt_' + str(d.stem) + '.txt'))\n    if os.path.exists(img_path) and os.path.exists(label_path):\n        print(img_path, label_path)\n    else:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.make_trainfile",
        "documentation": {}
    },
    {
        "label": "f_w",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.make_trainfile",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.make_trainfile",
        "peekOfCode": "f_w = open(os.path.join(data_path, 'test.txt'), 'w', encoding='utf8')\nfor img_path in glob.glob(data_path + '/img/*.jpg', recursive=True):\n    d = pathlib.Path(img_path)\n    label_path = os.path.join(data_path, 'gt', ('gt_' + str(d.stem) + '.txt'))\n    if os.path.exists(img_path) and os.path.exists(label_path):\n        print(img_path, label_path)\n    else:\n        print('不存在', img_path, label_path)\n    f_w.write('{}\\t{}\\n'.format(img_path, label_path))\nf_w.close()",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.make_trainfile",
        "documentation": {}
    },
    {
        "label": "runningScore",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.metrics",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.metrics",
        "peekOfCode": "class runningScore(object):\n    def __init__(self, n_classes):\n        self.n_classes = n_classes\n        self.confusion_matrix = np.zeros((n_classes, n_classes))\n    def _fast_hist(self, label_true, label_pred, n_class):\n        mask = (label_true >= 0) & (label_true < n_class)\n        if np.sum((label_pred[mask] < 0)) > 0:\n            print(label_pred[label_pred < 0])\n        hist = np.bincount(\n            n_class * label_true[mask].astype(int) + label_pred[mask],",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ProfilerOptions",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "peekOfCode": "class ProfilerOptions(object):\n    '''\n    Use a string to initialize a ProfilerOptions.\n    The string should be in the format: \"key1=value1;key2=value;key3=value3\".\n    For example:\n      \"profile_path=model.profile\"\n      \"batch_range=[50, 60]; profile_path=model.profile\"\n      \"batch_range=[50, 60]; tracer_option=OpDetail; profile_path=model.profile\"\n    ProfilerOptions supports following key-value pair:\n      batch_range      - a integer list, e.g. [100, 110].",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "documentation": {}
    },
    {
        "label": "add_profiler_step",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "peekOfCode": "def add_profiler_step(options_str=None):\n    '''\n    Enable the operator-level timing using PaddlePaddle's profiler.\n    The profiler uses a independent variable to count the profiler steps.\n    One call of this function is treated as a profiler step.\n    Args:\n      profiler_options - a string to initialize the ProfilerOptions.\n                         Default is None, and the profiler is disabled.\n    '''\n    if options_str is None:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "documentation": {}
    },
    {
        "label": "_profiler_step_id",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "peekOfCode": "_profiler_step_id = 0\n# A global variable to avoid parsing from string every time.\n_profiler_options = None\nclass ProfilerOptions(object):\n    '''\n    Use a string to initialize a ProfilerOptions.\n    The string should be in the format: \"key1=value1;key2=value;key3=value3\".\n    For example:\n      \"profile_path=model.profile\"\n      \"batch_range=[50, 60]; profile_path=model.profile\"",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "documentation": {}
    },
    {
        "label": "_profiler_options",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "peekOfCode": "_profiler_options = None\nclass ProfilerOptions(object):\n    '''\n    Use a string to initialize a ProfilerOptions.\n    The string should be in the format: \"key1=value1;key2=value;key3=value3\".\n    For example:\n      \"profile_path=model.profile\"\n      \"batch_range=[50, 60]; profile_path=model.profile\"\n      \"batch_range=[50, 60]; tracer_option=OpDetail; profile_path=model.profile\"\n    ProfilerOptions supports following key-value pair:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.profiler",
        "documentation": {}
    },
    {
        "label": "Polynomial",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.schedulers",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.schedulers",
        "peekOfCode": "class Polynomial(object):\n    \"\"\"\n    Polynomial learning rate decay\n    Args:\n        learning_rate (float): The initial learning rate. It is a python float number.\n        epochs(int): The decay epoch size. It determines the decay cycle, when by_epoch is set to true, it will change to epochs=epochs*step_each_epoch.\n        step_each_epoch: all steps in each epoch.\n        end_lr(float, optional): The minimum final learning rate. Default: 0.0001.\n        power(float, optional): Power of polynomial. Default: 1.0.\n        warmup_epoch(int): The epoch numbers for LinearWarmup. Default: 0, , when by_epoch is set to true, it will change to warmup_epoch=warmup_epoch*step_each_epoch.",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.schedulers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.schedulers",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.schedulers",
        "peekOfCode": "__all__ = ['Polynomial']\nclass Polynomial(object):\n    \"\"\"\n    Polynomial learning rate decay\n    Args:\n        learning_rate (float): The initial learning rate. It is a python float number.\n        epochs(int): The decay epoch size. It determines the decay cycle, when by_epoch is set to true, it will change to epochs=epochs*step_each_epoch.\n        step_each_epoch: all steps in each epoch.\n        end_lr(float, optional): The minimum final learning rate. Default: 0.0001.\n        power(float, optional): Power of polynomial. Default: 1.0.",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.schedulers",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "class Config(object):\n    def __init__(self, config_path, BASE_KEY='base'):\n        self.BASE_KEY = BASE_KEY\n        self.cfg = self._load_config_with_base(config_path)\n    def _load_config_with_base(self, file_path):\n        \"\"\"\n               Load config from file.\n               Args:\n                   file_path (str): Path of the config file to be loaded.\n               Returns: global config",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "class ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\n            \"-c\", \"--config_file\", help=\"configuration file to use\")\n        self.add_argument(\n            \"-o\", \"--opt\", nargs='*', help=\"set configuration options\")\n        self.add_argument(\n            '-p',",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def get_image_file_list(img_file):\n    imgs_lists = []\n    if img_file is None or not os.path.exists(img_file):\n        raise Exception(\"not found any img file in {}\".format(img_file))\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif', 'pdf'}\n    if os.path.isfile(img_file) and _check_image_file(img_file):\n        imgs_lists.append(img_file)\n    elif os.path.isdir(img_file):\n        for single_file in os.listdir(img_file):\n            file_path = os.path.join(img_file, single_file)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def setup_logger(log_file_path: str=None):\n    import logging\n    logging._warn_preinit_stderr = 0\n    logger = logging.getLogger('DBNet.paddle')\n    formatter = logging.Formatter(\n        '%(asctime)s %(name)s %(levelname)s: %(message)s')\n    ch = logging.StreamHandler()\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n    if log_file_path is not None:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "exe_time",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def exe_time(func):\n    def newFunc(*args, **args2):\n        t0 = time.time()\n        back = func(*args, **args2)\n        print(\"{} cost {:.3f}s\".format(func.__name__, time.time() - t0))\n        return back\n    return newFunc\ndef load(file_path: str):\n    file_path = pathlib.Path(file_path)\n    func_dict = {'.txt': _load_txt, '.json': _load_json, '.list': _load_txt}",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def load(file_path: str):\n    file_path = pathlib.Path(file_path)\n    func_dict = {'.txt': _load_txt, '.json': _load_json, '.list': _load_txt}\n    assert file_path.suffix in func_dict\n    return func_dict[file_path.suffix](file_path)\ndef _load_txt(file_path: str):\n    with open(file_path, 'r', encoding='utf8') as f:\n        content = [\n            x.strip().strip('\\ufeff').strip('\\xef\\xbb\\xbf')\n            for x in f.readlines()",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def save(data, file_path):\n    file_path = pathlib.Path(file_path)\n    func_dict = {'.txt': _save_txt, '.json': _save_json}\n    assert file_path.suffix in func_dict\n    return func_dict[file_path.suffix](data, file_path)\ndef _save_txt(data, file_path):\n    \"\"\"\n    将一个list的数组写入txt文件里\n    :param data:\n    :param file_path:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "show_img",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def show_img(imgs: np.ndarray, title='img'):\n    color = (len(imgs.shape) == 3 and imgs.shape[-1] == 3)\n    imgs = np.expand_dims(imgs, axis=0)\n    for i, img in enumerate(imgs):\n        plt.figure()\n        plt.title('{}_{}'.format(title, i))\n        plt.imshow(img, cmap=None if color else 'gray')\n    plt.show()\ndef draw_bbox(img_path, result, color=(255, 0, 0), thickness=2):\n    if isinstance(img_path, str):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "draw_bbox",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def draw_bbox(img_path, result, color=(255, 0, 0), thickness=2):\n    if isinstance(img_path, str):\n        img_path = cv2.imread(img_path)\n        # img_path = cv2.cvtColor(img_path, cv2.COLOR_BGR2RGB)\n    img_path = img_path.copy()\n    for point in result:\n        point = point.astype(int)\n        cv2.polylines(img_path, [point], True, color, thickness)\n    return img_path\ndef cal_text_score(texts,",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "cal_text_score",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def cal_text_score(texts,\n                   gt_texts,\n                   training_masks,\n                   running_metric_text,\n                   thred=0.5):\n    training_masks = training_masks.numpy()\n    pred_text = texts.numpy() * training_masks\n    pred_text[pred_text <= thred] = 0\n    pred_text[pred_text > thred] = 1\n    pred_text = pred_text.astype(np.int32)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "order_points_clockwise",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def order_points_clockwise(pts):\n    rect = np.zeros((4, 2), dtype=\"float32\")\n    s = pts.sum(axis=1)\n    rect[0] = pts[np.argmin(s)]\n    rect[2] = pts[np.argmax(s)]\n    diff = np.diff(pts, axis=1)\n    rect[1] = pts[np.argmin(diff)]\n    rect[3] = pts[np.argmax(diff)]\n    return rect\ndef order_points_clockwise_list(pts):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "order_points_clockwise_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def order_points_clockwise_list(pts):\n    pts = pts.tolist()\n    pts.sort(key=lambda x: (x[1], x[0]))\n    pts[:2] = sorted(pts[:2], key=lambda x: x[0])\n    pts[2:] = sorted(pts[2:], key=lambda x: -x[0])\n    pts = np.array(pts)\n    return pts\ndef get_datalist(train_data_path):\n    \"\"\"\n    获取训练和验证的数据list",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "get_datalist",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def get_datalist(train_data_path):\n    \"\"\"\n    获取训练和验证的数据list\n    :param train_data_path: 训练的dataset文件列表，每个文件内以如下格式存储 ‘path/to/img\\tlabel’\n    :return:\n    \"\"\"\n    train_data = []\n    for p in train_data_path:\n        with open(p, 'r', encoding='utf-8') as f:\n            for line in f.readlines():",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "save_result",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def save_result(result_path, box_list, score_list, is_output_polygon):\n    if is_output_polygon:\n        with open(result_path, 'wt') as res:\n            for i, box in enumerate(box_list):\n                box = box.reshape(-1).tolist()\n                result = \",\".join([str(int(x)) for x in box])\n                score = score_list[i]\n                res.write(result + ',' + str(score) + \"\\n\")\n    else:\n        with open(result_path, 'wt') as res:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "expand_polygon",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def expand_polygon(polygon):\n    \"\"\"\n    对只有一个字符的框进行扩充\n    \"\"\"\n    (x, y), (w, h), angle = cv2.minAreaRect(np.float32(polygon))\n    if angle < -45:\n        w, h = h, w\n        angle += 90\n    new_w = w + h\n    box = ((x, y), (new_w, h), angle)",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "print_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "description": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "peekOfCode": "def print_dict(cfg, print_func=print, delimiter=0):\n    \"\"\"\n    Recursively visualize a dict and\n    indenting acrrording by the relationship of keys.\n    \"\"\"\n    for k, v in sorted(cfg.items()):\n        if isinstance(v, dict):\n            print_func(\"{}{} : \".format(delimiter * \" \", str(k)))\n            print_dict(v, print_func, delimiter + 4)\n        elif isinstance(v, list) and len(v) >= 1 and isinstance(v[0], dict):",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.PaddleOCR_DBNet.utils.util",
        "documentation": {}
    },
    {
        "label": "TimeAnalyzer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.analysis",
        "description": "Vision.Paddle.PaddleOCR.benchmark.analysis",
        "peekOfCode": "class TimeAnalyzer(object):\n    def __init__(self,\n                 filename,\n                 keyword=None,\n                 separator=None,\n                 position=None,\n                 range=\"-1\"):\n        if filename is None:\n            raise Exception(\"Please specify the filename!\")\n        if keyword is None:",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.analysis",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.benchmark.analysis",
        "description": "Vision.Paddle.PaddleOCR.benchmark.analysis",
        "peekOfCode": "def parse_args():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        \"--filename\", type=str, help=\"The name of log which need to analysis.\")\n    parser.add_argument(\n        \"--log_with_profiler\",\n        type=str,\n        help=\"The path of train log with profiler\")\n    parser.add_argument(\n        \"--profiler_path\", type=str, help=\"The path of profiler timeline log.\")",
        "detail": "Vision.Paddle.PaddleOCR.benchmark.analysis",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "class ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\n            \"-o\", \"--opt\", nargs='+', help=\"set configuration options\")\n        self.add_argument(\n            \"-l\",\n            \"--language\",\n            nargs='+',",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "merge_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "def merge_config(config):\n    \"\"\"\n    Merge config into global config.\n    Args:\n        config (dict): Config to be merged.\n    Returns: global config\n    \"\"\"\n    for key, value in config.items():\n        if \".\" not in key:\n            if isinstance(value, dict) and key in global_config:",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "loss_file",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "def loss_file(path):\n    assert (\n        os.path.exists(path)\n    ), \"There is no such file:{},Please do not forget to put in the specified file\".format(\n        path)\nif __name__ == '__main__':\n    FLAGS = ArgsParser().parse_args()\n    merge_config(FLAGS.opt)\n    save_file_path = 'rec_{}_lite_train.yml'.format(FLAGS.language)\n    if os.path.isfile(save_file_path):",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "support_list",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "support_list = {\n    'it': 'italian',\n    'xi': 'spanish',\n    'pu': 'portuguese',\n    'ru': 'russian',\n    'ar': 'arabic',\n    'ta': 'tamil',\n    'ug': 'uyghur',\n    'fa': 'persian',\n    'ur': 'urdu',",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "latin_lang",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "latin_lang = [\n    'af', 'az', 'bs', 'cs', 'cy', 'da', 'de', 'es', 'et', 'fr', 'ga', 'hr',\n    'hu', 'id', 'is', 'it', 'ku', 'la', 'lt', 'lv', 'mi', 'ms', 'mt', 'nl',\n    'no', 'oc', 'pi', 'pl', 'pt', 'ro', 'rs_latin', 'sk', 'sl', 'sq', 'sv',\n    'sw', 'tl', 'tr', 'uz', 'vi', 'latin'\n]\narabic_lang = ['ar', 'fa', 'ug', 'ur']\ncyrillic_lang = [\n    'ru', 'rs_cyrillic', 'be', 'bg', 'uk', 'mn', 'abq', 'ady', 'kbd', 'ava',\n    'dar', 'inh', 'che', 'lbe', 'lez', 'tab', 'cyrillic'",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "arabic_lang",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "arabic_lang = ['ar', 'fa', 'ug', 'ur']\ncyrillic_lang = [\n    'ru', 'rs_cyrillic', 'be', 'bg', 'uk', 'mn', 'abq', 'ady', 'kbd', 'ava',\n    'dar', 'inh', 'che', 'lbe', 'lez', 'tab', 'cyrillic'\n]\ndevanagari_lang = [\n    'hi', 'mr', 'ne', 'bh', 'mai', 'ang', 'bho', 'mah', 'sck', 'new', 'gom',\n    'sa', 'bgc', 'devanagari'\n]\nmulti_lang = latin_lang + arabic_lang + cyrillic_lang + devanagari_lang",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "cyrillic_lang",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "cyrillic_lang = [\n    'ru', 'rs_cyrillic', 'be', 'bg', 'uk', 'mn', 'abq', 'ady', 'kbd', 'ava',\n    'dar', 'inh', 'che', 'lbe', 'lez', 'tab', 'cyrillic'\n]\ndevanagari_lang = [\n    'hi', 'mr', 'ne', 'bh', 'mai', 'ang', 'bho', 'mah', 'sck', 'new', 'gom',\n    'sa', 'bgc', 'devanagari'\n]\nmulti_lang = latin_lang + arabic_lang + cyrillic_lang + devanagari_lang\nassert (os.path.isfile(\"./rec_multi_language_lite_train.yml\")",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "devanagari_lang",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "devanagari_lang = [\n    'hi', 'mr', 'ne', 'bh', 'mai', 'ang', 'bho', 'mah', 'sck', 'new', 'gom',\n    'sa', 'bgc', 'devanagari'\n]\nmulti_lang = latin_lang + arabic_lang + cyrillic_lang + devanagari_lang\nassert (os.path.isfile(\"./rec_multi_language_lite_train.yml\")\n        ), \"Loss basic configuration file rec_multi_language_lite_train.yml.\\\nYou can download it from \\\nhttps://github.com/PaddlePaddle/PaddleOCR/tree/dygraph/configs/rec/multi_language/\"\nglobal_config = yaml.load(",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "multi_lang",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "multi_lang = latin_lang + arabic_lang + cyrillic_lang + devanagari_lang\nassert (os.path.isfile(\"./rec_multi_language_lite_train.yml\")\n        ), \"Loss basic configuration file rec_multi_language_lite_train.yml.\\\nYou can download it from \\\nhttps://github.com/PaddlePaddle/PaddleOCR/tree/dygraph/configs/rec/multi_language/\"\nglobal_config = yaml.load(\n    open(\"./rec_multi_language_lite_train.yml\", 'rb'), Loader=yaml.Loader)\nproject_path = os.path.abspath(os.path.join(os.getcwd(), \"../../../\"))\nclass ArgsParser(ArgumentParser):\n    def __init__(self):",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "global_config",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "global_config = yaml.load(\n    open(\"./rec_multi_language_lite_train.yml\", 'rb'), Loader=yaml.Loader)\nproject_path = os.path.abspath(os.path.join(os.getcwd(), \"../../../\"))\nclass ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\n            \"-o\", \"--opt\", nargs='+', help=\"set configuration options\")\n        self.add_argument(",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "project_path",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "description": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "peekOfCode": "project_path = os.path.abspath(os.path.join(os.getcwd(), \"../../../\"))\nclass ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\n            \"-o\", \"--opt\", nargs='+', help=\"set configuration options\")\n        self.add_argument(\n            \"-l\",\n            \"--language\",",
        "detail": "Vision.Paddle.PaddleOCR.configs.rec.multi_language.generate_multi_language_configs",
        "documentation": {}
    },
    {
        "label": "resize_norm_img",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "description": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "peekOfCode": "def resize_norm_img(img, image_shape, padding=True):\n    imgC, imgH, imgW = image_shape\n    h = img.shape[0]\n    w = img.shape[1]\n    if not padding:\n        resized_image = cv2.resize(\n            img, (imgW, imgH), interpolation=cv2.INTER_LINEAR)\n        resized_w = imgW\n    else:\n        ratio = w / float(h)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "documentation": {}
    },
    {
        "label": "create_header_file",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "description": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "peekOfCode": "def create_header_file(name, tensor_name, tensor_data, output_path):\n    \"\"\"\n    This function generates a header file containing the data from the numpy array provided.\n    \"\"\"\n    file_path = pathlib.Path(f\"{output_path}/\" + name).resolve()\n    # Create header file with npy_data as a C array\n    raw_path = file_path.with_suffix(\".h\").resolve()\n    with open(raw_path, \"w\") as header_file:\n        header_file.write(\n            \"\\n\" + f\"const size_t {tensor_name}_len = {tensor_data.size};\\n\" +",
        "detail": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "documentation": {}
    },
    {
        "label": "create_headers",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "description": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "peekOfCode": "def create_headers(image_name):\n    \"\"\"\n    This function generates C header files for the input and output arrays required to run inferences\n    \"\"\"\n    img_path = os.path.join(\"./\", f\"{image_name}\")\n    # Resize image to 32x320\n    img = cv2.imread(img_path)\n    img = resize_norm_img(img, [3, 32, 320])\n    img_data = img.astype(\"float32\")\n    # # Add the batch dimension, as we are expecting 4-dimensional input: NCHW.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.avh.convert_image",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--det_model\", required=True, help=\"Path of Detection model of PPOCR.\")\n    parser.add_argument(\n        \"--cls_model\",\n        required=True,\n        help=\"Path of Classification model of PPOCR.\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "build_option",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "def build_option(args):\n    det_option = fd.RuntimeOption()\n    cls_option = fd.RuntimeOption()\n    rec_option = fd.RuntimeOption()\n    det_option.use_ascend()\n    cls_option.use_ascend()\n    rec_option.use_ascend()\n    return det_option, cls_option, rec_option\nargs = parse_arguments()\ndet_model_file = os.path.join(args.det_model, \"inference.pdmodel\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "args = parse_arguments()\ndet_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "det_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "det_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "det_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "cls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "cls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "rec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "rec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Rec model enable static shape infer.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_label_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "rec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Rec model enable static shape infer.\n# When deploy on Ascend, it must be true.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "det_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Rec model enable static shape infer.\n# When deploy on Ascend, it must be true.\nrec_model.preprocessor.static_shape_infer = True\n# Create PP-OCRv3, if cls_model is not needed,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "cls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Rec model enable static shape infer.\n# When deploy on Ascend, it must be true.\nrec_model.preprocessor.static_shape_infer = True\n# Create PP-OCRv3, if cls_model is not needed,\n# just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "rec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Rec model enable static shape infer.\n# When deploy on Ascend, it must be true.\nrec_model.preprocessor.static_shape_infer = True\n# Create PP-OCRv3, if cls_model is not needed,\n# just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# The batch size must be set to 1, when enable static shape infer.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model.preprocessor.static_shape_infer",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "rec_model.preprocessor.static_shape_infer = True\n# Create PP-OCRv3, if cls_model is not needed,\n# just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# The batch size must be set to 1, when enable static shape infer.\nppocr_v3.cls_batch_size = 1\nppocr_v3.rec_batch_size = 1\n# Prepare image.\nim = cv2.imread(args.image)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "ppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# The batch size must be set to 1, when enable static shape infer.\nppocr_v3.cls_batch_size = 1\nppocr_v3.rec_batch_size = 1\n# Prepare image.\nim = cv2.imread(args.image)\n# Print the results.\nresult = ppocr_v3.predict(im)\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "ppocr_v3.cls_batch_size = 1\nppocr_v3.rec_batch_size = 1\n# Prepare image.\nim = cv2.imread(args.image)\n# Print the results.\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "ppocr_v3.rec_batch_size = 1\n# Prepare image.\nim = cv2.imread(args.image)\n# Print the results.\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "im = cv2.imread(args.image)\n# Print the results.\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "result = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "vis_im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "peekOfCode": "vis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.ascend.python.infer",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--det_model\", required=True, help=\"Path of Detection model of PPOCR.\")\n    parser.add_argument(\n        \"--cls_model\",\n        required=True,\n        help=\"Path of Classification model of PPOCR.\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "build_option",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "def build_option(args):\n    det_option = fd.RuntimeOption()\n    cls_option = fd.RuntimeOption()\n    rec_option = fd.RuntimeOption()\n    if args.device.lower() == \"gpu\":\n        det_option.use_gpu(args.device_id)\n        cls_option.use_gpu(args.device_id)\n        rec_option.use_gpu(args.device_id)\n    if args.backend.lower() == \"trt\":\n        assert args.device.lower(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "args = parse_arguments()\ndet_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "cls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "cls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "rec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "rec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Parameters settings for pre and post processing of Det/Cls/Rec Models.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_label_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "rec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Parameters settings for pre and post processing of Det/Cls/Rec Models.\n# All parameters are set to default values.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Parameters settings for pre and post processing of Det/Cls/Rec Models.\n# All parameters are set to default values.\ndet_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "cls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Parameters settings for pre and post processing of Det/Cls/Rec Models.\n# All parameters are set to default values.\ndet_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "rec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Parameters settings for pre and post processing of Det/Cls/Rec Models.\n# All parameters are set to default values.\ndet_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model.preprocessor.max_side_len",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\ncls_model.postprocessor.cls_thresh = 0.9\n# Create PP-OCRv3, if cls_model is not needed, just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_thresh",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\ncls_model.postprocessor.cls_thresh = 0.9\n# Create PP-OCRv3, if cls_model is not needed, just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_box_thresh",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\ncls_model.postprocessor.cls_thresh = 0.9\n# Create PP-OCRv3, if cls_model is not needed, just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_unclip_ratio",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\ncls_model.postprocessor.cls_thresh = 0.9\n# Create PP-OCRv3, if cls_model is not needed, just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size\n# of the cls and rec models will be the same as the number of boxes detected by the det model.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_score_mode",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\ncls_model.postprocessor.cls_thresh = 0.9\n# Create PP-OCRv3, if cls_model is not needed, just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size\n# of the cls and rec models will be the same as the number of boxes detected by the det model.\nppocr_v3.cls_batch_size = args.cls_bs",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.use_dilation",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "det_model.postprocessor.use_dilation = False\ncls_model.postprocessor.cls_thresh = 0.9\n# Create PP-OCRv3, if cls_model is not needed, just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size\n# of the cls and rec models will be the same as the number of boxes detected by the det model.\nppocr_v3.cls_batch_size = args.cls_bs\nppocr_v3.rec_batch_size = args.rec_bs",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model.postprocessor.cls_thresh",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "cls_model.postprocessor.cls_thresh = 0.9\n# Create PP-OCRv3, if cls_model is not needed, just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size\n# of the cls and rec models will be the same as the number of boxes detected by the det model.\nppocr_v3.cls_batch_size = args.cls_bs\nppocr_v3.rec_batch_size = args.rec_bs\n# Read the input image",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "ppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size\n# of the cls and rec models will be the same as the number of boxes detected by the det model.\nppocr_v3.cls_batch_size = args.cls_bs\nppocr_v3.rec_batch_size = args.rec_bs\n# Read the input image\nim = cv2.imread(args.image)\n# Predict and reutrn the results",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "ppocr_v3.cls_batch_size = args.cls_bs\nppocr_v3.rec_batch_size = args.rec_bs\n# Read the input image\nim = cv2.imread(args.image)\n# Predict and reutrn the results\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the results.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "ppocr_v3.rec_batch_size = args.rec_bs\n# Read the input image\nim = cv2.imread(args.image)\n# Predict and reutrn the results\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the results.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "im = cv2.imread(args.image)\n# Predict and reutrn the results\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the results.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "result = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the results.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "vis_im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "peekOfCode": "vis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--cls_model\",\n        required=True,\n        help=\"Path of Classification model of PPOCR.\")\n    parser.add_argument(\n        \"--image\", type=str, required=True, help=\"Path of test image file.\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "build_option",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "def build_option(args):\n    cls_option = fd.RuntimeOption()\n    if args.device.lower() == \"gpu\":\n        cls_option.use_gpu(args.device_id)\n    return cls_option\nargs = parse_arguments()\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\n# Set the runtime option\ncls_option = build_option(args)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "args = parse_arguments()\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\n# Set the runtime option\ncls_option = build_option(args)\n# Create the cls_model\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\n# Set the postprocessing parameters\ncls_model.postprocessor.cls_thresh = 0.9",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "cls_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "cls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\n# Set the runtime option\ncls_option = build_option(args)\n# Create the cls_model\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\n# Set the postprocessing parameters\ncls_model.postprocessor.cls_thresh = 0.9\n# Read the image",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "cls_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "cls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\n# Set the runtime option\ncls_option = build_option(args)\n# Create the cls_model\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\n# Set the postprocessing parameters\ncls_model.postprocessor.cls_thresh = 0.9\n# Read the image\nim = cv2.imread(args.image)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "cls_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "cls_option = build_option(args)\n# Create the cls_model\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\n# Set the postprocessing parameters\ncls_model.postprocessor.cls_thresh = 0.9\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = cls_model.predict(im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "cls_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "cls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\n# Set the postprocessing parameters\ncls_model.postprocessor.cls_thresh = 0.9\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = cls_model.predict(im)\n# User can infer a batch of images by following code.\n# result = cls_model.batch_predict([im])",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "cls_model.postprocessor.cls_thresh",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "cls_model.postprocessor.cls_thresh = 0.9\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = cls_model.predict(im)\n# User can infer a batch of images by following code.\n# result = cls_model.batch_predict([im])\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "im = cv2.imread(args.image)\n# Predict and return the results\nresult = cls_model.predict(im)\n# User can infer a batch of images by following code.\n# result = cls_model.batch_predict([im])\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "peekOfCode": "result = cls_model.predict(im)\n# User can infer a batch of images by following code.\n# result = cls_model.batch_predict([im])\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_cls",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--det_model\", required=True, help=\"Path of Detection model of PPOCR.\")\n    parser.add_argument(\n        \"--image\", type=str, required=True, help=\"Path of test image file.\")\n    parser.add_argument(\n        \"--device\",",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "build_option",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "def build_option(args):\n    det_option = fd.RuntimeOption()\n    if args.device.lower() == \"gpu\":\n        det_option.use_gpu(args.device_id)\n    return det_option\nargs = parse_arguments()\ndet_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\n# Set the runtime option\ndet_option = build_option(args)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "args = parse_arguments()\ndet_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\n# Set the runtime option\ndet_option = build_option(args)\n# Create the det_model\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\n# Set the preporcessing parameters\ndet_model.preprocessor.max_side_len = 960",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\n# Set the runtime option\ndet_option = build_option(args)\n# Create the det_model\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\n# Set the preporcessing parameters\ndet_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\n# Set the runtime option\ndet_option = build_option(args)\n# Create the det_model\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\n# Set the preporcessing parameters\ndet_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_option = build_option(args)\n# Create the det_model\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\n# Set the preporcessing parameters\ndet_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\n# Set the preporcessing parameters\ndet_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\n# Read the image",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model.preprocessor.max_side_len",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model.preprocessor.max_side_len = 960\ndet_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = det_model.predict(im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_thresh",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model.postprocessor.det_db_thresh = 0.3\ndet_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = det_model.predict(im)\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_box_thresh",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model.postprocessor.det_db_box_thresh = 0.6\ndet_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = det_model.predict(im)\nprint(result)\n# Visualize the results",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_unclip_ratio",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model.postprocessor.det_db_unclip_ratio = 1.5\ndet_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = det_model.predict(im)\nprint(result)\n# Visualize the results\nvis_im = fd.vision.vis_ppocr(im, result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.det_db_score_mode",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model.postprocessor.det_db_score_mode = \"slow\"\ndet_model.postprocessor.use_dilation = False\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = det_model.predict(im)\nprint(result)\n# Visualize the results\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "det_model.postprocessor.use_dilation",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "det_model.postprocessor.use_dilation = False\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the results\nresult = det_model.predict(im)\nprint(result)\n# Visualize the results\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "im = cv2.imread(args.image)\n# Predict and return the results\nresult = det_model.predict(im)\nprint(result)\n# Visualize the results\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "result = det_model.predict(im)\nprint(result)\n# Visualize the results\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "vis_im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "peekOfCode": "vis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_det",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--rec_model\",\n        required=True,\n        help=\"Path of Recognization model of PPOCR.\")\n    parser.add_argument(\n        \"--rec_label_file\",",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "build_option",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "def build_option(args):\n    rec_option = fd.RuntimeOption()\n    if args.device.lower() == \"gpu\":\n        rec_option.use_gpu(args.device_id)\n    return rec_option\nargs = parse_arguments()\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\n# Set the runtime option",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "args = parse_arguments()\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\n# Set the runtime option\nrec_option = build_option(args)\n# Create the rec_model\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Read the image",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "rec_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "rec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\n# Set the runtime option\nrec_option = build_option(args)\n# Create the rec_model\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Read the image\nim = cv2.imread(args.image)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "rec_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "rec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\n# Set the runtime option\nrec_option = build_option(args)\n# Create the rec_model\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the result",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "rec_label_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "rec_label_file = args.rec_label_file\n# Set the runtime option\nrec_option = build_option(args)\n# Create the rec_model\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the result\nresult = rec_model.predict(im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "rec_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "rec_option = build_option(args)\n# Create the rec_model\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the result\nresult = rec_model.predict(im)\n# User can infer a batch of images by following code.\n# result = rec_model.batch_predict([im])",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "rec_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "rec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Read the image\nim = cv2.imread(args.image)\n# Predict and return the result\nresult = rec_model.predict(im)\n# User can infer a batch of images by following code.\n# result = rec_model.batch_predict([im])\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "im = cv2.imread(args.image)\n# Predict and return the result\nresult = rec_model.predict(im)\n# User can infer a batch of images by following code.\n# result = rec_model.batch_predict([im])\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "peekOfCode": "result = rec_model.predict(im)\n# User can infer a batch of images by following code.\n# result = rec_model.batch_predict([im])\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.cpu-gpu.python.infer_rec",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--det_model\", required=True, help=\"Path of Detection model of PPOCR.\")\n    parser.add_argument(\n        \"--cls_model\",\n        required=True,\n        help=\"Path of Classification model of PPOCR.\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "build_option",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "def build_option(args):\n    det_option = fd.RuntimeOption()\n    cls_option = fd.RuntimeOption()\n    rec_option = fd.RuntimeOption()\n    det_option.use_kunlunxin()\n    cls_option.use_kunlunxin()\n    rec_option.use_kunlunxin()\n    return det_option, cls_option, rec_option\nargs = parse_arguments()\ndet_model_file = os.path.join(args.det_model, \"inference.pdmodel\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "args = parse_arguments()\ndet_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "det_model_file = os.path.join(args.det_model, \"inference.pdmodel\")\ndet_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "det_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "det_params_file = os.path.join(args.det_model, \"inference.pdiparams\")\ncls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "cls_model_file = os.path.join(args.cls_model, \"inference.pdmodel\")\ncls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "cls_params_file = os.path.join(args.cls_model, \"inference.pdiparams\")\nrec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "rec_model_file = os.path.join(args.rec_model, \"inference.pdmodel\")\nrec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "rec_params_file = os.path.join(args.rec_model, \"inference.pdiparams\")\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PP-OCRv3, if cls_model is not needed,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_label_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "rec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PP-OCRv3, if cls_model is not needed,\n# just set cls_model=None .",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "det_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PP-OCRv3, if cls_model is not needed,\n# just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "cls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PP-OCRv3, if cls_model is not needed,\n# just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "rec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PP-OCRv3, if cls_model is not needed,\n# just set cls_model=None .\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size\n# of the cls and rec models will be the same as the number of boxes detected by the det model.\nppocr_v3.cls_batch_size = args.cls_bs",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "ppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Set inference batch size for cls model and rec model, the value could be -1 and 1 to positive infinity.\n# When inference batch size is set to -1, it means that the inference batch size\n# of the cls and rec models will be the same as the number of boxes detected by the det model.\nppocr_v3.cls_batch_size = args.cls_bs\nppocr_v3.rec_batch_size = args.rec_bs\n# Prepare image.\nim = cv2.imread(args.image)\n# Print the results.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "ppocr_v3.cls_batch_size = args.cls_bs\nppocr_v3.rec_batch_size = args.rec_bs\n# Prepare image.\nim = cv2.imread(args.image)\n# Print the results.\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "ppocr_v3.rec_batch_size = args.rec_bs\n# Prepare image.\nim = cv2.imread(args.image)\n# Print the results.\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "im = cv2.imread(args.image)\n# Print the results.\nresult = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "result = ppocr_v3.predict(im)\nprint(result)\n# Visuliaze the output.\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "vis_im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "peekOfCode": "vis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.kunlunxin.python.infer",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--det_model\", required=True, help=\"Path of Detection model of PPOCR.\")\n    parser.add_argument(\n        \"--cls_model\",\n        required=True,\n        help=\"Path of Classification model of PPOCR.\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "build_option",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "def build_option(args):\n    det_option = fd.RuntimeOption()\n    cls_option = fd.RuntimeOption()\n    rec_option = fd.RuntimeOption()\n    if args.device == \"npu\":\n        det_option.use_rknpu2()\n        cls_option.use_rknpu2()\n        rec_option.use_rknpu2()\n    return det_option, cls_option, rec_option\ndef build_format(args):",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "build_format",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "def build_format(args):\n    det_format = fd.ModelFormat.ONNX\n    cls_format = fd.ModelFormat.ONNX\n    rec_format = fd.ModelFormat.ONNX\n    if args.device == \"npu\":\n        det_format = fd.ModelFormat.RKNN\n        cls_format = fd.ModelFormat.RKNN\n        rec_format = fd.ModelFormat.RKNN\n    return det_format, cls_format, rec_format\nargs = parse_arguments()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "args = parse_arguments()\n# Detection模型, 检测文字框\ndet_model_file = args.det_model\ndet_params_file = \"\"\n# Classification模型，方向分类，可选\ncls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "det_model_file = args.det_model\ndet_params_file = \"\"\n# Classification模型，方向分类，可选\ncls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "det_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "det_params_file = \"\"\n# Classification模型，方向分类，可选\ncls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_format, cls_format, rec_format = build_format(args)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "cls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_format, cls_format, rec_format = build_format(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "cls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_format, cls_format, rec_format = build_format(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file,\n    det_params_file,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "rec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_format, cls_format, rec_format = build_format(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file,\n    det_params_file,\n    runtime_option=det_option,\n    model_format=det_format)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "rec_params_file = \"\"\nrec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_format, cls_format, rec_format = build_format(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file,\n    det_params_file,\n    runtime_option=det_option,\n    model_format=det_format)\ncls_model = fd.vision.ocr.Classifier(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_label_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "rec_label_file = args.rec_label_file\ndet_option, cls_option, rec_option = build_option(args)\ndet_format, cls_format, rec_format = build_format(args)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file,\n    det_params_file,\n    runtime_option=det_option,\n    model_format=det_format)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "det_model = fd.vision.ocr.DBDetector(\n    det_model_file,\n    det_params_file,\n    runtime_option=det_option,\n    model_format=det_format)\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file,\n    cls_params_file,\n    runtime_option=cls_option,\n    model_format=cls_format)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "cls_model = fd.vision.ocr.Classifier(\n    cls_model_file,\n    cls_params_file,\n    runtime_option=cls_option,\n    model_format=cls_format)\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file,\n    rec_params_file,\n    rec_label_file,\n    runtime_option=rec_option,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "rec_model = fd.vision.ocr.Recognizer(\n    rec_model_file,\n    rec_params_file,\n    rec_label_file,\n    runtime_option=rec_option,\n    model_format=rec_format)\n# Det,Rec模型启用静态shape推理\ndet_model.preprocessor.static_shape_infer = True\nrec_model.preprocessor.static_shape_infer = True\nif args.device == \"npu\":",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model.preprocessor.static_shape_infer",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "det_model.preprocessor.static_shape_infer = True\nrec_model.preprocessor.static_shape_infer = True\nif args.device == \"npu\":\n    det_model.preprocessor.disable_normalize()\n    det_model.preprocessor.disable_permute()\n    cls_model.preprocessor.disable_normalize()\n    cls_model.preprocessor.disable_permute()\n    rec_model.preprocessor.disable_normalize()\n    rec_model.preprocessor.disable_permute()\n# 创建PP-OCR，串联3个模型，其中cls_model可选，如无需求，可设置为None",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model.preprocessor.static_shape_infer",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "rec_model.preprocessor.static_shape_infer = True\nif args.device == \"npu\":\n    det_model.preprocessor.disable_normalize()\n    det_model.preprocessor.disable_permute()\n    cls_model.preprocessor.disable_normalize()\n    cls_model.preprocessor.disable_permute()\n    rec_model.preprocessor.disable_normalize()\n    rec_model.preprocessor.disable_permute()\n# 创建PP-OCR，串联3个模型，其中cls_model可选，如无需求，可设置为None\nppocr_v3 = fd.vision.ocr.PPOCRv3(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "ppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# Cls模型和Rec模型的batch size 必须设置为1, 开启静态shape推理\nppocr_v3.cls_batch_size = 1\nppocr_v3.rec_batch_size = 1\n# 预测图片准备\nim = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)\nprint(result)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "ppocr_v3.cls_batch_size = 1\nppocr_v3.rec_batch_size = 1\n# 预测图片准备\nim = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "ppocr_v3.rec_batch_size = 1\n# 预测图片准备\nim = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "im = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "result = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "vis_im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "peekOfCode": "vis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"visualized_result.jpg\", vis_im)\nprint(\"Visualized result save in ./visualized_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.python.infer",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.rknpu2_tools.export",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.rknpu2_tools.export",
        "peekOfCode": "def get_config():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--verbose\", default=True, help=\"rknntoolkit verbose\")\n    parser.add_argument(\"--config_path\")\n    parser.add_argument(\"--target_platform\")\n    args = parser.parse_args()\n    return args\nif __name__ == \"__main__\":\n    config = get_config()\n    with open(config.config_path) as file:",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.rockchip.rknpu2_tools.export",
        "documentation": {}
    },
    {
        "label": "TritonPythonModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.cls_postprocess.1.model",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.cls_postprocess.1.model",
        "peekOfCode": "class TritonPythonModel:\n    \"\"\"Your Python model must use the same class name. Every Python model\n    that is created must have \"TritonPythonModel\" as the class name.\n    \"\"\"\n    def initialize(self, args):\n        \"\"\"`initialize` is called only once when the model is being loaded.\n        Implementing `initialize` function is optional. This function allows\n        the model to intialize any state associated with this model.\n        Parameters\n        ----------",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.cls_postprocess.1.model",
        "documentation": {}
    },
    {
        "label": "TritonPythonModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_postprocess.1.model",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_postprocess.1.model",
        "peekOfCode": "class TritonPythonModel:\n    \"\"\"Your Python model must use the same class name. Every Python model\n    that is created must have \"TritonPythonModel\" as the class name.\n    \"\"\"\n    def initialize(self, args):\n        \"\"\"`initialize` is called only once when the model is being loaded.\n        Implementing `initialize` function is optional. This function allows\n        the model to intialize any state associated with this model.\n        Parameters\n        ----------",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_postprocess.1.model",
        "documentation": {}
    },
    {
        "label": "get_rotate_crop_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_postprocess.1.model",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_postprocess.1.model",
        "peekOfCode": "def get_rotate_crop_image(img, box):\n    '''\n    img_height, img_width = img.shape[0:2]\n    left = int(np.min(points[:, 0]))\n    right = int(np.max(points[:, 0]))\n    top = int(np.min(points[:, 1]))\n    bottom = int(np.max(points[:, 1]))\n    img_crop = img[top:bottom, left:right, :].copy()\n    points[:, 0] = points[:, 0] - left\n    points[:, 1] = points[:, 1] - top",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_postprocess.1.model",
        "documentation": {}
    },
    {
        "label": "TritonPythonModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_preprocess.1.model",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_preprocess.1.model",
        "peekOfCode": "class TritonPythonModel:\n    \"\"\"Your Python model must use the same class name. Every Python model\n    that is created must have \"TritonPythonModel\" as the class name.\n    \"\"\"\n    def initialize(self, args):\n        \"\"\"`initialize` is called only once when the model is being loaded.\n        Implementing `initialize` function is optional. This function allows\n        the model to intialize any state associated with this model.\n        Parameters\n        ----------",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.det_preprocess.1.model",
        "documentation": {}
    },
    {
        "label": "TritonPythonModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.rec_postprocess.1.model",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.rec_postprocess.1.model",
        "peekOfCode": "class TritonPythonModel:\n    \"\"\"Your Python model must use the same class name. Every Python model\n    that is created must have \"TritonPythonModel\" as the class name.\n    \"\"\"\n    def initialize(self, args):\n        \"\"\"`initialize` is called only once when the model is being loaded.\n        Implementing `initialize` function is optional. This function allows\n        the model to intialize any state associated with this model.\n        Parameters\n        ----------",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.models.rec_postprocess.1.model",
        "documentation": {}
    },
    {
        "label": "SyncGRPCTritonRunner",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.client",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.client",
        "peekOfCode": "class SyncGRPCTritonRunner:\n    DEFAULT_MAX_RESP_WAIT_S = 120\n    def __init__(\n            self,\n            server_url: str,\n            model_name: str,\n            model_version: str,\n            *,\n            verbose=False,\n            resp_wait_s: Optional[float]=None, ):",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.client",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.client",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.client",
        "peekOfCode": "LOGGER = logging.getLogger(\"run_inference_on_triton\")\nclass SyncGRPCTritonRunner:\n    DEFAULT_MAX_RESP_WAIT_S = 120\n    def __init__(\n            self,\n            server_url: str,\n            model_name: str,\n            model_version: str,\n            *,\n            verbose=False,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.fastdeploy_serving.client",
        "documentation": {}
    },
    {
        "label": "det_model_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "det_model_dir = 'ch_PP-OCRv3_det_infer'\ncls_model_dir = 'ch_ppocr_mobile_v2.0_cls_infer'\nrec_model_dir = 'ch_PP-OCRv3_rec_infer'\nrec_label_file = 'ppocr_keys_v1.txt'\ndevice = 'cpu'\n# backend: ['paddle', 'trt'], you can also use other backends, but need to modify\n# the runtime option below\nbackend = 'paddle'\n# Prepare models\n# Detection model",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "cls_model_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "cls_model_dir = 'ch_ppocr_mobile_v2.0_cls_infer'\nrec_model_dir = 'ch_PP-OCRv3_rec_infer'\nrec_label_file = 'ppocr_keys_v1.txt'\ndevice = 'cpu'\n# backend: ['paddle', 'trt'], you can also use other backends, but need to modify\n# the runtime option below\nbackend = 'paddle'\n# Prepare models\n# Detection model\ndet_model_file = os.path.join(det_model_dir, \"inference.pdmodel\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "rec_model_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "rec_model_dir = 'ch_PP-OCRv3_rec_infer'\nrec_label_file = 'ppocr_keys_v1.txt'\ndevice = 'cpu'\n# backend: ['paddle', 'trt'], you can also use other backends, but need to modify\n# the runtime option below\nbackend = 'paddle'\n# Prepare models\n# Detection model\ndet_model_file = os.path.join(det_model_dir, \"inference.pdmodel\")\ndet_params_file = os.path.join(det_model_dir, \"inference.pdiparams\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "rec_label_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "rec_label_file = 'ppocr_keys_v1.txt'\ndevice = 'cpu'\n# backend: ['paddle', 'trt'], you can also use other backends, but need to modify\n# the runtime option below\nbackend = 'paddle'\n# Prepare models\n# Detection model\ndet_model_file = os.path.join(det_model_dir, \"inference.pdmodel\")\ndet_params_file = os.path.join(det_model_dir, \"inference.pdiparams\")\n# Classification model",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "device = 'cpu'\n# backend: ['paddle', 'trt'], you can also use other backends, but need to modify\n# the runtime option below\nbackend = 'paddle'\n# Prepare models\n# Detection model\ndet_model_file = os.path.join(det_model_dir, \"inference.pdmodel\")\ndet_params_file = os.path.join(det_model_dir, \"inference.pdiparams\")\n# Classification model\ncls_model_file = os.path.join(cls_model_dir, \"inference.pdmodel\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "backend",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "backend = 'paddle'\n# Prepare models\n# Detection model\ndet_model_file = os.path.join(det_model_dir, \"inference.pdmodel\")\ndet_params_file = os.path.join(det_model_dir, \"inference.pdiparams\")\n# Classification model\ncls_model_file = os.path.join(cls_model_dir, \"inference.pdmodel\")\ncls_params_file = os.path.join(cls_model_dir, \"inference.pdiparams\")\n# Recognition model\nrec_model_file = os.path.join(rec_model_dir, \"inference.pdmodel\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "det_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "det_model_file = os.path.join(det_model_dir, \"inference.pdmodel\")\ndet_params_file = os.path.join(det_model_dir, \"inference.pdiparams\")\n# Classification model\ncls_model_file = os.path.join(cls_model_dir, \"inference.pdmodel\")\ncls_params_file = os.path.join(cls_model_dir, \"inference.pdiparams\")\n# Recognition model\nrec_model_file = os.path.join(rec_model_dir, \"inference.pdmodel\")\nrec_params_file = os.path.join(rec_model_dir, \"inference.pdiparams\")\n# Setup runtime option to select hardware, backend, etc.\noption = fd.RuntimeOption()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "det_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "det_params_file = os.path.join(det_model_dir, \"inference.pdiparams\")\n# Classification model\ncls_model_file = os.path.join(cls_model_dir, \"inference.pdmodel\")\ncls_params_file = os.path.join(cls_model_dir, \"inference.pdiparams\")\n# Recognition model\nrec_model_file = os.path.join(rec_model_dir, \"inference.pdmodel\")\nrec_params_file = os.path.join(rec_model_dir, \"inference.pdiparams\")\n# Setup runtime option to select hardware, backend, etc.\noption = fd.RuntimeOption()\nif device.lower() == 'gpu':",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "cls_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "cls_model_file = os.path.join(cls_model_dir, \"inference.pdmodel\")\ncls_params_file = os.path.join(cls_model_dir, \"inference.pdiparams\")\n# Recognition model\nrec_model_file = os.path.join(rec_model_dir, \"inference.pdmodel\")\nrec_params_file = os.path.join(rec_model_dir, \"inference.pdiparams\")\n# Setup runtime option to select hardware, backend, etc.\noption = fd.RuntimeOption()\nif device.lower() == 'gpu':\n    option.use_gpu()\nif backend == 'trt':",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "cls_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "cls_params_file = os.path.join(cls_model_dir, \"inference.pdiparams\")\n# Recognition model\nrec_model_file = os.path.join(rec_model_dir, \"inference.pdmodel\")\nrec_params_file = os.path.join(rec_model_dir, \"inference.pdiparams\")\n# Setup runtime option to select hardware, backend, etc.\noption = fd.RuntimeOption()\nif device.lower() == 'gpu':\n    option.use_gpu()\nif backend == 'trt':\n    option.use_trt_backend()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "rec_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "rec_model_file = os.path.join(rec_model_dir, \"inference.pdmodel\")\nrec_params_file = os.path.join(rec_model_dir, \"inference.pdiparams\")\n# Setup runtime option to select hardware, backend, etc.\noption = fd.RuntimeOption()\nif device.lower() == 'gpu':\n    option.use_gpu()\nif backend == 'trt':\n    option.use_trt_backend()\nelse:\n    option.use_paddle_infer_backend()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "rec_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "rec_params_file = os.path.join(rec_model_dir, \"inference.pdiparams\")\n# Setup runtime option to select hardware, backend, etc.\noption = fd.RuntimeOption()\nif device.lower() == 'gpu':\n    option.use_gpu()\nif backend == 'trt':\n    option.use_trt_backend()\nelse:\n    option.use_paddle_infer_backend()\ndet_option = option",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "option = fd.RuntimeOption()\nif device.lower() == 'gpu':\n    option.use_gpu()\nif backend == 'trt':\n    option.use_trt_backend()\nelse:\n    option.use_paddle_infer_backend()\ndet_option = option\ndet_option.set_trt_input_shape(\"x\", [1, 3, 64, 64], [1, 3, 640, 640],\n                               [1, 3, 960, 960])",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "det_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "det_option = option\ndet_option.set_trt_input_shape(\"x\", [1, 3, 64, 64], [1, 3, 640, 640],\n                               [1, 3, 960, 960])\n# det_option.set_trt_cache_file(\"det_trt_cache.trt\")\nprint(det_model_file, det_params_file)\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_batch_size = 1\nrec_batch_size = 6\ncls_option = option",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "det_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "det_model = fd.vision.ocr.DBDetector(\n    det_model_file, det_params_file, runtime_option=det_option)\ncls_batch_size = 1\nrec_batch_size = 6\ncls_option = option\ncls_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [cls_batch_size, 3, 48, 320],\n                               [cls_batch_size, 3, 48, 1024])\n# cls_option.set_trt_cache_file(\"cls_trt_cache.trt\")\ncls_model = fd.vision.ocr.Classifier(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "cls_batch_size = 1\nrec_batch_size = 6\ncls_option = option\ncls_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [cls_batch_size, 3, 48, 320],\n                               [cls_batch_size, 3, 48, 1024])\n# cls_option.set_trt_cache_file(\"cls_trt_cache.trt\")\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_option = option",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "rec_batch_size = 6\ncls_option = option\ncls_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [cls_batch_size, 3, 48, 320],\n                               [cls_batch_size, 3, 48, 1024])\n# cls_option.set_trt_cache_file(\"cls_trt_cache.trt\")\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_option = option\nrec_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "cls_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "cls_option = option\ncls_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [cls_batch_size, 3, 48, 320],\n                               [cls_batch_size, 3, 48, 1024])\n# cls_option.set_trt_cache_file(\"cls_trt_cache.trt\")\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_option = option\nrec_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [rec_batch_size, 3, 48, 320],",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "cls_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "cls_model = fd.vision.ocr.Classifier(\n    cls_model_file, cls_params_file, runtime_option=cls_option)\nrec_option = option\nrec_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [rec_batch_size, 3, 48, 320],\n                               [rec_batch_size, 3, 48, 2304])\n# rec_option.set_trt_cache_file(\"rec_trt_cache.trt\")\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PPOCRv3 pipeline",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "rec_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "rec_option = option\nrec_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [rec_batch_size, 3, 48, 320],\n                               [rec_batch_size, 3, 48, 2304])\n# rec_option.set_trt_cache_file(\"rec_trt_cache.trt\")\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PPOCRv3 pipeline\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "rec_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "rec_model = fd.vision.ocr.Recognizer(\n    rec_model_file, rec_params_file, rec_label_file, runtime_option=rec_option)\n# Create PPOCRv3 pipeline\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\nppocr_v3.cls_batch_size = cls_batch_size\nppocr_v3.rec_batch_size = rec_batch_size\n# Create server, setup REST API\napp = SimpleServer()\napp.register(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "ppocr_v3",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "ppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\nppocr_v3.cls_batch_size = cls_batch_size\nppocr_v3.rec_batch_size = rec_batch_size\n# Create server, setup REST API\napp = SimpleServer()\napp.register(\n    task_name=\"fd/ppocrv3\",\n    model_handler=fd.serving.handler.VisionModelHandler,\n    predictor=ppocr_v3)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "ppocr_v3.cls_batch_size = cls_batch_size\nppocr_v3.rec_batch_size = rec_batch_size\n# Create server, setup REST API\napp = SimpleServer()\napp.register(\n    task_name=\"fd/ppocrv3\",\n    model_handler=fd.serving.handler.VisionModelHandler,\n    predictor=ppocr_v3)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "ppocr_v3.rec_batch_size = rec_batch_size\n# Create server, setup REST API\napp = SimpleServer()\napp.register(\n    task_name=\"fd/ppocrv3\",\n    model_handler=fd.serving.handler.VisionModelHandler,\n    predictor=ppocr_v3)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "peekOfCode": "app = SimpleServer()\napp.register(\n    task_name=\"fd/ppocrv3\",\n    model_handler=fd.serving.handler.VisionModelHandler,\n    predictor=ppocr_v3)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.serving.simple_serving.server",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "def parse_arguments():\n    import argparse\n    import ast\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--det_model\", required=True, help=\"Path of Detection model of PPOCR.\")\n    parser.add_argument(\n        \"--cls_model\",\n        required=True,\n        help=\"Path of Classification model of PPOCR.\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "args = parse_arguments()\n# 配置runtime，加载模型\nruntime_option = fd.RuntimeOption()\nruntime_option.use_sophgo()\n# Detection模型, 检测文字框\ndet_model_file = args.det_model\ndet_params_file = \"\"\n# Classification模型，方向分类，可选\ncls_model_file = args.cls_model\ncls_params_file = \"\"",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "runtime_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "runtime_option = fd.RuntimeOption()\nruntime_option.use_sophgo()\n# Detection模型, 检测文字框\ndet_model_file = args.det_model\ndet_params_file = \"\"\n# Classification模型，方向分类，可选\ncls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "det_model_file = args.det_model\ndet_params_file = \"\"\n# Classification模型，方向分类，可选\ncls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\n# PPOCR的cls和rec模型现在已经支持推理一个Batch的数据",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "det_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "det_params_file = \"\"\n# Classification模型，方向分类，可选\ncls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\n# PPOCR的cls和rec模型现在已经支持推理一个Batch的数据\n# 定义下面两个变量后, 可用于设置trt输入shape, 并在PPOCR模型初始化后, 完成Batch推理设置",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "cls_model_file = args.cls_model\ncls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\n# PPOCR的cls和rec模型现在已经支持推理一个Batch的数据\n# 定义下面两个变量后, 可用于设置trt输入shape, 并在PPOCR模型初始化后, 完成Batch推理设置\ncls_batch_size = 1\nrec_batch_size = 1",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "cls_params_file = \"\"\n# Recognition模型，文字识别模型\nrec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\n# PPOCR的cls和rec模型现在已经支持推理一个Batch的数据\n# 定义下面两个变量后, 可用于设置trt输入shape, 并在PPOCR模型初始化后, 完成Batch推理设置\ncls_batch_size = 1\nrec_batch_size = 1\n# 当使用TRT时，分别给三个模型的runtime设置动态shape,并完成模型的创建.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_model_file = args.rec_model\nrec_params_file = \"\"\nrec_label_file = args.rec_label_file\n# PPOCR的cls和rec模型现在已经支持推理一个Batch的数据\n# 定义下面两个变量后, 可用于设置trt输入shape, 并在PPOCR模型初始化后, 完成Batch推理设置\ncls_batch_size = 1\nrec_batch_size = 1\n# 当使用TRT时，分别给三个模型的runtime设置动态shape,并完成模型的创建.\n# 注意: 需要在检测模型创建完成后，再设置分类模型的动态输入并创建分类模型, 识别模型同理.\n# 如果用户想要自己改动检测模型的输入shape, 我们建议用户把检测模型的长和高设置为32的倍数.",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_params_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_params_file = \"\"\nrec_label_file = args.rec_label_file\n# PPOCR的cls和rec模型现在已经支持推理一个Batch的数据\n# 定义下面两个变量后, 可用于设置trt输入shape, 并在PPOCR模型初始化后, 完成Batch推理设置\ncls_batch_size = 1\nrec_batch_size = 1\n# 当使用TRT时，分别给三个模型的runtime设置动态shape,并完成模型的创建.\n# 注意: 需要在检测模型创建完成后，再设置分类模型的动态输入并创建分类模型, 识别模型同理.\n# 如果用户想要自己改动检测模型的输入shape, 我们建议用户把检测模型的长和高设置为32的倍数.\ndet_option = runtime_option",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_label_file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_label_file = args.rec_label_file\n# PPOCR的cls和rec模型现在已经支持推理一个Batch的数据\n# 定义下面两个变量后, 可用于设置trt输入shape, 并在PPOCR模型初始化后, 完成Batch推理设置\ncls_batch_size = 1\nrec_batch_size = 1\n# 当使用TRT时，分别给三个模型的runtime设置动态shape,并完成模型的创建.\n# 注意: 需要在检测模型创建完成后，再设置分类模型的动态输入并创建分类模型, 识别模型同理.\n# 如果用户想要自己改动检测模型的输入shape, 我们建议用户把检测模型的长和高设置为32的倍数.\ndet_option = runtime_option\ndet_option.set_trt_input_shape(\"x\", [1, 3, 64, 64], [1, 3, 640, 640],",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "cls_batch_size = 1\nrec_batch_size = 1\n# 当使用TRT时，分别给三个模型的runtime设置动态shape,并完成模型的创建.\n# 注意: 需要在检测模型创建完成后，再设置分类模型的动态输入并创建分类模型, 识别模型同理.\n# 如果用户想要自己改动检测模型的输入shape, 我们建议用户把检测模型的长和高设置为32的倍数.\ndet_option = runtime_option\ndet_option.set_trt_input_shape(\"x\", [1, 3, 64, 64], [1, 3, 640, 640],\n                               [1, 3, 960, 960])\n# 用户可以把TRT引擎文件保存至本地\n# det_option.set_trt_cache_file(args.det_model  + \"/det_trt_cache.trt\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_batch_size = 1\n# 当使用TRT时，分别给三个模型的runtime设置动态shape,并完成模型的创建.\n# 注意: 需要在检测模型创建完成后，再设置分类模型的动态输入并创建分类模型, 识别模型同理.\n# 如果用户想要自己改动检测模型的输入shape, 我们建议用户把检测模型的长和高设置为32的倍数.\ndet_option = runtime_option\ndet_option.set_trt_input_shape(\"x\", [1, 3, 64, 64], [1, 3, 640, 640],\n                               [1, 3, 960, 960])\n# 用户可以把TRT引擎文件保存至本地\n# det_option.set_trt_cache_file(args.det_model  + \"/det_trt_cache.trt\")\ndet_model = fd.vision.ocr.DBDetector(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "det_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "det_option = runtime_option\ndet_option.set_trt_input_shape(\"x\", [1, 3, 64, 64], [1, 3, 640, 640],\n                               [1, 3, 960, 960])\n# 用户可以把TRT引擎文件保存至本地\n# det_option.set_trt_cache_file(args.det_model  + \"/det_trt_cache.trt\")\ndet_model = fd.vision.ocr.DBDetector(\n    det_model_file,\n    det_params_file,\n    runtime_option=det_option,\n    model_format=fd.ModelFormat.SOPHGO)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "det_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "det_model = fd.vision.ocr.DBDetector(\n    det_model_file,\n    det_params_file,\n    runtime_option=det_option,\n    model_format=fd.ModelFormat.SOPHGO)\ncls_option = runtime_option\ncls_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [cls_batch_size, 3, 48, 320],\n                               [cls_batch_size, 3, 48, 1024])\n# 用户可以把TRT引擎文件保存至本地",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "cls_option = runtime_option\ncls_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [cls_batch_size, 3, 48, 320],\n                               [cls_batch_size, 3, 48, 1024])\n# 用户可以把TRT引擎文件保存至本地\n# cls_option.set_trt_cache_file(args.cls_model  + \"/cls_trt_cache.trt\")\ncls_model = fd.vision.ocr.Classifier(\n    cls_model_file,\n    cls_params_file,\n    runtime_option=cls_option,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "cls_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "cls_model = fd.vision.ocr.Classifier(\n    cls_model_file,\n    cls_params_file,\n    runtime_option=cls_option,\n    model_format=fd.ModelFormat.SOPHGO)\nrec_option = runtime_option\nrec_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [rec_batch_size, 3, 48, 320],\n                               [rec_batch_size, 3, 48, 2304])\n# 用户可以把TRT引擎文件保存至本地",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_option",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_option = runtime_option\nrec_option.set_trt_input_shape(\"x\", [1, 3, 48, 10],\n                               [rec_batch_size, 3, 48, 320],\n                               [rec_batch_size, 3, 48, 2304])\n# 用户可以把TRT引擎文件保存至本地\n# rec_option.set_trt_cache_file(args.rec_model  + \"/rec_trt_cache.trt\")\nrec_model = fd.vision.ocr.Recognizer(\n    rec_model_file,\n    rec_params_file,\n    rec_label_file,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_model = fd.vision.ocr.Recognizer(\n    rec_model_file,\n    rec_params_file,\n    rec_label_file,\n    runtime_option=rec_option,\n    model_format=fd.ModelFormat.SOPHGO)\n# 创建PP-OCR，串联3个模型，其中cls_model可选，如无需求，可设置为None\nppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# 需要使用下行代码, 来启用rec模型的静态shape推理，这里rec模型的静态输入为[3, 48, 584]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "ppocr_v3 = fd.vision.ocr.PPOCRv3(\n    det_model=det_model, cls_model=cls_model, rec_model=rec_model)\n# 需要使用下行代码, 来启用rec模型的静态shape推理，这里rec模型的静态输入为[3, 48, 584]\nrec_model.preprocessor.static_shape_infer = True\nrec_model.preprocessor.rec_image_shape = [3, 48, 584]\n# 给cls和rec模型设置推理时的batch size\n# 此值能为-1, 和1到正无穷\n# 当此值为-1时, cls和rec模型的batch size将默认和det模型检测出的框的数量相同\nppocr_v3.cls_batch_size = cls_batch_size\nppocr_v3.rec_batch_size = rec_batch_size",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model.preprocessor.static_shape_infer",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_model.preprocessor.static_shape_infer = True\nrec_model.preprocessor.rec_image_shape = [3, 48, 584]\n# 给cls和rec模型设置推理时的batch size\n# 此值能为-1, 和1到正无穷\n# 当此值为-1时, cls和rec模型的batch size将默认和det模型检测出的框的数量相同\nppocr_v3.cls_batch_size = cls_batch_size\nppocr_v3.rec_batch_size = rec_batch_size\n# 预测图片准备\nim = cv2.imread(args.image)\n#预测并打印结果",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "rec_model.preprocessor.rec_image_shape",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "rec_model.preprocessor.rec_image_shape = [3, 48, 584]\n# 给cls和rec模型设置推理时的batch size\n# 此值能为-1, 和1到正无穷\n# 当此值为-1时, cls和rec模型的batch size将默认和det模型检测出的框的数量相同\nppocr_v3.cls_batch_size = cls_batch_size\nppocr_v3.rec_batch_size = rec_batch_size\n# 预测图片准备\nim = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.cls_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "ppocr_v3.cls_batch_size = cls_batch_size\nppocr_v3.rec_batch_size = rec_batch_size\n# 预测图片准备\nim = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"sophgo_result.jpg\", vis_im)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "ppocr_v3.rec_batch_size",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "ppocr_v3.rec_batch_size = rec_batch_size\n# 预测图片准备\nim = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"sophgo_result.jpg\", vis_im)\nprint(\"Visualized result save in ./sophgo_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "im = cv2.imread(args.image)\n#预测并打印结果\nresult = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"sophgo_result.jpg\", vis_im)\nprint(\"Visualized result save in ./sophgo_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "result = ppocr_v3.predict(im)\nprint(result)\n# 可视化结果\nvis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"sophgo_result.jpg\", vis_im)\nprint(\"Visualized result save in ./sophgo_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "vis_im",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "description": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "peekOfCode": "vis_im = fd.vision.vis_ppocr(im, result)\ncv2.imwrite(\"sophgo_result.jpg\", vis_im)\nprint(\"Visualized result save in ./sophgo_result.jpg\")",
        "detail": "Vision.Paddle.PaddleOCR.deploy.fastdeploy.sophgo.python.infer",
        "documentation": {}
    },
    {
        "label": "KIESer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.module",
        "peekOfCode": "class KIESer(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.module",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.params",
        "peekOfCode": "class Config(object):\n    pass\ndef read_params():\n    cfg = pp_ocr_read_params()\n    # SER params\n    cfg.kie_algorithm = \"LayoutXLM\"\n    cfg.use_visual_backbone = False\n    cfg.ser_model_dir = \"./inference/ser_vi_layoutxlm_xfund_infer\"\n    cfg.ser_dict_path = \"train_data/XFUND/class_list_xfun.txt\"\n    cfg.vis_font_path = \"./doc/fonts/simfang.ttf\"",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.params",
        "peekOfCode": "def read_params():\n    cfg = pp_ocr_read_params()\n    # SER params\n    cfg.kie_algorithm = \"LayoutXLM\"\n    cfg.use_visual_backbone = False\n    cfg.ser_model_dir = \"./inference/ser_vi_layoutxlm_xfund_infer\"\n    cfg.ser_dict_path = \"train_data/XFUND/class_list_xfun.txt\"\n    cfg.vis_font_path = \"./doc/fonts/simfang.ttf\"\n    cfg.ocr_order_method = \"tb-yx\"\n    return cfg",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser.params",
        "documentation": {}
    },
    {
        "label": "KIESerRE",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.module",
        "peekOfCode": "class KIESerRE(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.module",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.params",
        "peekOfCode": "class Config(object):\n    pass\ndef read_params():\n    cfg = pp_ocr_read_params()\n    # SER params\n    cfg.kie_algorithm = \"LayoutXLM\"\n    cfg.use_visual_backbone = False\n    cfg.ser_model_dir = \"./inference/ser_vi_layoutxlm_xfund_infer\"\n    cfg.re_model_dir = \"./inference/re_vi_layoutxlm_xfund_infer\"\n    cfg.ser_dict_path = \"train_data/XFUND/class_list_xfun.txt\"",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.params",
        "peekOfCode": "def read_params():\n    cfg = pp_ocr_read_params()\n    # SER params\n    cfg.kie_algorithm = \"LayoutXLM\"\n    cfg.use_visual_backbone = False\n    cfg.ser_model_dir = \"./inference/ser_vi_layoutxlm_xfund_infer\"\n    cfg.re_model_dir = \"./inference/re_vi_layoutxlm_xfund_infer\"\n    cfg.ser_dict_path = \"train_data/XFUND/class_list_xfun.txt\"\n    cfg.vis_font_path = \"./doc/fonts/simfang.ttf\"\n    cfg.ocr_order_method = \"tb-yx\"",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.kie_ser_re.params",
        "documentation": {}
    },
    {
        "label": "OCRCls",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.module",
        "peekOfCode": "class OCRCls(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.module",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.params",
        "peekOfCode": "class Config(object):\n    pass\ndef read_params():\n    cfg = Config()\n    #params for text classifier\n    cfg.cls_model_dir = \"./inference/ch_ppocr_mobile_v2.0_cls_infer/\"\n    cfg.cls_image_shape = \"3, 48, 192\"\n    cfg.label_list = ['0', '180']\n    cfg.cls_batch_num = 30\n    cfg.cls_thresh = 0.9",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.params",
        "peekOfCode": "def read_params():\n    cfg = Config()\n    #params for text classifier\n    cfg.cls_model_dir = \"./inference/ch_ppocr_mobile_v2.0_cls_infer/\"\n    cfg.cls_image_shape = \"3, 48, 192\"\n    cfg.label_list = ['0', '180']\n    cfg.cls_batch_num = 30\n    cfg.cls_thresh = 0.9\n    cfg.use_pdserving = False\n    cfg.use_tensorrt = False",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_cls.params",
        "documentation": {}
    },
    {
        "label": "OCRDet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.module",
        "peekOfCode": "class OCRDet(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.module",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.params",
        "peekOfCode": "class Config(object):\n    pass\ndef read_params():\n    cfg = Config()\n    #params for text detector\n    cfg.det_algorithm = \"DB\"\n    cfg.det_model_dir = \"./inference/ch_PP-OCRv3_det_infer/\"\n    cfg.det_limit_side_len = 960\n    cfg.det_limit_type = 'max'\n    #DB parmas",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.params",
        "peekOfCode": "def read_params():\n    cfg = Config()\n    #params for text detector\n    cfg.det_algorithm = \"DB\"\n    cfg.det_model_dir = \"./inference/ch_PP-OCRv3_det_infer/\"\n    cfg.det_limit_side_len = 960\n    cfg.det_limit_type = 'max'\n    #DB parmas\n    cfg.det_db_thresh = 0.3\n    cfg.det_db_box_thresh = 0.6",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_det.params",
        "documentation": {}
    },
    {
        "label": "OCRRec",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.module",
        "peekOfCode": "class OCRRec(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.module",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.params",
        "peekOfCode": "class Config(object):\n    pass\ndef read_params():\n    cfg = Config()\n    #params for text recognizer\n    cfg.rec_algorithm = \"CRNN\"\n    cfg.rec_model_dir = \"./inference/ch_PP-OCRv3_rec_infer/\"\n    cfg.rec_image_shape = \"3, 48, 320\"\n    cfg.rec_batch_num = 6\n    cfg.max_text_length = 25",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.params",
        "peekOfCode": "def read_params():\n    cfg = Config()\n    #params for text recognizer\n    cfg.rec_algorithm = \"CRNN\"\n    cfg.rec_model_dir = \"./inference/ch_PP-OCRv3_rec_infer/\"\n    cfg.rec_image_shape = \"3, 48, 320\"\n    cfg.rec_batch_num = 6\n    cfg.max_text_length = 25\n    cfg.rec_char_dict_path = \"./ppocr/utils/ppocr_keys_v1.txt\"\n    cfg.use_space_char = True",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_rec.params",
        "documentation": {}
    },
    {
        "label": "OCRSystem",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.module",
        "peekOfCode": "class OCRSystem(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.module",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.params",
        "peekOfCode": "class Config(object):\n    pass\ndef read_params():\n    cfg = Config()\n    #params for text detector\n    cfg.det_algorithm = \"DB\"\n    cfg.det_model_dir = \"./inference/ch_PP-OCRv3_det_infer/\"\n    cfg.det_limit_side_len = 960\n    cfg.det_limit_type = 'max'\n    #DB parmas",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.params",
        "peekOfCode": "def read_params():\n    cfg = Config()\n    #params for text detector\n    cfg.det_algorithm = \"DB\"\n    cfg.det_model_dir = \"./inference/ch_PP-OCRv3_det_infer/\"\n    cfg.det_limit_side_len = 960\n    cfg.det_limit_type = 'max'\n    #DB parmas\n    cfg.det_db_thresh = 0.3\n    cfg.det_db_box_thresh = 0.5",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.ocr_system.params",
        "documentation": {}
    },
    {
        "label": "LayoutPredictor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.module",
        "peekOfCode": "class LayoutPredictor(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.module",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.params",
        "peekOfCode": "class Config(object):\n    pass\ndef read_params():\n    cfg = Config()\n    # params for layout analysis\n    cfg.layout_model_dir = './inference/picodet_lcnet_x1_0_fgd_layout_infer/'\n    cfg.layout_dict_path = './ppocr/utils/dict/layout_dict/layout_publaynet_dict.txt'\n    cfg.layout_score_threshold = 0.5\n    cfg.layout_nms_threshold = 0.5\n    return cfg",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.params",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.params",
        "peekOfCode": "def read_params():\n    cfg = Config()\n    # params for layout analysis\n    cfg.layout_model_dir = './inference/picodet_lcnet_x1_0_fgd_layout_infer/'\n    cfg.layout_dict_path = './ppocr/utils/dict/layout_dict/layout_publaynet_dict.txt'\n    cfg.layout_score_threshold = 0.5\n    cfg.layout_nms_threshold = 0.5\n    return cfg",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_layout.params",
        "documentation": {}
    },
    {
        "label": "StructureSystem",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_system.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_system.module",
        "peekOfCode": "class StructureSystem(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_system.module",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_system.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_system.params",
        "peekOfCode": "def read_params():\n    cfg = table_read_params()\n    # params for layout parser model\n    cfg.layout_model_dir = ''\n    cfg.layout_dict_path = './ppocr/utils/dict/layout_publaynet_dict.txt'\n    cfg.layout_score_threshold = 0.5\n    cfg.layout_nms_threshold = 0.5\n    cfg.mode = 'structure'\n    cfg.output = './output'\n    return cfg",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_system.params",
        "documentation": {}
    },
    {
        "label": "TableSystem",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_table.module",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_table.module",
        "peekOfCode": "class TableSystem(hub.Module):\n    def _initialize(self, use_gpu=False, enable_mkldnn=False):\n        \"\"\"\n        initialize with the necessary elements\n        \"\"\"\n        cfg = self.merge_configs()\n        cfg.use_gpu = use_gpu\n        if use_gpu:\n            try:\n                _places = os.environ[\"CUDA_VISIBLE_DEVICES\"]",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_table.module",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_table.params",
        "description": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_table.params",
        "peekOfCode": "def read_params():\n    cfg = pp_ocr_read_params()\n    # params for table structure model\n    cfg.table_max_len = 488\n    cfg.table_model_dir = './inference/en_ppocr_mobile_v2.0_table_structure_infer/'\n    cfg.table_char_dict_path = './ppocr/utils/dict/table_structure_dict.txt'\n    cfg.show_log = False\n    return cfg",
        "detail": "Vision.Paddle.PaddleOCR.deploy.hubserving.structure_table.params",
        "documentation": {}
    },
    {
        "label": "DetResizeForTest",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "peekOfCode": "class DetResizeForTest(object):\n    def __init__(self, **kwargs):\n        super(DetResizeForTest, self).__init__()\n        self.resize_type = 0\n        if 'image_shape' in kwargs:\n            self.image_shape = kwargs['image_shape']\n            self.resize_type = 1\n        elif 'limit_side_len' in kwargs:\n            self.limit_side_len = kwargs['limit_side_len']\n            self.limit_type = kwargs.get('limit_type', 'min')",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "documentation": {}
    },
    {
        "label": "BaseRecLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "peekOfCode": "class BaseRecLabelDecode(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, config):\n        support_character_type = [\n            'ch', 'en', 'EN_symbol', 'french', 'german', 'japan', 'korean',\n            'it', 'xi', 'pu', 'ru', 'ar', 'ta', 'ug', 'fa', 'ur', 'rs', 'oc',\n            'rsc', 'bg', 'uk', 'be', 'te', 'ka', 'chinese_cht', 'hi', 'mr',\n            'ne', 'EN'\n        ]\n        character_type = config['character_type']",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "documentation": {}
    },
    {
        "label": "CTCLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "peekOfCode": "class CTCLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(\n            self,\n            config,\n            #character_dict_path=None,\n            #character_type='ch',\n            #use_space_char=False,\n            **kwargs):\n        super(CTCLabelDecode, self).__init__(config)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "documentation": {}
    },
    {
        "label": "CharacterOps",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "peekOfCode": "class CharacterOps(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, config):\n        self.character_type = config['character_type']\n        self.loss_type = config['loss_type']\n        if self.character_type == \"en\":\n            self.character_str = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n            dict_character = list(self.character_str)\n        elif self.character_type == \"ch\":\n            character_dict_path = config['character_dict_path']",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "documentation": {}
    },
    {
        "label": "OCRReader",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "peekOfCode": "class OCRReader(object):\n    def __init__(self,\n                 algorithm=\"CRNN\",\n                 image_shape=[3, 32, 320],\n                 char_type=\"ch\",\n                 batch_num=1,\n                 char_dict_path=\"./ppocr_keys_v1.txt\"):\n        self.rec_image_shape = image_shape\n        self.character_type = char_type\n        self.rec_batch_num = batch_num",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_reader",
        "documentation": {}
    },
    {
        "label": "cv2_to_base64",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "peekOfCode": "def cv2_to_base64(image):\n    #data = cv2.imencode('.jpg', image)[1]\n    return base64.b64encode(image).decode(\n        'utf8')  #data.tostring()).decode('utf8')\nheaders = {\"Content-type\": \"application/json\"}\nurl = \"http://127.0.0.1:9292/ocr/prediction\"\ntest_img_dir = \"../../../doc/imgs/\"\nfor idx, img_file in enumerate(os.listdir(test_img_dir)):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data1 = file.read()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "documentation": {}
    },
    {
        "label": "headers",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "peekOfCode": "headers = {\"Content-type\": \"application/json\"}\nurl = \"http://127.0.0.1:9292/ocr/prediction\"\ntest_img_dir = \"../../../doc/imgs/\"\nfor idx, img_file in enumerate(os.listdir(test_img_dir)):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data1 = file.read()\n    image = cv2_to_base64(image_data1)\n    for i in range(1):\n        data = {\"feed\": [{\"image\": image}], \"fetch\": [\"save_infer_model/scale_0.tmp_1\"]}\n        r = requests.post(url=url, headers=headers, data=json.dumps(data))",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "peekOfCode": "url = \"http://127.0.0.1:9292/ocr/prediction\"\ntest_img_dir = \"../../../doc/imgs/\"\nfor idx, img_file in enumerate(os.listdir(test_img_dir)):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data1 = file.read()\n    image = cv2_to_base64(image_data1)\n    for i in range(1):\n        data = {\"feed\": [{\"image\": image}], \"fetch\": [\"save_infer_model/scale_0.tmp_1\"]}\n        r = requests.post(url=url, headers=headers, data=json.dumps(data))\n        print(r.json())",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "documentation": {}
    },
    {
        "label": "test_img_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "peekOfCode": "test_img_dir = \"../../../doc/imgs/\"\nfor idx, img_file in enumerate(os.listdir(test_img_dir)):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data1 = file.read()\n    image = cv2_to_base64(image_data1)\n    for i in range(1):\n        data = {\"feed\": [{\"image\": image}], \"fetch\": [\"save_infer_model/scale_0.tmp_1\"]}\n        r = requests.post(url=url, headers=headers, data=json.dumps(data))\n        print(r.json())\ntest_img_dir = \"../../../doc/imgs/\"",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "documentation": {}
    },
    {
        "label": "test_img_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "peekOfCode": "test_img_dir = \"../../../doc/imgs/\"\nprint(\"==> total number of test imgs: \", len(os.listdir(test_img_dir)))",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_client",
        "documentation": {}
    },
    {
        "label": "OCRService",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_server",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_server",
        "peekOfCode": "class OCRService(WebService):\n    def init_det_debugger(self, det_model_config):\n        self.det_preprocess = Sequential([\n            ResizeByFactor(32, 960), Div(255),\n            Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]), Transpose(\n                (2, 0, 1))\n        ])\n        self.det_client = LocalPredictor()\n        if sys.argv[1] == 'gpu':\n            self.det_client.load_model_config(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_server",
        "documentation": {}
    },
    {
        "label": "ocr_service",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_server",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_server",
        "peekOfCode": "ocr_service = OCRService(name=\"ocr\")\nocr_service.load_model_config(\"../ppocr_rec_mobile_2.0_serving\")\nocr_service.prepare_server(workdir=\"workdir\", port=9292)\nocr_service.init_det_debugger(det_model_config=\"../ppocr_det_mobile_2.0_serving\")\nif sys.argv[1] == 'gpu':\n    ocr_service.set_gpus(\"0\")\n    ocr_service.run_debugger_service(gpu=True)\nelif sys.argv[1] == 'cpu':\n    ocr_service.run_debugger_service()\nocr_service.run_web_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.win.ocr_web_server",
        "documentation": {}
    },
    {
        "label": "cv2_to_base64",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "peekOfCode": "def cv2_to_base64(image):\n    return base64.b64encode(image).decode(\n        'utf8')  #data.tostring()).decode('utf8')\ndef _check_image_file(path):\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif'}\n    return any([path.lower().endswith(e) for e in img_end])\ntest_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):\n    test_img_list.append(test_img_dir)\nelif os.path.isdir(test_img_dir):",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "peekOfCode": "client = Client()\n# TODO:load_client need to load more than one client model.\n# this need to figure out some details.\nclient.load_client_config(sys.argv[1:])\nclient.connect([\"127.0.0.1:8181\"])\nimport paddle\ntest_img_dir = \"../../doc/imgs/1.jpg\"\nocr_reader = OCRReader(char_dict_path=\"../../ppocr/utils/ppocr_keys_v1.txt\")\ndef cv2_to_base64(image):\n    return base64.b64encode(image).decode(",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "documentation": {}
    },
    {
        "label": "test_img_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "peekOfCode": "test_img_dir = \"../../doc/imgs/1.jpg\"\nocr_reader = OCRReader(char_dict_path=\"../../ppocr/utils/ppocr_keys_v1.txt\")\ndef cv2_to_base64(image):\n    return base64.b64encode(image).decode(\n        'utf8')  #data.tostring()).decode('utf8')\ndef _check_image_file(path):\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif'}\n    return any([path.lower().endswith(e) for e in img_end])\ntest_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "documentation": {}
    },
    {
        "label": "ocr_reader",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "peekOfCode": "ocr_reader = OCRReader(char_dict_path=\"../../ppocr/utils/ppocr_keys_v1.txt\")\ndef cv2_to_base64(image):\n    return base64.b64encode(image).decode(\n        'utf8')  #data.tostring()).decode('utf8')\ndef _check_image_file(path):\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif'}\n    return any([path.lower().endswith(e) for e in img_end])\ntest_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):\n    test_img_list.append(test_img_dir)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "documentation": {}
    },
    {
        "label": "test_img_list",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "peekOfCode": "test_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):\n    test_img_list.append(test_img_dir)\nelif os.path.isdir(test_img_dir):\n    for single_file in os.listdir(test_img_dir):\n        file_path = os.path.join(test_img_dir, single_file)\n        if os.path.isfile(file_path) and _check_image_file(file_path):\n            test_img_list.append(file_path)\nif len(test_img_list) == 0:\n    raise Exception(\"not found any img file in {}\".format(test_img_dir))",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_cpp_client",
        "documentation": {}
    },
    {
        "label": "DetResizeForTest",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "peekOfCode": "class DetResizeForTest(object):\n    def __init__(self, **kwargs):\n        super(DetResizeForTest, self).__init__()\n        self.resize_type = 0\n        if 'image_shape' in kwargs:\n            self.image_shape = kwargs['image_shape']\n            self.resize_type = 1\n        elif 'limit_side_len' in kwargs:\n            self.limit_side_len = kwargs['limit_side_len']\n            self.limit_type = kwargs.get('limit_type', 'min')",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "documentation": {}
    },
    {
        "label": "BaseRecLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "peekOfCode": "class BaseRecLabelDecode(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, config):\n        support_character_type = [\n            'ch', 'en', 'EN_symbol', 'french', 'german', 'japan', 'korean',\n            'it', 'xi', 'pu', 'ru', 'ar', 'ta', 'ug', 'fa', 'ur', 'rs', 'oc',\n            'rsc', 'bg', 'uk', 'be', 'te', 'ka', 'chinese_cht', 'hi', 'mr',\n            'ne', 'EN'\n        ]\n        character_type = config['character_type']",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "documentation": {}
    },
    {
        "label": "CTCLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "peekOfCode": "class CTCLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(\n            self,\n            config,\n            #character_dict_path=None,\n            #character_type='ch',\n            #use_space_char=False,\n            **kwargs):\n        super(CTCLabelDecode, self).__init__(config)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "documentation": {}
    },
    {
        "label": "CharacterOps",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "peekOfCode": "class CharacterOps(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, config):\n        self.character_type = config['character_type']\n        self.loss_type = config['loss_type']\n        if self.character_type == \"en\":\n            self.character_str = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n            dict_character = list(self.character_str)\n        elif self.character_type == \"ch\":\n            character_dict_path = config['character_dict_path']",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "documentation": {}
    },
    {
        "label": "OCRReader",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "peekOfCode": "class OCRReader(object):\n    def __init__(self,\n                 algorithm=\"CRNN\",\n                 image_shape=[3, 48, 320],\n                 char_type=\"ch\",\n                 batch_num=1,\n                 char_dict_path=\"./ppocr_keys_v1.txt\"):\n        self.rec_image_shape = image_shape\n        self.character_type = char_type\n        self.rec_batch_num = batch_num",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "peekOfCode": "class ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\"-c\", \"--config\", help=\"configuration file to use\")\n        self.add_argument(\n            \"-o\", \"--opt\", nargs='+', help=\"set configuration options\")\n    def parse_args(self, argv=None):\n        args = super(ArgsParser, self).parse_args(argv)\n        assert args.config is not None, \\",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.ocr_reader",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "peekOfCode": "def str2bool(v):\n    return v.lower() in (\"true\", \"t\", \"1\")\nparser = argparse.ArgumentParser(description=\"args for paddleserving\")\nparser.add_argument(\"--image_dir\", type=str, default=\"../../doc/imgs/\")\nparser.add_argument(\"--det\", type=str2bool, default=True)\nparser.add_argument(\"--rec\", type=str2bool, default=True)\nargs = parser.parse_args()\ndef cv2_to_base64(image):\n    return base64.b64encode(image).decode('utf8')\ndef _check_image_file(path):",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "documentation": {}
    },
    {
        "label": "cv2_to_base64",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "peekOfCode": "def cv2_to_base64(image):\n    return base64.b64encode(image).decode('utf8')\ndef _check_image_file(path):\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif'}\n    return any([path.lower().endswith(e) for e in img_end])\nurl = \"http://127.0.0.1:9998/ocr/prediction\"\ntest_img_dir = args.image_dir\ntest_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):\n    test_img_list.append(test_img_dir)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"args for paddleserving\")\nparser.add_argument(\"--image_dir\", type=str, default=\"../../doc/imgs/\")\nparser.add_argument(\"--det\", type=str2bool, default=True)\nparser.add_argument(\"--rec\", type=str2bool, default=True)\nargs = parser.parse_args()\ndef cv2_to_base64(image):\n    return base64.b64encode(image).decode('utf8')\ndef _check_image_file(path):\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif'}\n    return any([path.lower().endswith(e) for e in img_end])",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "peekOfCode": "args = parser.parse_args()\ndef cv2_to_base64(image):\n    return base64.b64encode(image).decode('utf8')\ndef _check_image_file(path):\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif'}\n    return any([path.lower().endswith(e) for e in img_end])\nurl = \"http://127.0.0.1:9998/ocr/prediction\"\ntest_img_dir = args.image_dir\ntest_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "peekOfCode": "url = \"http://127.0.0.1:9998/ocr/prediction\"\ntest_img_dir = args.image_dir\ntest_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):\n    test_img_list.append(test_img_dir)\nelif os.path.isdir(test_img_dir):\n    for single_file in os.listdir(test_img_dir):\n        file_path = os.path.join(test_img_dir, single_file)\n        if os.path.isfile(file_path) and _check_image_file(file_path):\n            test_img_list.append(file_path)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "documentation": {}
    },
    {
        "label": "test_img_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "peekOfCode": "test_img_dir = args.image_dir\ntest_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):\n    test_img_list.append(test_img_dir)\nelif os.path.isdir(test_img_dir):\n    for single_file in os.listdir(test_img_dir):\n        file_path = os.path.join(test_img_dir, single_file)\n        if os.path.isfile(file_path) and _check_image_file(file_path):\n            test_img_list.append(file_path)\nif len(test_img_list) == 0:",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "documentation": {}
    },
    {
        "label": "test_img_list",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "peekOfCode": "test_img_list = []\nif os.path.isfile(test_img_dir) and _check_image_file(test_img_dir):\n    test_img_list.append(test_img_dir)\nelif os.path.isdir(test_img_dir):\n    for single_file in os.listdir(test_img_dir):\n        file_path = os.path.join(test_img_dir, single_file)\n        if os.path.isfile(file_path) and _check_image_file(file_path):\n            test_img_list.append(file_path)\nif len(test_img_list) == 0:\n    raise Exception(\"not found any img file in {}\".format(test_img_dir))",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_http_client",
        "documentation": {}
    },
    {
        "label": "cv2_to_base64",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "peekOfCode": "def cv2_to_base64(image):\n    return base64.b64encode(image).decode('utf8')\nimport argparse\nparser = argparse.ArgumentParser(description=\"args for paddleserving\")\nparser.add_argument(\"--image_dir\", type=str, default=\"../../doc/imgs/\")\nargs = parser.parse_args()\ntest_img_dir = args.image_dir\nfor img_file in os.listdir(test_img_dir):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data = file.read()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "peekOfCode": "client = PipelineClient()\nclient.connect(['127.0.0.1:18091'])\ndef cv2_to_base64(image):\n    return base64.b64encode(image).decode('utf8')\nimport argparse\nparser = argparse.ArgumentParser(description=\"args for paddleserving\")\nparser.add_argument(\"--image_dir\", type=str, default=\"../../doc/imgs/\")\nargs = parser.parse_args()\ntest_img_dir = args.image_dir\nfor img_file in os.listdir(test_img_dir):",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"args for paddleserving\")\nparser.add_argument(\"--image_dir\", type=str, default=\"../../doc/imgs/\")\nargs = parser.parse_args()\ntest_img_dir = args.image_dir\nfor img_file in os.listdir(test_img_dir):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data = file.read()\n    image = cv2_to_base64(image_data)\n    for i in range(1):\n        ret = client.predict(feed_dict={\"image\": image}, fetch=[\"res\"])",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "peekOfCode": "args = parser.parse_args()\ntest_img_dir = args.image_dir\nfor img_file in os.listdir(test_img_dir):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data = file.read()\n    image = cv2_to_base64(image_data)\n    for i in range(1):\n        ret = client.predict(feed_dict={\"image\": image}, fetch=[\"res\"])\n        print(ret)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "documentation": {}
    },
    {
        "label": "test_img_dir",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "peekOfCode": "test_img_dir = args.image_dir\nfor img_file in os.listdir(test_img_dir):\n    with open(os.path.join(test_img_dir, img_file), 'rb') as file:\n        image_data = file.read()\n    image = cv2_to_base64(image_data)\n    for i in range(1):\n        ret = client.predict(feed_dict={\"image\": image}, fetch=[\"res\"])\n        print(ret)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.pipeline_rpc_client",
        "documentation": {}
    },
    {
        "label": "DetOp",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "peekOfCode": "class DetOp(Op):\n    def init_op(self):\n        self.det_preprocess = Sequential([\n            DetResizeForTest(), Div(255),\n            Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]), Transpose(\n                (2, 0, 1))\n        ])\n        self.filter_func = FilterBoxes(10, 10)\n        self.post_func = DBPostProcess({\n            \"thresh\": 0.3,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "documentation": {}
    },
    {
        "label": "RecOp",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "peekOfCode": "class RecOp(Op):\n    def init_op(self):\n        self.ocr_reader = OCRReader(\n            char_dict_path=\"../../ppocr/utils/ppocr_keys_v1.txt\")\n        self.get_rotate_crop_image = GetRotateCropImage()\n        self.sorted_boxes = SortedBoxes()\n    def preprocess(self, input_dicts, data_id, log_id):\n        (_, input_dict), = input_dicts.items()\n        raw_im = input_dict[\"image\"]\n        data = np.frombuffer(raw_im, np.uint8)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "documentation": {}
    },
    {
        "label": "OcrService",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "peekOfCode": "class OcrService(WebService):\n    def get_pipeline_response(self, read_op):\n        det_op = DetOp(name=\"det\", input_ops=[read_op])\n        rec_op = RecOp(name=\"rec\", input_ops=[det_op])\n        return rec_op\nuci_service = OcrService(name=\"ocr\")\nFLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "documentation": {}
    },
    {
        "label": "_LOGGER",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "peekOfCode": "_LOGGER = logging.getLogger()\nclass DetOp(Op):\n    def init_op(self):\n        self.det_preprocess = Sequential([\n            DetResizeForTest(), Div(255),\n            Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]), Transpose(\n                (2, 0, 1))\n        ])\n        self.filter_func = FilterBoxes(10, 10)\n        self.post_func = DBPostProcess({",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "documentation": {}
    },
    {
        "label": "uci_service",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "peekOfCode": "uci_service = OcrService(name=\"ocr\")\nFLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "documentation": {}
    },
    {
        "label": "FLAGS",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "peekOfCode": "FLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service",
        "documentation": {}
    },
    {
        "label": "DetOp",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "peekOfCode": "class DetOp(Op):\n    def init_op(self):\n        self.det_preprocess = Sequential([\n            DetResizeForTest(), Div(255),\n            Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]), Transpose(\n                (2, 0, 1))\n        ])\n        self.filter_func = FilterBoxes(10, 10)\n        self.post_func = DBPostProcess({\n            \"thresh\": 0.3,",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "documentation": {}
    },
    {
        "label": "OcrService",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "peekOfCode": "class OcrService(WebService):\n    def get_pipeline_response(self, read_op):\n        det_op = DetOp(name=\"det\", input_ops=[read_op])\n        return det_op\nuci_service = OcrService(name=\"ocr\")\nFLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "documentation": {}
    },
    {
        "label": "_LOGGER",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "peekOfCode": "_LOGGER = logging.getLogger()\nclass DetOp(Op):\n    def init_op(self):\n        self.det_preprocess = Sequential([\n            DetResizeForTest(), Div(255),\n            Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]), Transpose(\n                (2, 0, 1))\n        ])\n        self.filter_func = FilterBoxes(10, 10)\n        self.post_func = DBPostProcess({",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "documentation": {}
    },
    {
        "label": "uci_service",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "peekOfCode": "uci_service = OcrService(name=\"ocr\")\nFLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "documentation": {}
    },
    {
        "label": "FLAGS",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "peekOfCode": "FLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_det",
        "documentation": {}
    },
    {
        "label": "RecOp",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "peekOfCode": "class RecOp(Op):\n    def init_op(self):\n        self.ocr_reader = OCRReader(\n            char_dict_path=\"../../ppocr/utils/ppocr_keys_v1.txt\")\n    def preprocess(self, input_dicts, data_id, log_id):\n        (_, input_dict), = input_dicts.items()\n        raw_im = base64.b64decode(input_dict[\"image\"].encode('utf8'))\n        data = np.fromstring(raw_im, np.uint8)\n        im = cv2.imdecode(data, cv2.IMREAD_COLOR)\n        feed_list = []",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "documentation": {}
    },
    {
        "label": "OcrService",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "peekOfCode": "class OcrService(WebService):\n    def get_pipeline_response(self, read_op):\n        rec_op = RecOp(name=\"rec\", input_ops=[read_op])\n        return rec_op\nuci_service = OcrService(name=\"ocr\")\nFLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "documentation": {}
    },
    {
        "label": "_LOGGER",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "peekOfCode": "_LOGGER = logging.getLogger()\nclass RecOp(Op):\n    def init_op(self):\n        self.ocr_reader = OCRReader(\n            char_dict_path=\"../../ppocr/utils/ppocr_keys_v1.txt\")\n    def preprocess(self, input_dicts, data_id, log_id):\n        (_, input_dict), = input_dicts.items()\n        raw_im = base64.b64decode(input_dict[\"image\"].encode('utf8'))\n        data = np.fromstring(raw_im, np.uint8)\n        im = cv2.imdecode(data, cv2.IMREAD_COLOR)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "documentation": {}
    },
    {
        "label": "uci_service",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "peekOfCode": "uci_service = OcrService(name=\"ocr\")\nFLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "documentation": {}
    },
    {
        "label": "FLAGS",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "description": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "peekOfCode": "FLAGS = ArgsParser().parse_args()\nuci_service.prepare_pipeline_config(yml_dict=FLAGS.conf_dict)\nuci_service.run_service()",
        "detail": "Vision.Paddle.PaddleOCR.deploy.pdserving.web_service_rec",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.prune.export_prune_model",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.prune.export_prune_model",
        "peekOfCode": "def main(config, device, logger, vdl_writer):\n    global_config = config['Global']\n    # build dataloader\n    set_signal_handlers()\n    valid_dataloader = build_dataloader(config, 'Eval', device, logger)\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n    # build model\n    # for rec algorithm",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.prune.export_prune_model",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.prune.export_prune_model",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.prune.export_prune_model",
        "peekOfCode": "__dir__ = os.path.dirname(__file__)\nsys.path.append(__dir__)\nsys.path.append(os.path.join(__dir__, '..', '..', '..'))\nsys.path.append(os.path.join(__dir__, '..', '..', '..', 'tools'))\nimport paddle\nfrom ppocr.data import build_dataloader, set_signal_handlers\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.metrics import build_metric\nfrom ppocr.utils.save_load import load_model",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.prune.export_prune_model",
        "documentation": {}
    },
    {
        "label": "get_pruned_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "peekOfCode": "def get_pruned_params(parameters):\n    params = []\n    for param in parameters:\n        if len(\n                param.shape\n        ) == 4 and 'depthwise' not in param.name and 'transpose' not in param.name and \"conv2d_57\" not in param.name and \"conv2d_56\" not in param.name:\n            params.append(param.name)\n    return params\ndef main(config, device, logger, vdl_writer):\n    # init dist environment",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "peekOfCode": "def main(config, device, logger, vdl_writer):\n    # init dist environment\n    if config['Global']['distributed']:\n        dist.init_parallel_env()\n    global_config = config['Global']\n    # build dataloader\n    set_signal_handlers()\n    train_dataloader = build_dataloader(config, 'Train', device, logger)\n    if config['Eval']:\n        valid_dataloader = build_dataloader(config, 'Eval', device, logger)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "peekOfCode": "__dir__ = os.path.dirname(__file__)\nsys.path.append(__dir__)\nsys.path.append(os.path.join(__dir__, '..', '..', '..'))\nsys.path.append(os.path.join(__dir__, '..', '..', '..', 'tools'))\nimport paddle\nimport paddle.distributed as dist\nfrom ppocr.data import build_dataloader, set_signal_handlers\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.losses import build_loss\nfrom ppocr.optimizer import build_optimizer",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.prune.sensitivity_anal",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.export_model",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.export_model",
        "peekOfCode": "def main():\n    ############################################################################################################\n    # 1. quantization configs\n    ############################################################################################################\n    quant_config = {\n        # weight preprocess type, default is None and no preprocessing is performed. \n        'weight_preprocess_type': None,\n        # activation preprocess type, default is None and no preprocessing is performed.\n        'activation_preprocess_type': None,\n        # weight quantize type, default is 'channel_wise_abs_max'",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.export_model",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.export_model",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.export_model",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..', '..', '..')))\nsys.path.insert(\n    0, os.path.abspath(os.path.join(__dir__, '..', '..', '..', 'tools')))\nimport argparse\nimport paddle\nfrom paddle.jit import to_static\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.export_model",
        "documentation": {}
    },
    {
        "label": "PACT",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "peekOfCode": "class PACT(paddle.nn.Layer):\n    def __init__(self):\n        super(PACT, self).__init__()\n        alpha_attr = paddle.ParamAttr(\n            name=self.full_name() + \".pact\",\n            initializer=paddle.nn.initializer.Constant(value=20),\n            learning_rate=1.0,\n            regularizer=paddle.regularizer.L2Decay(2e-5))\n        self.alpha = self.create_parameter(\n            shape=[1], attr=alpha_attr, dtype='float32')",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "peekOfCode": "def main(config, device, logger, vdl_writer):\n    # init dist environment\n    if config['Global']['distributed']:\n        dist.init_parallel_env()\n    global_config = config['Global']\n    # build dataloader\n    set_signal_handlers()\n    train_dataloader = build_dataloader(config, 'Train', device, logger)\n    if config['Eval']:\n        valid_dataloader = build_dataloader(config, 'Eval', device, logger)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.append(os.path.abspath(os.path.join(__dir__, '..', '..', '..')))\nsys.path.append(\n    os.path.abspath(os.path.join(__dir__, '..', '..', '..', 'tools')))\nimport yaml\nimport paddle\nimport paddle.distributed as dist\npaddle.seed(2)\nfrom ppocr.data import build_dataloader, set_signal_handlers",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "documentation": {}
    },
    {
        "label": "quant_config",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "peekOfCode": "quant_config = {\n    # weight preprocess type, default is None and no preprocessing is performed. \n    'weight_preprocess_type': None,\n    # activation preprocess type, default is None and no preprocessing is performed.\n    'activation_preprocess_type': None,\n    # weight quantize type, default is 'channel_wise_abs_max'\n    'weight_quantize_type': 'channel_wise_abs_max',\n    # activation quantize type, default is 'moving_average_abs_max'\n    'activation_quantize_type': 'moving_average_abs_max',\n    # weight quantize bit num, default is 8",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant",
        "documentation": {}
    },
    {
        "label": "PACT",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "peekOfCode": "class PACT(paddle.nn.Layer):\n    def __init__(self):\n        super(PACT, self).__init__()\n        alpha_attr = paddle.ParamAttr(\n            name=self.full_name() + \".pact\",\n            initializer=paddle.nn.initializer.Constant(value=20),\n            learning_rate=1.0,\n            regularizer=paddle.regularizer.L2Decay(2e-5))\n        self.alpha = self.create_parameter(\n            shape=[1], attr=alpha_attr, dtype='float32')",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "documentation": {}
    },
    {
        "label": "sample_generator",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "peekOfCode": "def sample_generator(loader):\n    def __reader__():\n        for indx, data in enumerate(loader):\n            images = np.array(data[0])\n            yield images\n    return __reader__\ndef sample_generator_layoutxlm_ser(loader):\n    def __reader__():\n        for indx, data in enumerate(loader):\n            input_ids = np.array(data[0])",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "documentation": {}
    },
    {
        "label": "sample_generator_layoutxlm_ser",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "peekOfCode": "def sample_generator_layoutxlm_ser(loader):\n    def __reader__():\n        for indx, data in enumerate(loader):\n            input_ids = np.array(data[0])\n            bbox = np.array(data[1])\n            attention_mask = np.array(data[2])\n            token_type_ids = np.array(data[3])\n            images = np.array(data[4])\n            yield [input_ids, bbox, attention_mask, token_type_ids, images]\n    return __reader__",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "peekOfCode": "def main(config, device, logger, vdl_writer):\n    # init dist environment\n    if config['Global']['distributed']:\n        dist.init_parallel_env()\n    global_config = config['Global']\n    # build dataloader\n    set_signal_handlers()\n    config['Train']['loader']['num_workers'] = 0\n    is_layoutxlm_ser =  config['Architecture']['model_type'] =='kie' and config['Architecture']['Backbone']['name'] == 'LayoutXLMForSer'\n    train_dataloader = build_dataloader(config, 'Train', device, logger)",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.append(os.path.abspath(os.path.join(__dir__, '..', '..', '..')))\nsys.path.append(\n    os.path.abspath(os.path.join(__dir__, '..', '..', '..', 'tools')))\nimport yaml\nimport paddle\nimport paddle.distributed as dist\npaddle.seed(2)\nfrom ppocr.data import build_dataloader, set_signal_handlers",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "documentation": {}
    },
    {
        "label": "quant_config",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "description": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "peekOfCode": "quant_config = {\n    # weight preprocess type, default is None and no preprocessing is performed. \n    'weight_preprocess_type': None,\n    # activation preprocess type, default is None and no preprocessing is performed.\n    'activation_preprocess_type': None,\n    # weight quantize type, default is 'channel_wise_abs_max'\n    'weight_quantize_type': 'channel_wise_abs_max',\n    # activation quantize type, default is 'moving_average_abs_max'\n    'activation_quantize_type': 'moving_average_abs_max',\n    # weight quantize bit num, default is 8",
        "detail": "Vision.Paddle.PaddleOCR.deploy.slim.quantization.quant_kl",
        "documentation": {}
    },
    {
        "label": "tia_distort",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "peekOfCode": "def tia_distort(src, segment=4):\n    img_h, img_w = src.shape[:2]\n    cut = img_w // segment\n    thresh = cut // 3\n    src_pts = list()\n    dst_pts = list()\n    src_pts.append([0, 0])\n    src_pts.append([img_w, 0])\n    src_pts.append([img_w, img_h])\n    src_pts.append([0, img_h])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "documentation": {}
    },
    {
        "label": "tia_stretch",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "peekOfCode": "def tia_stretch(src, segment=4):\n    img_h, img_w = src.shape[:2]\n    cut = img_w // segment\n    thresh = cut * 4 // 5\n    src_pts = list()\n    dst_pts = list()\n    src_pts.append([0, 0])\n    src_pts.append([img_w, 0])\n    src_pts.append([img_w, img_h])\n    src_pts.append([0, img_h])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "documentation": {}
    },
    {
        "label": "tia_perspective",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "peekOfCode": "def tia_perspective(src):\n    img_h, img_w = src.shape[:2]\n    thresh = img_h // 2\n    src_pts = list()\n    dst_pts = list()\n    src_pts.append([0, 0])\n    src_pts.append([img_w, 0])\n    src_pts.append([img_w, img_h])\n    src_pts.append([0, img_h])\n    dst_pts.append([0, np.random.randint(thresh)])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.augment",
        "documentation": {}
    },
    {
        "label": "WarpMLS",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.warp_mls",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.warp_mls",
        "peekOfCode": "class WarpMLS:\n    def __init__(self, src, src_pts, dst_pts, dst_w, dst_h, trans_ratio=1.):\n        self.src = src\n        self.src_pts = src_pts\n        self.dst_pts = dst_pts\n        self.pt_count = len(self.dst_pts)\n        self.dst_w = dst_w\n        self.dst_h = dst_h\n        self.trans_ratio = trans_ratio\n        self.grid_size = 100",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.text_image_aug.warp_mls",
        "documentation": {}
    },
    {
        "label": "TensorizeEntitiesRelations",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_re_convert",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_re_convert",
        "peekOfCode": "class TensorizeEntitiesRelations(object):\n    def __init__(self, max_seq_len=512, infer_mode=False, **kwargs):\n        self.max_seq_len = max_seq_len\n        self.infer_mode = infer_mode\n    def __call__(self, data):\n        entities = data['entities']\n        relations = data['relations']\n        entities_new = np.full(\n            shape=[self.max_seq_len + 1, 3], fill_value=-1, dtype='int64')\n        entities_new[0, 0] = len(entities['start'])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_re_convert",
        "documentation": {}
    },
    {
        "label": "VQASerTokenChunk",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_chunk",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_chunk",
        "peekOfCode": "class VQASerTokenChunk(object):\n    def __init__(self, max_seq_len=512, infer_mode=False, **kwargs):\n        self.max_seq_len = max_seq_len\n        self.infer_mode = infer_mode\n    def __call__(self, data):\n        encoded_inputs_all = []\n        seq_len = len(data['input_ids'])\n        for index in range(0, seq_len, self.max_seq_len):\n            chunk_beg = index\n            chunk_end = min(index + self.max_seq_len, seq_len)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_chunk",
        "documentation": {}
    },
    {
        "label": "VQAReTokenChunk",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_chunk",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_chunk",
        "peekOfCode": "class VQAReTokenChunk(object):\n    def __init__(self,\n                 max_seq_len=512,\n                 entities_labels=None,\n                 infer_mode=False,\n                 **kwargs):\n        self.max_seq_len = max_seq_len\n        self.entities_labels = {\n            'HEADER': 0,\n            'QUESTION': 1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_chunk",
        "documentation": {}
    },
    {
        "label": "VQATokenPad",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_pad",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_pad",
        "peekOfCode": "class VQATokenPad(object):\n    def __init__(self,\n                 max_seq_len=512,\n                 pad_to_max_seq_len=True,\n                 return_attention_mask=True,\n                 return_token_type_ids=True,\n                 truncation_strategy=\"longest_first\",\n                 return_overflowing_tokens=False,\n                 return_special_tokens_mask=False,\n                 infer_mode=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_pad",
        "documentation": {}
    },
    {
        "label": "VQAReTokenRelation",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_relation",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_relation",
        "peekOfCode": "class VQAReTokenRelation(object):\n    def __init__(self, **kwargs):\n        pass\n    def __call__(self, data):\n        \"\"\"\n        build relations\n        \"\"\"\n        entities = data['entities']\n        relations = data['relations']\n        id2label = data.pop('id2label')",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.token.vqa_token_relation",
        "documentation": {}
    },
    {
        "label": "order_by_tbyx",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.augment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.augment",
        "peekOfCode": "def order_by_tbyx(ocr_info):\n    res = sorted(ocr_info, key=lambda r: (r[\"bbox\"][1], r[\"bbox\"][0]))\n    for i in range(len(res) - 1):\n        for j in range(i, 0, -1):\n            if abs(res[j + 1][\"bbox\"][1] - res[j][\"bbox\"][1]) < 20 and \\\n                    (res[j + 1][\"bbox\"][0] < res[j][\"bbox\"][0]):\n                tmp = deepcopy(res[j])\n                res[j] = deepcopy(res[j + 1])\n                res[j + 1] = deepcopy(tmp)\n            else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.vqa.augment",
        "documentation": {}
    },
    {
        "label": "CVRandomRotation",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVRandomRotation(object):\n    def __init__(self, degrees=15):\n        assert isinstance(degrees,\n                          numbers.Number), \"degree should be a single number.\"\n        assert degrees >= 0, \"degree must be positive.\"\n        self.degrees = degrees\n    @staticmethod\n    def get_params(degrees):\n        return sample_sym(degrees)\n    def __call__(self, img):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVRandomAffine",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVRandomAffine(object):\n    def __init__(self, degrees, translate=None, scale=None, shear=None):\n        assert isinstance(degrees,\n                          numbers.Number), \"degree should be a single number.\"\n        assert degrees >= 0, \"degree must be positive.\"\n        self.degrees = degrees\n        if translate is not None:\n            assert isinstance(translate, (tuple, list)) and len(translate) == 2, \\\n                \"translate should be a list or tuple and it must be of length 2.\"\n            for t in translate:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVRandomPerspective",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVRandomPerspective(object):\n    def __init__(self, distortion=0.5):\n        self.distortion = distortion\n    def get_params(self, width, height, distortion):\n        offset_h = sample_asym(\n            distortion * height / 2, size=4).astype(dtype=np.int32)\n        offset_w = sample_asym(\n            distortion * width / 2, size=4).astype(dtype=np.int32)\n        topleft = (offset_w[0], offset_h[0])\n        topright = (width - 1 - offset_w[1], offset_h[1])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVRescale",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVRescale(object):\n    def __init__(self, factor=4, base_size=(128, 512)):\n        \"\"\" Define image scales using gaussian pyramid and rescale image to target scale.\n        Args:\n            factor: the decayed factor from base size, factor=4 keeps target scale by default.\n            base_size: base size the build the bottom layer of pyramid\n        \"\"\"\n        if isinstance(factor, numbers.Number):\n            self.factor = round(sample_uniform(0, factor))\n        elif isinstance(factor, (tuple, list)) and len(factor) == 2:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVGaussianNoise",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVGaussianNoise(object):\n    def __init__(self, mean=0, var=20):\n        self.mean = mean\n        if isinstance(var, numbers.Number):\n            self.var = max(int(sample_asym(var)), 1)\n        elif isinstance(var, (tuple, list)) and len(var) == 2:\n            self.var = int(sample_uniform(var[0], var[1]))\n        else:\n            raise Exception('degree must be number or list with length 2')\n    def __call__(self, img):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVMotionBlur",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVMotionBlur(object):\n    def __init__(self, degrees=12, angle=90):\n        if isinstance(degrees, numbers.Number):\n            self.degree = max(int(sample_asym(degrees)), 1)\n        elif isinstance(degrees, (tuple, list)) and len(degrees) == 2:\n            self.degree = int(sample_uniform(degrees[0], degrees[1]))\n        else:\n            raise Exception('degree must be number or list with length 2')\n        self.angle = sample_uniform(-angle, angle)\n    def __call__(self, img):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVGeometry",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVGeometry(object):\n    def __init__(self,\n                 degrees=15,\n                 translate=(0.3, 0.3),\n                 scale=(0.5, 2.),\n                 shear=(45, 15),\n                 distortion=0.5,\n                 p=0.5):\n        self.p = p\n        type_p = random.random()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVDeterioration",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVDeterioration(object):\n    def __init__(self, var, degrees, factor, p=0.5):\n        self.p = p\n        transforms = []\n        if var is not None:\n            transforms.append(CVGaussianNoise(var=var))\n        if degrees is not None:\n            transforms.append(CVMotionBlur(degrees=degrees))\n        if factor is not None:\n            transforms.append(CVRescale(factor=factor))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "CVColorJitter",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class CVColorJitter(object):\n    def __init__(self,\n                 brightness=0.5,\n                 contrast=0.5,\n                 saturation=0.5,\n                 hue=0.1,\n                 p=0.5):\n        self.p = p\n        self.transforms = ColorJitter(\n            brightness=brightness,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "SVTRDeterioration",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class SVTRDeterioration(object):\n    def __init__(self, var, degrees, factor, p=0.5):\n        self.p = p\n        transforms = []\n        if var is not None:\n            transforms.append(CVGaussianNoise(var=var))\n        if degrees is not None:\n            transforms.append(CVMotionBlur(degrees=degrees))\n        if factor is not None:\n            transforms.append(CVRescale(factor=factor))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "SVTRGeometry",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "class SVTRGeometry(object):\n    def __init__(self,\n                 aug_type=0,\n                 degrees=15,\n                 translate=(0.3, 0.3),\n                 scale=(0.5, 2.),\n                 shear=(45, 15),\n                 distortion=0.5,\n                 p=0.5):\n        self.aug_type = aug_type",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "sample_asym",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "def sample_asym(magnitude, size=None):\n    return np.random.beta(1, 4, size) * magnitude\ndef sample_sym(magnitude, size=None):\n    return (np.random.beta(4, 4, size=size) - 0.5) * 2 * magnitude\ndef sample_uniform(low, high, size=None):\n    return np.random.uniform(low, high, size=size)\ndef get_interpolation(type='random'):\n    if type == 'random':\n        choice = [\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "sample_sym",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "def sample_sym(magnitude, size=None):\n    return (np.random.beta(4, 4, size=size) - 0.5) * 2 * magnitude\ndef sample_uniform(low, high, size=None):\n    return np.random.uniform(low, high, size=size)\ndef get_interpolation(type='random'):\n    if type == 'random':\n        choice = [\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA\n        ]\n        interpolation = choice[random.randint(0, len(choice) - 1)]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "sample_uniform",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "def sample_uniform(low, high, size=None):\n    return np.random.uniform(low, high, size=size)\ndef get_interpolation(type='random'):\n    if type == 'random':\n        choice = [\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA\n        ]\n        interpolation = choice[random.randint(0, len(choice) - 1)]\n    elif type == 'nearest':\n        interpolation = cv2.INTER_NEAREST",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "get_interpolation",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "peekOfCode": "def get_interpolation(type='random'):\n    if type == 'random':\n        choice = [\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA\n        ]\n        interpolation = choice[random.randint(0, len(choice) - 1)]\n    elif type == 'nearest':\n        interpolation = cv2.INTER_NEAREST\n    elif type == 'linear':\n        interpolation = cv2.INTER_LINEAR",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.abinet_aug",
        "documentation": {}
    },
    {
        "label": "ColorJitter",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ColorJitter",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ColorJitter",
        "peekOfCode": "class ColorJitter(object):\n    def __init__(self, brightness=0, contrast=0, saturation=0, hue=0,**kwargs):\n        self.aug = pp_ColorJitter(brightness, contrast, saturation, hue)\n    def __call__(self, data):\n        image = data['image']\n        image = self.aug(image)\n        data['image'] = image\n        return data",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ColorJitter",
        "documentation": {}
    },
    {
        "label": "CopyPaste",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "peekOfCode": "class CopyPaste(object):\n    def __init__(self, objects_paste_ratio=0.2, limit_paste=True, **kwargs):\n        self.ext_data_num = 1\n        self.objects_paste_ratio = objects_paste_ratio\n        self.limit_paste = limit_paste\n        augmenter_args = [{'type': 'Resize', 'args': {'size': [0.5, 3]}}]\n        self.aug = IaaAugment(augmenter_args)\n    def __call__(self, data):\n        point_num = data['polys'].shape[1]\n        src_img = data['image']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "documentation": {}
    },
    {
        "label": "get_union",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "peekOfCode": "def get_union(pD, pG):\n    return Polygon(pD).union(Polygon(pG)).area\ndef get_intersection_over_union(pD, pG):\n    return get_intersection(pD, pG) / get_union(pD, pG)\ndef get_intersection(pD, pG):\n    return Polygon(pD).intersection(Polygon(pG)).area\ndef rotate_bbox(img, text_polys, angle, scale=1):\n    \"\"\"\n    from https://github.com/WenmuZhou/DBNet.pytorch/blob/master/data_loader/modules/augment.py\n    Args:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "documentation": {}
    },
    {
        "label": "get_intersection_over_union",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "peekOfCode": "def get_intersection_over_union(pD, pG):\n    return get_intersection(pD, pG) / get_union(pD, pG)\ndef get_intersection(pD, pG):\n    return Polygon(pD).intersection(Polygon(pG)).area\ndef rotate_bbox(img, text_polys, angle, scale=1):\n    \"\"\"\n    from https://github.com/WenmuZhou/DBNet.pytorch/blob/master/data_loader/modules/augment.py\n    Args:\n        img: np.ndarray\n        text_polys: np.ndarray N*4*2",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "documentation": {}
    },
    {
        "label": "get_intersection",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "peekOfCode": "def get_intersection(pD, pG):\n    return Polygon(pD).intersection(Polygon(pG)).area\ndef rotate_bbox(img, text_polys, angle, scale=1):\n    \"\"\"\n    from https://github.com/WenmuZhou/DBNet.pytorch/blob/master/data_loader/modules/augment.py\n    Args:\n        img: np.ndarray\n        text_polys: np.ndarray N*4*2\n        angle: int\n        scale: int",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "documentation": {}
    },
    {
        "label": "rotate_bbox",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "peekOfCode": "def rotate_bbox(img, text_polys, angle, scale=1):\n    \"\"\"\n    from https://github.com/WenmuZhou/DBNet.pytorch/blob/master/data_loader/modules/augment.py\n    Args:\n        img: np.ndarray\n        text_polys: np.ndarray N*4*2\n        angle: int\n        scale: int\n    Returns:\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.copy_paste",
        "documentation": {}
    },
    {
        "label": "RandomScale",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "peekOfCode": "class RandomScale():\n    def __init__(self, short_size=640, **kwargs):\n        self.short_size = short_size\n    def scale_aligned(self, img, scale):\n        oh, ow = img.shape[0:2]\n        h = int(oh * scale + 0.5)\n        w = int(ow * scale + 0.5)\n        if h % 32 != 0:\n            h = h + (32 - h % 32)\n        if w % 32 != 0:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "documentation": {}
    },
    {
        "label": "MakeShrink",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "peekOfCode": "class MakeShrink():\n    def __init__(self, kernel_scale=0.7, **kwargs):\n        self.kernel_scale = kernel_scale\n    def dist(self, a, b):\n        return np.linalg.norm((a - b), ord=2, axis=0)\n    def perimeter(self, bbox):\n        peri = 0.0\n        for i in range(bbox.shape[0]):\n            peri += self.dist(bbox[i], bbox[(i + 1) % bbox.shape[0]])\n        return peri",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "documentation": {}
    },
    {
        "label": "GroupRandomHorizontalFlip",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "peekOfCode": "class GroupRandomHorizontalFlip():\n    def __init__(self, p=0.5, **kwargs):\n        self.p = p\n    def __call__(self, data):\n        imgs = data['image']\n        if random.random() < self.p:\n            for i in range(len(imgs)):\n                imgs[i] = np.flip(imgs[i], axis=1).copy()\n        data['image'] = imgs\n        return data",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "documentation": {}
    },
    {
        "label": "GroupRandomRotate",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "peekOfCode": "class GroupRandomRotate():\n    def __init__(self, **kwargs):\n        pass\n    def __call__(self, data):\n        imgs = data['image']\n        max_angle = 10\n        angle = random.random() * 2 * max_angle - max_angle\n        for i in range(len(imgs)):\n            img = imgs[i]\n            w, h = img.shape[:2]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "documentation": {}
    },
    {
        "label": "GroupRandomCropPadding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "peekOfCode": "class GroupRandomCropPadding():\n    def __init__(self, target_size=(640, 640), **kwargs):\n        self.target_size = target_size\n    def __call__(self, data):\n        imgs = data['image']\n        h, w = imgs[0].shape[0:2]\n        t_w, t_h = self.target_size\n        p_w, p_h = self.target_size\n        if w == t_w and h == t_h:\n            return data",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "documentation": {}
    },
    {
        "label": "MakeCentripetalShift",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "peekOfCode": "class MakeCentripetalShift():\n    def __init__(self, **kwargs):\n        pass\n    def jaccard(self, As, Bs):\n        A = As.shape[0]  # small\n        B = Bs.shape[0]  # large\n        dis = np.sqrt(\n            np.sum((As[:, np.newaxis, :].repeat(\n                B, axis=1) - Bs[np.newaxis, :, :].repeat(\n                    A, axis=0))**2,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "documentation": {}
    },
    {
        "label": "ScaleAlignedShort",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "peekOfCode": "class ScaleAlignedShort():\n    def __init__(self, short_size=640, **kwargs):\n        self.short_size = short_size\n    def __call__(self, data):\n        img = data['image']\n        org_img_shape = img.shape\n        h, w = img.shape[0:2]\n        scale = self.short_size * 1.0 / min(h, w)\n        h = int(h * scale + 0.5)\n        w = int(w * scale + 0.5)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ct_process",
        "documentation": {}
    },
    {
        "label": "DRRGTargets",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.drrg_targets",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.drrg_targets",
        "peekOfCode": "class DRRGTargets(object):\n    def __init__(self,\n                 orientation_thr=2.0,\n                 resample_step=8.0,\n                 num_min_comps=9,\n                 num_max_comps=600,\n                 min_width=8.0,\n                 max_width=24.0,\n                 center_region_shrink_ratio=0.3,\n                 comp_shrink_ratio=1.0,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.drrg_targets",
        "documentation": {}
    },
    {
        "label": "EASTProcessTrain",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.east_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.east_process",
        "peekOfCode": "class EASTProcessTrain(object):\n    def __init__(self,\n                 image_shape=[512, 512],\n                 background_ratio=0.125,\n                 min_crop_side_ratio=0.1,\n                 min_text_size=10,\n                 **kwargs):\n        self.input_size = image_shape[1]\n        self.random_scale = np.array([0.5, 1, 2.0, 3.0])\n        self.background_ratio = background_ratio",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.east_process",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.east_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.east_process",
        "peekOfCode": "__all__ = ['EASTProcessTrain']\nclass EASTProcessTrain(object):\n    def __init__(self,\n                 image_shape=[512, 512],\n                 background_ratio=0.125,\n                 min_crop_side_ratio=0.1,\n                 min_text_size=10,\n                 **kwargs):\n        self.input_size = image_shape[1]\n        self.random_scale = np.array([0.5, 1, 2.0, 3.0])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.east_process",
        "documentation": {}
    },
    {
        "label": "RandomScaling",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "peekOfCode": "class RandomScaling:\n    def __init__(self, size=800, scale=(3. / 4, 5. / 2), **kwargs):\n        \"\"\"Random scale the image while keeping aspect.\n        Args:\n            size (int) : Base size before scaling.\n            scale (tuple(float)) : The range of scaling.\n        \"\"\"\n        assert isinstance(size, int)\n        assert isinstance(scale, float) or isinstance(scale, tuple)\n        self.size = size",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "documentation": {}
    },
    {
        "label": "RandomCropFlip",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "peekOfCode": "class RandomCropFlip:\n    def __init__(self,\n                 pad_ratio=0.1,\n                 crop_ratio=0.5,\n                 iter_num=1,\n                 min_area_ratio=0.2,\n                 **kwargs):\n        \"\"\"Random crop and flip a patch of the image.\n        Args:\n            crop_ratio (float): The ratio of cropping.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "documentation": {}
    },
    {
        "label": "RandomCropPolyInstances",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "peekOfCode": "class RandomCropPolyInstances:\n    \"\"\"Randomly crop images and make sure to contain at least one intact\n    instance.\"\"\"\n    def __init__(self, crop_ratio=5.0 / 8.0, min_side_ratio=0.4, **kwargs):\n        super().__init__()\n        self.crop_ratio = crop_ratio\n        self.min_side_ratio = min_side_ratio\n    def sample_valid_start_end(self, valid_array, min_len, max_start, min_end):\n        assert isinstance(min_len, int)\n        assert len(valid_array) > min_len",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "documentation": {}
    },
    {
        "label": "RandomRotatePolyInstances",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "peekOfCode": "class RandomRotatePolyInstances:\n    def __init__(self,\n                 rotate_ratio=0.5,\n                 max_angle=10,\n                 pad_with_fixed_color=False,\n                 pad_value=(0, 0, 0),\n                 **kwargs):\n        \"\"\"Randomly rotate images and polygon masks.\n        Args:\n            rotate_ratio (float): The ratio of samples to operate rotation.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "documentation": {}
    },
    {
        "label": "SquareResizePad",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "peekOfCode": "class SquareResizePad:\n    def __init__(self,\n                 target_size,\n                 pad_ratio=0.6,\n                 pad_with_fixed_color=False,\n                 pad_value=(0, 0, 0),\n                 **kwargs):\n        \"\"\"Resize or pad images to be square shape.\n        Args:\n            target_size (int): The target size of square shaped image.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_aug",
        "documentation": {}
    },
    {
        "label": "FCENetTargets",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_targets",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_targets",
        "peekOfCode": "class FCENetTargets:\n    \"\"\"Generate the ground truth targets of FCENet: Fourier Contour Embedding\n    for Arbitrary-Shaped Text Detection.\n    [https://arxiv.org/abs/2104.10442]\n    Args:\n        fourier_degree (int): The maximum Fourier transform degree k.\n        resample_step (float): The step size for resampling the text center\n            line (TCL). It's better not to exceed half of the minimum width.\n        center_region_shrink_ratio (float): The shrink ratio of text center\n            region.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_targets",
        "documentation": {}
    },
    {
        "label": "vector_slope",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_targets",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_targets",
        "peekOfCode": "def vector_slope(vec):\n    assert len(vec) == 2\n    return abs(vec[1] / (vec[0] + 1e-8))\nclass FCENetTargets:\n    \"\"\"Generate the ground truth targets of FCENet: Fourier Contour Embedding\n    for Arbitrary-Shaped Text Detection.\n    [https://arxiv.org/abs/2104.10442]\n    Args:\n        fourier_degree (int): The maximum Fourier transform degree k.\n        resample_step (float): The step size for resampling the text center",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.fce_targets",
        "documentation": {}
    },
    {
        "label": "AugmenterBuilder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.iaa_augment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.iaa_augment",
        "peekOfCode": "class AugmenterBuilder(object):\n    def __init__(self):\n        pass\n    def build(self, args, root=True):\n        if args is None or len(args) == 0:\n            return None\n        elif isinstance(args, list):\n            if root:\n                sequence = [self.build(value, root=False) for value in args]\n                return iaa.Sequential(sequence)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.iaa_augment",
        "documentation": {}
    },
    {
        "label": "IaaAugment",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.iaa_augment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.iaa_augment",
        "peekOfCode": "class IaaAugment():\n    def __init__(self, augmenter_args=None, **kwargs):\n        if augmenter_args is None:\n            augmenter_args = [{\n                'type': 'Fliplr',\n                'args': {\n                    'p': 0.5\n                }\n            }, {\n                'type': 'Affine',",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.iaa_augment",
        "documentation": {}
    },
    {
        "label": "ClsLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class ClsLabelEncode(object):\n    def __init__(self, label_list, **kwargs):\n        self.label_list = label_list\n    def __call__(self, data):\n        label = data['label']\n        if label not in self.label_list:\n            return None\n        label = self.label_list.index(label)\n        data['label'] = label\n        return data",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "DetLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class DetLabelEncode(object):\n    def __init__(self, **kwargs):\n        pass\n    def __call__(self, data):\n        label = data['label']\n        label = json.loads(label)\n        nBox = len(label)\n        boxes, txts, txt_tags = [], [], []\n        for bno in range(0, nBox):\n            box = label[bno]['points']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "BaseRecLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class BaseRecLabelEncode(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 lower=False):\n        self.max_text_len = max_text_length\n        self.beg_str = \"sos\"\n        self.end_str = \"eos\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "CTCLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class CTCLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(CTCLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def __call__(self, data):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "E2ELabelEncodeTest",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class E2ELabelEncodeTest(BaseRecLabelEncode):\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(E2ELabelEncodeTest, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def __call__(self, data):\n        import json",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "E2ELabelEncodeTrain",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class E2ELabelEncodeTrain(object):\n    def __init__(self, **kwargs):\n        pass\n    def __call__(self, data):\n        import json\n        label = data['label']\n        label = json.loads(label)\n        nBox = len(label)\n        boxes, txts, txt_tags = [], [], []\n        for bno in range(0, nBox):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "KieLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class KieLabelEncode(object):\n    def __init__(self,\n                 character_dict_path,\n                 class_path,\n                 norm=10,\n                 directed=False,\n                 **kwargs):\n        super(KieLabelEncode, self).__init__()\n        self.dict = dict({'': 0})\n        self.label2classid_map = dict()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "AttnLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class AttnLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(AttnLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def add_special_char(self, dict_character):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "RFLLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class RFLLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(RFLLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def add_special_char(self, dict_character):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "SEEDLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class SEEDLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(SEEDLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def add_special_char(self, dict_character):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "SRNLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class SRNLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length=25,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(SRNLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def add_special_char(self, dict_character):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "TableLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class TableLabelEncode(AttnLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path,\n                 replace_empty_cell_token=False,\n                 merge_no_span_structure=False,\n                 learn_empty_box=False,\n                 loc_reg_num=4,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "TableMasterLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class TableMasterLabelEncode(TableLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path,\n                 replace_empty_cell_token=False,\n                 merge_no_span_structure=False,\n                 learn_empty_box=False,\n                 loc_reg_num=4,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "TableBoxEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class TableBoxEncode(object):\n    def __init__(self, in_box_format='xyxy', out_box_format='xyxy', **kwargs):\n        assert out_box_format in ['xywh', 'xyxy', 'xyxyxyxy']\n        self.in_box_format = in_box_format\n        self.out_box_format = out_box_format\n    def __call__(self, data):\n        img_height, img_width = data['image'].shape[:2]\n        bboxes = data['bboxes']\n        if self.in_box_format != self.out_box_format:\n            if self.out_box_format == 'xywh':",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "SARLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class SARLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(SARLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def add_special_char(self, dict_character):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "SATRNLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class SATRNLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 lower=False,\n                 **kwargs):\n        super(SATRNLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "PRENLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class PRENLabelEncode(BaseRecLabelEncode):\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path,\n                 use_space_char=False,\n                 **kwargs):\n        super(PRENLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def add_special_char(self, dict_character):\n        padding_str = '<PAD>'  # 0 ",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "VQATokenLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class VQATokenLabelEncode(object):\n    \"\"\"\n    Label encode for NLP VQA methods\n    \"\"\"\n    def __init__(self,\n                 class_path,\n                 contains_re=False,\n                 add_special_ids=False,\n                 algorithm='LayoutXLM',\n                 use_textline_bbox_info=True,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "MultiLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class MultiLabelEncode(BaseRecLabelEncode):\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 gtc_encode=None,\n                 **kwargs):\n        super(MultiLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n        self.ctc_encode = CTCLabelEncode(max_text_length, character_dict_path,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "NRTRLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class NRTRLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(NRTRLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)\n    def __call__(self, data):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "ViTSTRLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class ViTSTRLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 ignore_index=0,\n                 **kwargs):\n        super(ViTSTRLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "ABINetLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class ABINetLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 ignore_index=100,\n                 **kwargs):\n        super(ABINetLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "SRLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class SRLabelEncode(BaseRecLabelEncode):\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(SRLabelEncode, self).__init__(max_text_length,\n                                            character_dict_path, use_space_char)\n        self.dic = {}\n        with open(character_dict_path, 'r') as fin:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "SPINLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class SPINLabelEncode(AttnLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 lower=True,\n                 **kwargs):\n        super(SPINLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "VLLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class VLLabelEncode(BaseRecLabelEncode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self,\n                 max_text_length,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 **kwargs):\n        super(VLLabelEncode, self).__init__(max_text_length,\n                                            character_dict_path, use_space_char)\n        self.dict = {}",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "CTLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class CTLabelEncode(object):\n    def __init__(self, **kwargs):\n        pass\n    def __call__(self, data):\n        label = data['label']\n        label = json.loads(label)\n        nBox = len(label)\n        boxes, txts = [], []\n        for bno in range(0, nBox):\n            box = label[bno]['points']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "CANLabelEncode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "peekOfCode": "class CANLabelEncode(BaseRecLabelEncode):\n    def __init__(self,\n                 character_dict_path,\n                 max_text_length=100,\n                 use_space_char=False,\n                 lower=True,\n                 **kwargs):\n        super(CANLabelEncode, self).__init__(\n            max_text_length, character_dict_path, use_space_char, lower)\n    def encode(self, text_seq):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.label_ops",
        "documentation": {}
    },
    {
        "label": "MakeBorderMap",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_border_map",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_border_map",
        "peekOfCode": "class MakeBorderMap(object):\n    def __init__(self,\n                 shrink_ratio=0.4,\n                 thresh_min=0.3,\n                 thresh_max=0.7,\n                 **kwargs):\n        self.shrink_ratio = shrink_ratio\n        self.thresh_min = thresh_min\n        self.thresh_max = thresh_max\n        if 'total_epoch' in kwargs and 'epoch' in kwargs and kwargs[",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_border_map",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_border_map",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_border_map",
        "peekOfCode": "__all__ = ['MakeBorderMap']\nclass MakeBorderMap(object):\n    def __init__(self,\n                 shrink_ratio=0.4,\n                 thresh_min=0.3,\n                 thresh_max=0.7,\n                 **kwargs):\n        self.shrink_ratio = shrink_ratio\n        self.thresh_min = thresh_min\n        self.thresh_max = thresh_max",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_border_map",
        "documentation": {}
    },
    {
        "label": "MakePseGt",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_pse_gt",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_pse_gt",
        "peekOfCode": "class MakePseGt(object):\n    def __init__(self, kernel_num=7, size=640, min_shrink_ratio=0.4, **kwargs):\n        self.kernel_num = kernel_num\n        self.min_shrink_ratio = min_shrink_ratio\n        self.size = size\n    def __call__(self, data):\n        image = data['image']\n        text_polys = data['polys']\n        ignore_tags = data['ignore_tags']\n        h, w, _ = image.shape",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_pse_gt",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_pse_gt",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_pse_gt",
        "peekOfCode": "__all__ = ['MakePseGt']\nclass MakePseGt(object):\n    def __init__(self, kernel_num=7, size=640, min_shrink_ratio=0.4, **kwargs):\n        self.kernel_num = kernel_num\n        self.min_shrink_ratio = min_shrink_ratio\n        self.size = size\n    def __call__(self, data):\n        image = data['image']\n        text_polys = data['polys']\n        ignore_tags = data['ignore_tags']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_pse_gt",
        "documentation": {}
    },
    {
        "label": "MakeShrinkMap",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_shrink_map",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_shrink_map",
        "peekOfCode": "class MakeShrinkMap(object):\n    r'''\n    Making binary mask from detection data with ICDAR format.\n    Typically following the process of class `MakeICDARData`.\n    '''\n    def __init__(self, min_text_size=8, shrink_ratio=0.4, **kwargs):\n        self.min_text_size = min_text_size\n        self.shrink_ratio = shrink_ratio\n        if 'total_epoch' in kwargs and 'epoch' in kwargs and kwargs[\n                'epoch'] != \"None\":",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_shrink_map",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_shrink_map",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_shrink_map",
        "peekOfCode": "__all__ = ['MakeShrinkMap']\nclass MakeShrinkMap(object):\n    r'''\n    Making binary mask from detection data with ICDAR format.\n    Typically following the process of class `MakeICDARData`.\n    '''\n    def __init__(self, min_text_size=8, shrink_ratio=0.4, **kwargs):\n        self.min_text_size = min_text_size\n        self.shrink_ratio = shrink_ratio\n        if 'total_epoch' in kwargs and 'epoch' in kwargs and kwargs[",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.make_shrink_map",
        "documentation": {}
    },
    {
        "label": "DecodeImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class DecodeImage(object):\n    \"\"\" decode image \"\"\"\n    def __init__(self,\n                 img_mode='RGB',\n                 channel_first=False,\n                 ignore_orientation=False,\n                 **kwargs):\n        self.img_mode = img_mode\n        self.channel_first = channel_first\n        self.ignore_orientation = ignore_orientation",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "NormalizeImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class NormalizeImage(object):\n    \"\"\" normalize image such as substract mean, divide std\n    \"\"\"\n    def __init__(self, scale=None, mean=None, std=None, order='chw', **kwargs):\n        if isinstance(scale, str):\n            scale = eval(scale)\n        self.scale = np.float32(scale if scale is not None else 1.0 / 255.0)\n        mean = mean if mean is not None else [0.485, 0.456, 0.406]\n        std = std if std is not None else [0.229, 0.224, 0.225]\n        shape = (3, 1, 1) if order == 'chw' else (1, 1, 3)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "ToCHWImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class ToCHWImage(object):\n    \"\"\" convert hwc image to chw image\n    \"\"\"\n    def __init__(self, **kwargs):\n        pass\n    def __call__(self, data):\n        img = data['image']\n        from PIL import Image\n        if isinstance(img, Image.Image):\n            img = np.array(img)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "Fasttext",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class Fasttext(object):\n    def __init__(self, path=\"None\", **kwargs):\n        import fasttext\n        self.fast_model = fasttext.load_model(path)\n    def __call__(self, data):\n        label = data['label']\n        fast_label = self.fast_model[label]\n        data['fast_label'] = fast_label\n        return data\nclass KeepKeys(object):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "KeepKeys",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class KeepKeys(object):\n    def __init__(self, keep_keys, **kwargs):\n        self.keep_keys = keep_keys\n    def __call__(self, data):\n        data_list = []\n        for key in self.keep_keys:\n            data_list.append(data[key])\n        return data_list\nclass Pad(object):\n    def __init__(self, size=None, size_div=32, **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "Pad",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class Pad(object):\n    def __init__(self, size=None, size_div=32, **kwargs):\n        if size is not None and not isinstance(size, (int, list, tuple)):\n            raise TypeError(\"Type of target_size is invalid. Now is {}\".format(\n                type(size)))\n        if isinstance(size, int):\n            size = [size, size]\n        self.size = size\n        self.size_div = size_div\n    def __call__(self, data):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "Resize",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class Resize(object):\n    def __init__(self, size=(640, 640), **kwargs):\n        self.size = size\n    def resize_image(self, img):\n        resize_h, resize_w = self.size\n        ori_h, ori_w = img.shape[:2]  # (h, w, c)\n        ratio_h = float(resize_h) / ori_h\n        ratio_w = float(resize_w) / ori_w\n        img = cv2.resize(img, (int(resize_w), int(resize_h)))\n        return img, [ratio_h, ratio_w]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "DetResizeForTest",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class DetResizeForTest(object):\n    def __init__(self, **kwargs):\n        super(DetResizeForTest, self).__init__()\n        self.resize_type = 0\n        self.keep_ratio = False\n        if 'image_shape' in kwargs:\n            self.image_shape = kwargs['image_shape']\n            self.resize_type = 1\n            if 'keep_ratio' in kwargs:\n                self.keep_ratio = kwargs['keep_ratio']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "E2EResizeForTest",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class E2EResizeForTest(object):\n    def __init__(self, **kwargs):\n        super(E2EResizeForTest, self).__init__()\n        self.max_side_len = kwargs['max_side_len']\n        self.valid_set = kwargs['valid_set']\n    def __call__(self, data):\n        img = data['image']\n        src_h, src_w, _ = img.shape\n        if self.valid_set == 'totaltext':\n            im_resized, [ratio_h, ratio_w] = self.resize_image_for_totaltext(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "KieResize",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class KieResize(object):\n    def __init__(self, **kwargs):\n        super(KieResize, self).__init__()\n        self.max_side, self.min_side = kwargs['img_scale'][0], kwargs[\n            'img_scale'][1]\n    def __call__(self, data):\n        img = data['image']\n        points = data['points']\n        src_h, src_w, _ = img.shape\n        im_resized, scale_factor, [ratio_h, ratio_w",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "SRResize",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class SRResize(object):\n    def __init__(self,\n                 imgH=32,\n                 imgW=128,\n                 down_sample_scale=4,\n                 keep_ratio=False,\n                 min_ratio=1,\n                 mask=False,\n                 infer_mode=False,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "ResizeNormalize",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class ResizeNormalize(object):\n    def __init__(self, size, interpolation=Image.BICUBIC):\n        self.size = size\n        self.interpolation = interpolation\n    def __call__(self, img):\n        img = img.resize(self.size, self.interpolation)\n        img_numpy = np.array(img).astype(\"float32\")\n        img_numpy = img_numpy.transpose((2, 0, 1)) / 255\n        return img_numpy\nclass GrayImageChannelFormat(object):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "GrayImageChannelFormat",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "peekOfCode": "class GrayImageChannelFormat(object):\n    \"\"\"\n    format gray scale image's channel: (3,h,w) -> (1,h,w)\n    Args:\n        inverse: inverse gray image \n    \"\"\"\n    def __init__(self, inverse=False, **kwargs):\n        self.inverse = inverse\n    def __call__(self, data):\n        img = data['image']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.operators",
        "documentation": {}
    },
    {
        "label": "PGProcessTrain",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.pg_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.pg_process",
        "peekOfCode": "class PGProcessTrain(object):\n    def __init__(self,\n                 character_dict_path,\n                 max_text_length,\n                 max_text_nums,\n                 tcl_len,\n                 batch_size=14,\n                 use_resize=True,\n                 use_random_crop=False,\n                 min_crop_size=24,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.pg_process",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.pg_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.pg_process",
        "peekOfCode": "__all__ = ['PGProcessTrain']\nclass PGProcessTrain(object):\n    def __init__(self,\n                 character_dict_path,\n                 max_text_length,\n                 max_text_nums,\n                 tcl_len,\n                 batch_size=14,\n                 use_resize=True,\n                 use_random_crop=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.pg_process",
        "documentation": {}
    },
    {
        "label": "RawRandAugment",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.randaugment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.randaugment",
        "peekOfCode": "class RawRandAugment(object):\n    def __init__(self,\n                 num_layers=2,\n                 magnitude=5,\n                 fillcolor=(128, 128, 128),\n                 **kwargs):\n        self.num_layers = num_layers\n        self.magnitude = magnitude\n        self.max_level = 10\n        abso_level = self.magnitude / self.max_level",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.randaugment",
        "documentation": {}
    },
    {
        "label": "RandAugment",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.randaugment",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.randaugment",
        "peekOfCode": "class RandAugment(RawRandAugment):\n    \"\"\" RandAugment wrapper to auto fit different img types \"\"\"\n    def __init__(self, prob=0.5, *args, **kwargs):\n        self.prob = prob\n        if six.PY2:\n            super(RandAugment, self).__init__(*args, **kwargs)\n        else:\n            super().__init__(*args, **kwargs)\n    def __call__(self, data):\n        if np.random.rand() > self.prob:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.randaugment",
        "documentation": {}
    },
    {
        "label": "EastRandomCropData",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "class EastRandomCropData(object):\n    def __init__(self,\n                 size=(640, 640),\n                 max_tries=10,\n                 min_crop_side_ratio=0.1,\n                 keep_ratio=True,\n                 **kwargs):\n        self.size = size\n        self.max_tries = max_tries\n        self.min_crop_side_ratio = min_crop_side_ratio",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "RandomCropImgMask",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "class RandomCropImgMask(object):\n    def __init__(self, size, main_key, crop_keys, p=3 / 8, **kwargs):\n        self.size = size\n        self.main_key = main_key\n        self.crop_keys = crop_keys\n        self.p = p\n    def __call__(self, data):\n        image = data['image']\n        h, w = image.shape[0:2]\n        th, tw = self.size",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "is_poly_in_rect",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "def is_poly_in_rect(poly, x, y, w, h):\n    poly = np.array(poly)\n    if poly[:, 0].min() < x or poly[:, 0].max() > x + w:\n        return False\n    if poly[:, 1].min() < y or poly[:, 1].max() > y + h:\n        return False\n    return True\ndef is_poly_outside_rect(poly, x, y, w, h):\n    poly = np.array(poly)\n    if poly[:, 0].max() < x or poly[:, 0].min() > x + w:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "is_poly_outside_rect",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "def is_poly_outside_rect(poly, x, y, w, h):\n    poly = np.array(poly)\n    if poly[:, 0].max() < x or poly[:, 0].min() > x + w:\n        return True\n    if poly[:, 1].max() < y or poly[:, 1].min() > y + h:\n        return True\n    return False\ndef split_regions(axis):\n    regions = []\n    min_axis = 0",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "split_regions",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "def split_regions(axis):\n    regions = []\n    min_axis = 0\n    for i in range(1, axis.shape[0]):\n        if axis[i] != axis[i - 1] + 1:\n            region = axis[min_axis:i]\n            min_axis = i\n            regions.append(region)\n    return regions\ndef random_select(axis, max_size):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "random_select",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "def random_select(axis, max_size):\n    xx = np.random.choice(axis, size=2)\n    xmin = np.min(xx)\n    xmax = np.max(xx)\n    xmin = np.clip(xmin, 0, max_size - 1)\n    xmax = np.clip(xmax, 0, max_size - 1)\n    return xmin, xmax\ndef region_wise_random_select(regions, max_size):\n    selected_index = list(np.random.choice(len(regions), 2))\n    selected_values = []",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "region_wise_random_select",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "def region_wise_random_select(regions, max_size):\n    selected_index = list(np.random.choice(len(regions), 2))\n    selected_values = []\n    for index in selected_index:\n        axis = regions[index]\n        xx = int(np.random.choice(axis, size=1))\n        selected_values.append(xx)\n    xmin = min(selected_values)\n    xmax = max(selected_values)\n    return xmin, xmax",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "crop_area",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "peekOfCode": "def crop_area(im, text_polys, min_crop_side_ratio, max_tries):\n    h, w, _ = im.shape\n    h_array = np.zeros(h, dtype=np.int32)\n    w_array = np.zeros(w, dtype=np.int32)\n    for points in text_polys:\n        points = np.round(points, decimals=0).astype(np.int32)\n        minx = np.min(points[:, 0])\n        maxx = np.max(points[:, 0])\n        w_array[minx:maxx] = 1\n        miny = np.min(points[:, 1])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.random_crop_data",
        "documentation": {}
    },
    {
        "label": "RecAug",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class RecAug(object):\n    def __init__(self,\n                 tia_prob=0.4,\n                 crop_prob=0.4,\n                 reverse_prob=0.4,\n                 noise_prob=0.4,\n                 jitter_prob=0.4,\n                 blur_prob=0.4,\n                 hsv_aug_prob=0.4,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "BaseDataAugmentation",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class BaseDataAugmentation(object):\n    def __init__(self,\n                 crop_prob=0.4,\n                 reverse_prob=0.4,\n                 noise_prob=0.4,\n                 jitter_prob=0.4,\n                 blur_prob=0.4,\n                 hsv_aug_prob=0.4,\n                 **kwargs):\n        self.crop_prob = crop_prob",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "ABINetRecAug",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class ABINetRecAug(object):\n    def __init__(self,\n                 geometry_p=0.5,\n                 deterioration_p=0.25,\n                 colorjitter_p=0.25,\n                 **kwargs):\n        self.transforms = Compose([\n            CVGeometry(\n                degrees=45,\n                translate=(0.0, 0.0),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "RecConAug",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class RecConAug(object):\n    def __init__(self,\n                 prob=0.5,\n                 image_shape=(32, 320, 3),\n                 max_text_length=25,\n                 ext_data_num=1,\n                 **kwargs):\n        self.ext_data_num = ext_data_num\n        self.prob = prob\n        self.max_text_length = max_text_length",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "SVTRRecAug",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class SVTRRecAug(object):\n    def __init__(self,\n                 aug_type=0,\n                 geometry_p=0.5,\n                 deterioration_p=0.25,\n                 colorjitter_p=0.25,\n                 **kwargs):\n        self.transforms = Compose([\n            SVTRGeometry(\n                aug_type=aug_type,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "ClsResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class ClsResizeImg(object):\n    def __init__(self, image_shape, **kwargs):\n        self.image_shape = image_shape\n    def __call__(self, data):\n        img = data['image']\n        norm_img, _ = resize_norm_img(img, self.image_shape)\n        data['image'] = norm_img\n        return data\nclass RecResizeImg(object):\n    def __init__(self,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "RecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class RecResizeImg(object):\n    def __init__(self,\n                 image_shape,\n                 infer_mode=False,\n                 eval_mode=False,\n                 character_dict_path='./ppocr/utils/ppocr_keys_v1.txt',\n                 padding=True,\n                 **kwargs):\n        self.image_shape = image_shape\n        self.infer_mode = infer_mode",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "VLRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class VLRecResizeImg(object):\n    def __init__(self,\n                 image_shape,\n                 infer_mode=False,\n                 character_dict_path='./ppocr/utils/ppocr_keys_v1.txt',\n                 padding=True,\n                 **kwargs):\n        self.image_shape = image_shape\n        self.infer_mode = infer_mode\n        self.character_dict_path = character_dict_path",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "RFLRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class RFLRecResizeImg(object):\n    def __init__(self, image_shape, padding=True, interpolation=1, **kwargs):\n        self.image_shape = image_shape\n        self.padding = padding\n        self.interpolation = interpolation\n        if self.interpolation == 0:\n            self.interpolation = cv2.INTER_NEAREST\n        elif self.interpolation == 1:\n            self.interpolation = cv2.INTER_LINEAR\n        elif self.interpolation == 2:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "SRNRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class SRNRecResizeImg(object):\n    def __init__(self, image_shape, num_heads, max_text_length, **kwargs):\n        self.image_shape = image_shape\n        self.num_heads = num_heads\n        self.max_text_length = max_text_length\n    def __call__(self, data):\n        img = data['image']\n        norm_img = resize_norm_img_srn(img, self.image_shape)\n        data['image'] = norm_img\n        [encoder_word_pos, gsrm_word_pos, gsrm_slf_attn_bias1, gsrm_slf_attn_bias2] = \\",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "SARRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class SARRecResizeImg(object):\n    def __init__(self, image_shape, width_downsample_ratio=0.25, **kwargs):\n        self.image_shape = image_shape\n        self.width_downsample_ratio = width_downsample_ratio\n    def __call__(self, data):\n        img = data['image']\n        norm_img, resize_shape, pad_shape, valid_ratio = resize_norm_img_sar(\n            img, self.image_shape, self.width_downsample_ratio)\n        data['image'] = norm_img\n        data['resized_shape'] = resize_shape",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "PRENResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class PRENResizeImg(object):\n    def __init__(self, image_shape, **kwargs):\n        \"\"\"\n        Accroding to original paper's realization, it's a hard resize method here. \n        So maybe you should optimize it to fit for your task better.\n        \"\"\"\n        self.dst_h, self.dst_w = image_shape\n    def __call__(self, data):\n        img = data['image']\n        resized_img = cv2.resize(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "SPINRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class SPINRecResizeImg(object):\n    def __init__(self,\n                 image_shape,\n                 interpolation=2,\n                 mean=(127.5, 127.5, 127.5),\n                 std=(127.5, 127.5, 127.5),\n                 **kwargs):\n        self.image_shape = image_shape\n        self.mean = np.array(mean, dtype=np.float32)\n        self.std = np.array(std, dtype=np.float32)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "GrayRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class GrayRecResizeImg(object):\n    def __init__(self,\n                 image_shape,\n                 resize_type,\n                 inter_type='Image.LANCZOS',\n                 scale=True,\n                 padding=False,\n                 **kwargs):\n        self.image_shape = image_shape\n        self.resize_type = resize_type",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "ABINetRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class ABINetRecResizeImg(object):\n    def __init__(self, image_shape, **kwargs):\n        self.image_shape = image_shape\n    def __call__(self, data):\n        img = data['image']\n        norm_img, valid_ratio = resize_norm_img_abinet(img, self.image_shape)\n        data['image'] = norm_img\n        data['valid_ratio'] = valid_ratio\n        return data\nclass SVTRRecResizeImg(object):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "SVTRRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class SVTRRecResizeImg(object):\n    def __init__(self, image_shape, padding=True, **kwargs):\n        self.image_shape = image_shape\n        self.padding = padding\n    def __call__(self, data):\n        img = data['image']\n        norm_img, valid_ratio = resize_norm_img(img, self.image_shape,\n                                                self.padding)\n        data['image'] = norm_img\n        data['valid_ratio'] = valid_ratio",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "RobustScannerRecResizeImg",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "class RobustScannerRecResizeImg(object):\n    def __init__(self,\n                 image_shape,\n                 max_text_length,\n                 width_downsample_ratio=0.25,\n                 **kwargs):\n        self.image_shape = image_shape\n        self.width_downsample_ratio = width_downsample_ratio\n        self.max_text_length = max_text_length\n    def __call__(self, data):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "resize_norm_img_sar",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def resize_norm_img_sar(img, image_shape, width_downsample_ratio=0.25):\n    imgC, imgH, imgW_min, imgW_max = image_shape\n    h = img.shape[0]\n    w = img.shape[1]\n    valid_ratio = 1.0\n    # make sure new_width is an integral multiple of width_divisor.\n    width_divisor = int(1 / width_downsample_ratio)\n    # resize\n    ratio = w / float(h)\n    resize_w = math.ceil(imgH * ratio)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "resize_norm_img",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def resize_norm_img(img,\n                    image_shape,\n                    padding=True,\n                    interpolation=cv2.INTER_LINEAR):\n    imgC, imgH, imgW = image_shape\n    h = img.shape[0]\n    w = img.shape[1]\n    if not padding:\n        resized_image = cv2.resize(\n            img, (imgW, imgH), interpolation=interpolation)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "resize_norm_img_chinese",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def resize_norm_img_chinese(img, image_shape):\n    imgC, imgH, imgW = image_shape\n    # todo: change to 0 and modified image shape\n    max_wh_ratio = imgW * 1.0 / imgH\n    h, w = img.shape[0], img.shape[1]\n    ratio = w * 1.0 / h\n    max_wh_ratio = max(max_wh_ratio, ratio)\n    imgW = int(imgH * max_wh_ratio)\n    if math.ceil(imgH * ratio) > imgW:\n        resized_w = imgW",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "resize_norm_img_srn",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def resize_norm_img_srn(img, image_shape):\n    imgC, imgH, imgW = image_shape\n    img_black = np.zeros((imgH, imgW))\n    im_hei = img.shape[0]\n    im_wid = img.shape[1]\n    if im_wid <= im_hei * 1:\n        img_new = cv2.resize(img, (imgH * 1, imgH))\n    elif im_wid <= im_hei * 2:\n        img_new = cv2.resize(img, (imgH * 2, imgH))\n    elif im_wid <= im_hei * 3:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "resize_norm_img_abinet",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def resize_norm_img_abinet(img, image_shape):\n    imgC, imgH, imgW = image_shape\n    resized_image = cv2.resize(\n        img, (imgW, imgH), interpolation=cv2.INTER_LINEAR)\n    resized_w = imgW\n    resized_image = resized_image.astype('float32')\n    resized_image = resized_image / 255.\n    mean = np.array([0.485, 0.456, 0.406])\n    std = np.array([0.229, 0.224, 0.225])\n    resized_image = (",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "srn_other_inputs",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def srn_other_inputs(image_shape, num_heads, max_text_length):\n    imgC, imgH, imgW = image_shape\n    feature_dim = int((imgH / 8) * (imgW / 8))\n    encoder_word_pos = np.array(range(0, feature_dim)).reshape(\n        (feature_dim, 1)).astype('int64')\n    gsrm_word_pos = np.array(range(0, max_text_length)).reshape(\n        (max_text_length, 1)).astype('int64')\n    gsrm_attn_bias_data = np.ones((1, max_text_length, max_text_length))\n    gsrm_slf_attn_bias1 = np.triu(gsrm_attn_bias_data, 1).reshape(\n        [1, max_text_length, max_text_length])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "flag",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def flag():\n    \"\"\"\n    flag\n    \"\"\"\n    return 1 if random.random() > 0.5000001 else -1\ndef hsv_aug(img):\n    \"\"\"\n    cvtColor\n    \"\"\"\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "hsv_aug",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def hsv_aug(img):\n    \"\"\"\n    cvtColor\n    \"\"\"\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    delta = 0.001 * random.random() * flag()\n    hsv[:, :, 2] = hsv[:, :, 2] * (1 + delta)\n    new_img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)\n    return new_img\ndef blur(img):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "blur",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def blur(img):\n    \"\"\"\n    blur\n    \"\"\"\n    h, w, _ = img.shape\n    if h > 10 and w > 10:\n        return cv2.GaussianBlur(img, (5, 5), 1)\n    else:\n        return img\ndef jitter(img):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "jitter",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def jitter(img):\n    \"\"\"\n    jitter\n    \"\"\"\n    w, h, _ = img.shape\n    if h > 10 and w > 10:\n        thres = min(w, h)\n        s = int(random.random() * thres * 0.01)\n        src_img = img.copy()\n        for i in range(s):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "add_gasuss_noise",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def add_gasuss_noise(image, mean=0, var=0.1):\n    \"\"\"\n    Gasuss noise\n    \"\"\"\n    noise = np.random.normal(mean, var**0.5, image.shape)\n    out = image + 0.5 * noise\n    out = np.clip(out, 0, 255)\n    out = np.uint8(out)\n    return out\ndef get_crop(image):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "get_crop",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def get_crop(image):\n    \"\"\"\n    random crop\n    \"\"\"\n    h, w, _ = image.shape\n    top_min = 1\n    top_max = 8\n    top_crop = int(random.randint(top_min, top_max))\n    top_crop = min(top_crop, h - 1)\n    crop_img = image.copy()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "rad",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def rad(x):\n    \"\"\"\n    rad\n    \"\"\"\n    return x * np.pi / 180\ndef get_warpR(config):\n    \"\"\"\n    get_warpR\n    \"\"\"\n    anglex, angley, anglez, fov, w, h, r = \\",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "get_warpR",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def get_warpR(config):\n    \"\"\"\n    get_warpR\n    \"\"\"\n    anglex, angley, anglez, fov, w, h, r = \\\n        config.anglex, config.angley, config.anglez, config.fov, config.w, config.h, config.r\n    if w > 69 and w < 112:\n        anglex = anglex * 1.5\n    z = np.sqrt(w**2 + h**2) / 2 / np.tan(rad(fov / 2))\n    # Homogeneous coordinate transformation matrix",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "get_warpAffine",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "peekOfCode": "def get_warpAffine(config):\n    \"\"\"\n    get_warpAffine\n    \"\"\"\n    anglez = config.anglez\n    rz = np.array([[np.cos(rad(anglez)), np.sin(rad(anglez)), 0],\n                   [-np.sin(rad(anglez)), np.cos(rad(anglez)), 0]], np.float32)\n    return rz",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.rec_img_aug",
        "documentation": {}
    },
    {
        "label": "SASTProcessTrain",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.sast_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.sast_process",
        "peekOfCode": "class SASTProcessTrain(object):\n    def __init__(self,\n                 image_shape=[512, 512],\n                 min_crop_size=24,\n                 min_crop_side_ratio=0.3,\n                 min_text_size=10,\n                 max_text_size=512,\n                 **kwargs):\n        self.input_size = image_shape[1]\n        self.min_crop_size = min_crop_size",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.sast_process",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.sast_process",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.sast_process",
        "peekOfCode": "__all__ = ['SASTProcessTrain']\nclass SASTProcessTrain(object):\n    def __init__(self,\n                 image_shape=[512, 512],\n                 min_crop_size=24,\n                 min_crop_side_ratio=0.3,\n                 min_text_size=10,\n                 max_text_size=512,\n                 **kwargs):\n        self.input_size = image_shape[1]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.sast_process",
        "documentation": {}
    },
    {
        "label": "SSLRotateResize",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ssl_img_aug",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ssl_img_aug",
        "peekOfCode": "class SSLRotateResize(object):\n    def __init__(self,\n                 image_shape,\n                 padding=False,\n                 select_all=True,\n                 mode=\"train\",\n                 **kwargs):\n        self.image_shape = image_shape\n        self.padding = padding\n        self.select_all = select_all",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.ssl_img_aug",
        "documentation": {}
    },
    {
        "label": "GenTableMask",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "peekOfCode": "class GenTableMask(object):\n    \"\"\" gen table mask \"\"\"\n    def __init__(self, shrink_h_max, shrink_w_max, mask_type=0, **kwargs):\n        self.shrink_h_max = 5\n        self.shrink_w_max = 5\n        self.mask_type = mask_type\n    def projection(self, erosion, h, w, spilt_threshold=0):\n        # 水平投影\n        projection_map = np.ones_like(erosion)\n        project_val_array = [0 for _ in range(0, h)]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "documentation": {}
    },
    {
        "label": "ResizeTableImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "peekOfCode": "class ResizeTableImage(object):\n    def __init__(self, max_len, resize_bboxes=False, infer_mode=False,\n                 **kwargs):\n        super(ResizeTableImage, self).__init__()\n        self.max_len = max_len\n        self.resize_bboxes = resize_bboxes\n        self.infer_mode = infer_mode\n    def __call__(self, data):\n        img = data['image']\n        height, width = img.shape[0:2]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "documentation": {}
    },
    {
        "label": "PaddingTableImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "peekOfCode": "class PaddingTableImage(object):\n    def __init__(self, size, **kwargs):\n        super(PaddingTableImage, self).__init__()\n        self.size = size\n    def __call__(self, data):\n        img = data['image']\n        pad_h, pad_w = self.size\n        padding_img = np.zeros((pad_h, pad_w, 3), dtype=np.float32)\n        height, width = img.shape[0:2]\n        padding_img[0:height, 0:width, :] = img.copy()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.imaug.table_ops",
        "documentation": {}
    },
    {
        "label": "DictCollator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "peekOfCode": "class DictCollator(object):\n    \"\"\"\n    data batch\n    \"\"\"\n    def __call__(self, batch):\n        # todo：support batch operators \n        data_dict = defaultdict(list)\n        to_tensor_keys = []\n        for sample in batch:\n            for k, v in sample.items():",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "documentation": {}
    },
    {
        "label": "ListCollator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "peekOfCode": "class ListCollator(object):\n    \"\"\"\n    data batch\n    \"\"\"\n    def __call__(self, batch):\n        # todo：support batch operators \n        data_dict = defaultdict(list)\n        to_tensor_idxs = []\n        for sample in batch:\n            for idx, v in enumerate(sample):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "documentation": {}
    },
    {
        "label": "SSLRotateCollate",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "peekOfCode": "class SSLRotateCollate(object):\n    \"\"\"\n    bach: [\n        [(4*3xH*W), (4,)]\n        [(4*3xH*W), (4,)]\n        ...\n    ]\n    \"\"\"\n    def __call__(self, batch):\n        output = [np.concatenate(d, axis=0) for d in zip(*batch)]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "documentation": {}
    },
    {
        "label": "DyMaskCollator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "peekOfCode": "class DyMaskCollator(object):\n    \"\"\"\n    batch: [\n        image [batch_size, channel, maxHinbatch, maxWinbatch]\n        image_mask [batch_size, channel, maxHinbatch, maxWinbatch]\n        label [batch_size, maxLabelLen]\n        label_mask [batch_size, maxLabelLen]\n        ...\n    ]\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.collate_fn",
        "documentation": {}
    },
    {
        "label": "LMDBDataSet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "peekOfCode": "class LMDBDataSet(Dataset):\n    def __init__(self, config, mode, logger, seed=None):\n        super(LMDBDataSet, self).__init__()\n        global_config = config['Global']\n        dataset_config = config[mode]['dataset']\n        loader_config = config[mode]['loader']\n        batch_size = loader_config['batch_size_per_card']\n        data_dir = dataset_config['data_dir']\n        self.do_shuffle = loader_config['shuffle']\n        self.lmdb_sets = self.load_hierarchical_lmdb_dataset(data_dir)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "documentation": {}
    },
    {
        "label": "LMDBDataSetSR",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "peekOfCode": "class LMDBDataSetSR(LMDBDataSet):\n    def buf2PIL(self, txn, key, type='RGB'):\n        imgbuf = txn.get(key)\n        buf = six.BytesIO()\n        buf.write(imgbuf)\n        buf.seek(0)\n        im = Image.open(buf).convert(type)\n        return im\n    def str_filt(self, str_, voc_type):\n        alpha_dict = {",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "documentation": {}
    },
    {
        "label": "LMDBDataSetTableMaster",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "peekOfCode": "class LMDBDataSetTableMaster(LMDBDataSet):\n    def load_hierarchical_lmdb_dataset(self, data_dir):\n        lmdb_sets = {}\n        dataset_idx = 0\n        env = lmdb.open(\n            data_dir,\n            max_readers=32,\n            readonly=True,\n            lock=False,\n            readahead=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.lmdb_dataset",
        "documentation": {}
    },
    {
        "label": "MultiScaleSampler",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.multi_scale_sampler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.multi_scale_sampler",
        "peekOfCode": "class MultiScaleSampler(Sampler):\n    def __init__(self,\n                 data_source,\n                 scales,\n                 first_bs=128,\n                 fix_bs=True,\n                 divided_factor=[8, 16],\n                 is_training=True,\n                 ratio_wh=0.8,\n                 max_w=480.,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.multi_scale_sampler",
        "documentation": {}
    },
    {
        "label": "PGDataSet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.pgnet_dataset",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.pgnet_dataset",
        "peekOfCode": "class PGDataSet(Dataset):\n    def __init__(self, config, mode, logger, seed=None):\n        super(PGDataSet, self).__init__()\n        self.logger = logger\n        self.seed = seed\n        self.mode = mode\n        global_config = config['Global']\n        dataset_config = config[mode]['dataset']\n        loader_config = config[mode]['loader']\n        self.delimiter = dataset_config.get('delimiter', '\\t')",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.pgnet_dataset",
        "documentation": {}
    },
    {
        "label": "PubTabDataSet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.pubtab_dataset",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.pubtab_dataset",
        "peekOfCode": "class PubTabDataSet(Dataset):\n    def __init__(self, config, mode, logger, seed=None):\n        super(PubTabDataSet, self).__init__()\n        self.logger = logger\n        global_config = config['Global']\n        dataset_config = config[mode]['dataset']\n        loader_config = config[mode]['loader']\n        label_file_list = dataset_config.pop('label_file_list')\n        data_source_num = len(label_file_list)\n        ratio_list = dataset_config.get(\"ratio_list\", [1.0])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.pubtab_dataset",
        "documentation": {}
    },
    {
        "label": "SimpleDataSet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.simple_dataset",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.simple_dataset",
        "peekOfCode": "class SimpleDataSet(Dataset):\n    def __init__(self, config, mode, logger, seed=None):\n        super(SimpleDataSet, self).__init__()\n        self.logger = logger\n        self.mode = mode.lower()\n        global_config = config['Global']\n        dataset_config = config[mode]['dataset']\n        loader_config = config[mode]['loader']\n        self.delimiter = dataset_config.get('delimiter', '\\t')\n        label_file_list = dataset_config.pop('label_file_list')",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.simple_dataset",
        "documentation": {}
    },
    {
        "label": "MultiScaleDataSet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.data.simple_dataset",
        "description": "Vision.Paddle.PaddleOCR.ppocr.data.simple_dataset",
        "peekOfCode": "class MultiScaleDataSet(SimpleDataSet):\n    def __init__(self, config, mode, logger, seed=None):\n        super(MultiScaleDataSet, self).__init__(config, mode, logger, seed)\n        self.ds_width = config[mode]['dataset'].get('ds_width', False)\n        if self.ds_width:\n            self.wh_aware()\n    def wh_aware(self):\n        data_line_new = []\n        wh_ratio = []\n        for lins in self.data_lines:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.data.simple_dataset",
        "documentation": {}
    },
    {
        "label": "RoIAlignRotated",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "description": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "peekOfCode": "class RoIAlignRotated(nn.Layer):\n    \"\"\"RoI align pooling layer for rotated proposals.\n    \"\"\"\n    def __init__(self,\n                 out_size,\n                 spatial_scale,\n                 sample_num=0,\n                 aligned=True,\n                 clockwise=False):\n        super(RoIAlignRotated, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "documentation": {}
    },
    {
        "label": "custom_ops",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "description": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "peekOfCode": "custom_ops = load(\n    name=\"custom_jit_ops\",\n    sources=[\n        \"ppocr/ext_op/roi_align_rotated/roi_align_rotated.cc\",\n        \"ppocr/ext_op/roi_align_rotated/roi_align_rotated.cu\"\n    ])\nroi_align_rotated = custom_ops.roi_align_rotated\nclass RoIAlignRotated(nn.Layer):\n    \"\"\"RoI align pooling layer for rotated proposals.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "documentation": {}
    },
    {
        "label": "roi_align_rotated",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "description": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "peekOfCode": "roi_align_rotated = custom_ops.roi_align_rotated\nclass RoIAlignRotated(nn.Layer):\n    \"\"\"RoI align pooling layer for rotated proposals.\n    \"\"\"\n    def __init__(self,\n                 out_size,\n                 spatial_scale,\n                 sample_num=0,\n                 aligned=True,\n                 clockwise=False):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.ext_op.roi_align_rotated.roi_align_rotated",
        "documentation": {}
    },
    {
        "label": "ACELoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.ace_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.ace_loss",
        "peekOfCode": "class ACELoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.loss_func = nn.CrossEntropyLoss(\n            weight=None,\n            ignore_index=0,\n            reduction='none',\n            soft_label=True,\n            axis=-1)\n    def __call__(self, predicts, batch):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.ace_loss",
        "documentation": {}
    },
    {
        "label": "CELoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "peekOfCode": "class CELoss(nn.Layer):\n    def __init__(self, epsilon=None):\n        super().__init__()\n        if epsilon is not None and (epsilon <= 0 or epsilon >= 1):\n            epsilon = None\n        self.epsilon = epsilon\n    def _labelsmoothing(self, target, class_num):\n        if target.shape[-1] != class_num:\n            one_hot_target = F.one_hot(target, class_num)\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "KLJSLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "peekOfCode": "class KLJSLoss(object):\n    def __init__(self, mode='kl'):\n        assert mode in ['kl', 'js', 'KL', 'JS'\n                        ], \"mode can only be one of ['kl', 'KL', 'js', 'JS']\"\n        self.mode = mode\n    def __call__(self, p1, p2, reduction=\"mean\", eps=1e-5):\n        if self.mode.lower() == 'kl':\n            loss = paddle.multiply(p2,\n                                   paddle.log((p2 + eps) / (p1 + eps) + eps))\n            loss += paddle.multiply(p1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "DMLLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "peekOfCode": "class DMLLoss(nn.Layer):\n    \"\"\"\n    DMLLoss\n    \"\"\"\n    def __init__(self, act=None, use_log=False):\n        super().__init__()\n        if act is not None:\n            assert act in [\"softmax\", \"sigmoid\"]\n        if act == \"softmax\":\n            self.act = nn.Softmax(axis=-1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "DistanceLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "peekOfCode": "class DistanceLoss(nn.Layer):\n    \"\"\"\n    DistanceLoss:\n        mode: loss mode\n    \"\"\"\n    def __init__(self, mode=\"l2\", **kargs):\n        super().__init__()\n        assert mode in [\"l1\", \"l2\", \"smooth_l1\"]\n        if mode == \"l1\":\n            self.loss_func = nn.L1Loss(**kargs)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "LossFromOutput",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "peekOfCode": "class LossFromOutput(nn.Layer):\n    def __init__(self, key='loss', reduction='none'):\n        super().__init__()\n        self.key = key\n        self.reduction = reduction\n    def forward(self, predicts, batch):\n        loss = predicts\n        if self.key is not None and isinstance(predicts, dict):\n            loss = loss[self.key]\n        if self.reduction == 'mean':",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "KLDivLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "peekOfCode": "class KLDivLoss(nn.Layer):\n    \"\"\"\n    KLDivLoss\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n    def _kldiv(self, x, target, mask=None):\n        eps = 1.0e-10\n        loss = target * (paddle.log(target + eps) - x)\n        if mask is not None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "DKDLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "peekOfCode": "class DKDLoss(nn.Layer):\n    \"\"\"\n    KLDivLoss\n    \"\"\"\n    def __init__(self, temperature=1.0, alpha=1.0, beta=1.0):\n        super().__init__()\n        self.temperature = temperature\n        self.alpha = alpha\n        self.beta = beta\n    def _cat_mask(self, t, mask1, mask2):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.basic_loss",
        "documentation": {}
    },
    {
        "label": "CenterLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.center_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.center_loss",
        "peekOfCode": "class CenterLoss(nn.Layer):\n    \"\"\"\n    Reference: Wen et al. A Discriminative Feature Learning Approach for Deep Face Recognition. ECCV 2016.\n    \"\"\"\n    def __init__(self, num_classes=6625, feat_dim=96, center_file_path=None):\n        super().__init__()\n        self.num_classes = num_classes\n        self.feat_dim = feat_dim\n        self.centers = paddle.randn(\n            shape=[self.num_classes, self.feat_dim]).astype(\"float64\")",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.center_loss",
        "documentation": {}
    },
    {
        "label": "ClsLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.cls_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.cls_loss",
        "peekOfCode": "class ClsLoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super(ClsLoss, self).__init__()\n        self.loss_func = nn.CrossEntropyLoss(reduction='mean')\n    def forward(self, predicts, batch):\n        label = batch[1].astype(\"int64\")\n        loss = self.loss_func(input=predicts, label=label)\n        return {'loss': loss}",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.cls_loss",
        "documentation": {}
    },
    {
        "label": "CombinedLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.combined_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.combined_loss",
        "peekOfCode": "class CombinedLoss(nn.Layer):\n    \"\"\"\n    CombinedLoss:\n        a combionation of loss function\n    \"\"\"\n    def __init__(self, loss_config_list=None):\n        super().__init__()\n        self.loss_func = []\n        self.loss_weight = []\n        assert isinstance(loss_config_list, list), (",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.combined_loss",
        "documentation": {}
    },
    {
        "label": "BalanceLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "peekOfCode": "class BalanceLoss(nn.Layer):\n    def __init__(self,\n                 balance_loss=True,\n                 main_loss_type='DiceLoss',\n                 negative_ratio=3,\n                 return_origin=False,\n                 eps=1e-6,\n                 **kwargs):\n        \"\"\"\n               The BalanceLoss for Differentiable Binarization text detection",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "documentation": {}
    },
    {
        "label": "DiceLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "peekOfCode": "class DiceLoss(nn.Layer):\n    def __init__(self, eps=1e-6):\n        super(DiceLoss, self).__init__()\n        self.eps = eps\n    def forward(self, pred, gt, mask, weights=None):\n        \"\"\"\n        DiceLoss function.\n        \"\"\"\n        assert pred.shape == gt.shape\n        assert pred.shape == mask.shape",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "documentation": {}
    },
    {
        "label": "MaskL1Loss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "peekOfCode": "class MaskL1Loss(nn.Layer):\n    def __init__(self, eps=1e-6):\n        super(MaskL1Loss, self).__init__()\n        self.eps = eps\n    def forward(self, pred, gt, mask):\n        \"\"\"\n        Mask L1 Loss\n        \"\"\"\n        loss = (paddle.abs(pred - gt) * mask).sum() / (mask.sum() + self.eps)\n        loss = paddle.mean(loss)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "documentation": {}
    },
    {
        "label": "BCELoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "peekOfCode": "class BCELoss(nn.Layer):\n    def __init__(self, reduction='mean'):\n        super(BCELoss, self).__init__()\n        self.reduction = reduction\n    def forward(self, input, label, mask=None, weight=None, name=None):\n        loss = F.binary_cross_entropy(input, label, reduction=self.reduction)\n        return loss",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_basic_loss",
        "documentation": {}
    },
    {
        "label": "DiceLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "peekOfCode": "class DiceLoss(nn.Layer):\n    def __init__(self, loss_weight=1.0):\n        super(DiceLoss, self).__init__()\n        self.loss_weight = loss_weight\n    def forward(self, input, target, mask, reduce=True):\n        batch_size = input.shape[0]\n        input = F.sigmoid(input)  # scale to 0-1\n        input = input.reshape((batch_size, -1))\n        target = paddle.cast(target.reshape((batch_size, -1)), \"float32\")\n        mask = paddle.cast(mask.reshape((batch_size, -1)), \"float32\")",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "documentation": {}
    },
    {
        "label": "SmoothL1Loss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "peekOfCode": "class SmoothL1Loss(nn.Layer):\n    def __init__(self, beta=1.0, loss_weight=1.0):\n        super(SmoothL1Loss, self).__init__()\n        self.beta = beta\n        self.loss_weight = loss_weight\n        np_coord = np.zeros(shape=[640, 640, 2], dtype=np.int64)\n        for i in range(640):\n            for j in range(640):\n                np_coord[i, j, 0] = j\n                np_coord[i, j, 1] = i",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "documentation": {}
    },
    {
        "label": "CTLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "peekOfCode": "class CTLoss(nn.Layer):\n    def __init__(self):\n        super(CTLoss, self).__init__()\n        self.kernel_loss = DiceLoss()\n        self.loc_loss = SmoothL1Loss(beta=0.1, loss_weight=0.05)\n    def forward(self, preds, batch):\n        imgs = batch[0]\n        out = preds['maps']\n        gt_kernels, training_masks, gt_instances, gt_kernel_instances, training_mask_distances, gt_distances = batch[\n            1:]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "documentation": {}
    },
    {
        "label": "ohem_single",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "peekOfCode": "def ohem_single(score, gt_text, training_mask):\n    # online hard example mining\n    pos_num = int(paddle.sum(gt_text > 0.5)) - int(\n        paddle.sum((gt_text > 0.5) & (training_mask <= 0.5)))\n    if pos_num == 0:\n        # selected_mask = gt_text.copy() * 0 # may be not good\n        selected_mask = training_mask\n        selected_mask = paddle.cast(\n            selected_mask.reshape(\n                (1, selected_mask.shape[0], selected_mask.shape[1])), \"float32\")",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "documentation": {}
    },
    {
        "label": "ohem_batch",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "peekOfCode": "def ohem_batch(scores, gt_texts, training_masks):\n    selected_masks = []\n    for i in range(scores.shape[0]):\n        selected_masks.append(\n            ohem_single(scores[i, :, :], gt_texts[i, :, :], training_masks[\n                i, :, :]))\n    selected_masks = paddle.cast(paddle.concat(selected_masks, 0), \"float32\")\n    return selected_masks\ndef iou_single(a, b, mask, n_class):\n    EPS = 1e-6",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "documentation": {}
    },
    {
        "label": "iou_single",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "peekOfCode": "def iou_single(a, b, mask, n_class):\n    EPS = 1e-6\n    valid = mask == 1\n    a = a[valid]\n    b = b[valid]\n    miou = []\n    # iou of each class\n    for i in range(n_class):\n        inter = paddle.cast(((a == i) & (b == i)), \"float32\")\n        union = paddle.cast(((a == i) | (b == i)), \"float32\")",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "documentation": {}
    },
    {
        "label": "iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "peekOfCode": "def iou(a, b, mask, n_class=2, reduce=True):\n    batch_size = a.shape[0]\n    a = a.reshape((batch_size, -1))\n    b = b.reshape((batch_size, -1))\n    mask = mask.reshape((batch_size, -1))\n    iou = paddle.zeros((batch_size, ), dtype=\"float32\")\n    for i in range(batch_size):\n        iou[i] = iou_single(a[i], b[i], mask[i], n_class)\n    if reduce:\n        iou = paddle.mean(iou)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_ct_loss",
        "documentation": {}
    },
    {
        "label": "DBLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_db_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_db_loss",
        "peekOfCode": "class DBLoss(nn.Layer):\n    \"\"\"\n    Differentiable Binarization (DB) Loss Function\n    args:\n        param (dict): the super paramter for DB Loss\n    \"\"\"\n    def __init__(self,\n                 balance_loss=True,\n                 main_loss_type='DiceLoss',\n                 alpha=5,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_db_loss",
        "documentation": {}
    },
    {
        "label": "DRRGLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_drrg_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_drrg_loss",
        "peekOfCode": "class DRRGLoss(nn.Layer):\n    def __init__(self, ohem_ratio=3.0):\n        super().__init__()\n        self.ohem_ratio = ohem_ratio\n        self.downsample_ratio = 1.0\n    def balance_bce_loss(self, pred, gt, mask):\n        \"\"\"Balanced Binary-CrossEntropy Loss.\n        Args:\n            pred (Tensor): Shape of :math:`(1, H, W)`.\n            gt (Tensor): Shape of :math:`(1, H, W)`.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_drrg_loss",
        "documentation": {}
    },
    {
        "label": "EASTLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_east_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_east_loss",
        "peekOfCode": "class EASTLoss(nn.Layer):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 eps=1e-6,\n                 **kwargs):\n        super(EASTLoss, self).__init__()\n        self.dice_loss = DiceLoss(eps=eps)\n    def forward(self, predicts, labels):\n        l_score, l_geo, l_mask = labels[1:]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_east_loss",
        "documentation": {}
    },
    {
        "label": "FCELoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_fce_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_fce_loss",
        "peekOfCode": "class FCELoss(nn.Layer):\n    \"\"\"The class for implementing FCENet loss\n    FCENet(CVPR2021): Fourier Contour Embedding for Arbitrary-shaped\n        Text Detection\n    [https://arxiv.org/abs/2104.10442]\n    Args:\n        fourier_degree (int) : The maximum Fourier transform degree k.\n        num_sample (int) : The sampling points number of regression\n            loss. If it is too small, fcenet tends to be overfitting.\n        ohem_ratio (float): the negative/positive ratio in OHEM.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_fce_loss",
        "documentation": {}
    },
    {
        "label": "multi_apply",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_fce_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_fce_loss",
        "peekOfCode": "def multi_apply(func, *args, **kwargs):\n    pfunc = partial(func, **kwargs) if kwargs else func\n    map_results = map(pfunc, *args)\n    return tuple(map(list, zip(*map_results)))\nclass FCELoss(nn.Layer):\n    \"\"\"The class for implementing FCENet loss\n    FCENet(CVPR2021): Fourier Contour Embedding for Arbitrary-shaped\n        Text Detection\n    [https://arxiv.org/abs/2104.10442]\n    Args:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_fce_loss",
        "documentation": {}
    },
    {
        "label": "PSELoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_pse_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_pse_loss",
        "peekOfCode": "class PSELoss(nn.Layer):\n    def __init__(self,\n                 alpha,\n                 ohem_ratio=3,\n                 kernel_sample_mask='pred',\n                 reduction='sum',\n                 eps=1e-6,\n                 **kwargs):\n        \"\"\"Implement PSE Loss.\n        \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_pse_loss",
        "documentation": {}
    },
    {
        "label": "SASTLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.det_sast_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.det_sast_loss",
        "peekOfCode": "class SASTLoss(nn.Layer):\n    \"\"\"\n    \"\"\"\n    def __init__(self, eps=1e-6, **kwargs):\n        super(SASTLoss, self).__init__()\n        self.dice_loss = DiceLoss(eps=eps)\n    def forward(self, predicts, labels):\n        \"\"\"\n        tcl_pos: N x 128 x 3\n        tcl_mask: N x 128 x 1",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.det_sast_loss",
        "documentation": {}
    },
    {
        "label": "DistillationDMLLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationDMLLoss(DMLLoss):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 model_name_pairs=[],\n                 act=None,\n                 use_log=False,\n                 key=None,\n                 multi_head=False,\n                 dis_head='ctc',",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationKLDivLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationKLDivLoss(KLDivLoss):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 model_name_pairs=[],\n                 key=None,\n                 multi_head=False,\n                 dis_head='ctc',\n                 maps_name=None,\n                 name=\"kl_div\"):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationDKDLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationDKDLoss(DKDLoss):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 model_name_pairs=[],\n                 key=None,\n                 multi_head=False,\n                 dis_head='ctc',\n                 maps_name=None,\n                 name=\"dkd\",",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationNRTRDMLLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationNRTRDMLLoss(DistillationDMLLoss):\n    \"\"\"\n    \"\"\"\n    def forward(self, predicts, batch):\n        loss_dict = dict()\n        for idx, pair in enumerate(self.model_name_pairs):\n            out1 = predicts[pair[0]]\n            out2 = predicts[pair[1]]\n            if self.key is not None:\n                out1 = out1[self.key]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationKLDivLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationKLDivLoss(KLDivLoss):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 model_name_pairs=[],\n                 key=None,\n                 multi_head=False,\n                 dis_head='ctc',\n                 maps_name=None,\n                 name=\"kl_div\"):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationDKDLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationDKDLoss(DKDLoss):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 model_name_pairs=[],\n                 key=None,\n                 multi_head=False,\n                 dis_head='ctc',\n                 maps_name=None,\n                 name=\"dkd\",",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationCTCLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationCTCLoss(CTCLoss):\n    def __init__(self,\n                 model_name_list=[],\n                 key=None,\n                 multi_head=False,\n                 name=\"loss_ctc\"):\n        super().__init__()\n        self.model_name_list = model_name_list\n        self.key = key\n        self.name = name",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationSARLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationSARLoss(SARLoss):\n    def __init__(self,\n                 model_name_list=[],\n                 key=None,\n                 multi_head=False,\n                 name=\"loss_sar\",\n                 **kwargs):\n        ignore_index = kwargs.get('ignore_index', 92)\n        super().__init__(ignore_index=ignore_index)\n        self.model_name_list = model_name_list",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationNRTRLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationNRTRLoss(CELoss):\n    def __init__(self,\n                 model_name_list=[],\n                 key=None,\n                 multi_head=False,\n                 smoothing=True,\n                 name=\"loss_nrtr\",\n                 **kwargs):\n        super().__init__(smoothing=smoothing)\n        self.model_name_list = model_name_list",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationDBLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationDBLoss(DBLoss):\n    def __init__(self,\n                 model_name_list=[],\n                 balance_loss=True,\n                 main_loss_type='DiceLoss',\n                 alpha=5,\n                 beta=10,\n                 ohem_ratio=3,\n                 eps=1e-6,\n                 name=\"db\",",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationDilaDBLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationDilaDBLoss(DBLoss):\n    def __init__(self,\n                 model_name_pairs=[],\n                 key=None,\n                 balance_loss=True,\n                 main_loss_type='DiceLoss',\n                 alpha=5,\n                 beta=10,\n                 ohem_ratio=3,\n                 eps=1e-6,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationDistanceLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationDistanceLoss(DistanceLoss):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 mode=\"l2\",\n                 model_name_pairs=[],\n                 key=None,\n                 name=\"loss_distance\",\n                 **kargs):\n        super().__init__(mode=mode, **kargs)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationVQASerTokenLayoutLMLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationVQASerTokenLayoutLMLoss(VQASerTokenLayoutLMLoss):\n    def __init__(self,\n                 num_classes,\n                 model_name_list=[],\n                 key=None,\n                 name=\"loss_ser\"):\n        super().__init__(num_classes=num_classes)\n        self.model_name_list = model_name_list\n        self.key = key\n        self.name = name",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationLossFromOutput",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationLossFromOutput(LossFromOutput):\n    def __init__(self,\n                 reduction=\"none\",\n                 model_name_list=[],\n                 dist_key=None,\n                 key=\"loss\",\n                 name=\"loss_re\"):\n        super().__init__(key=key, reduction=reduction)\n        self.model_name_list = model_name_list\n        self.name = name",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationSERDMLLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationSERDMLLoss(DMLLoss):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 act=\"softmax\",\n                 use_log=True,\n                 num_classes=7,\n                 model_name_pairs=[],\n                 key=None,\n                 name=\"loss_dml_ser\"):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillationVQADistanceLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillationVQADistanceLoss(DistanceLoss):\n    def __init__(self,\n                 mode=\"l2\",\n                 model_name_pairs=[],\n                 key=None,\n                 index=None,\n                 name=\"loss_distance\",\n                 **kargs):\n        super().__init__(mode=mode, **kargs)\n        assert isinstance(model_name_pairs, list)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "CTCDKDLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class CTCDKDLoss(nn.Layer):\n    \"\"\"\n    KLDivLoss\n    \"\"\"\n    def __init__(self, temperature=0.5, alpha=1.0, beta=1.0):\n        super().__init__()\n        self.temperature = temperature\n        self.alpha = alpha\n        self.beta = beta\n        self.eps = 1e-6",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "KLCTCLogits",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class KLCTCLogits(nn.Layer):\n    def __init__(self, weight=1.0, reduction='mean', mode=\"mean\"):\n        super().__init__()\n        self.weight = weight\n        self.reduction = reduction\n        self.eps = 1e-6\n        self.t = 0.5\n        self.act = nn.Softmax(axis=-1)\n        self.use_log = True\n        self.mode = mode",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "DistillCTCLogits",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "peekOfCode": "class DistillCTCLogits(KLCTCLogits):\n    def __init__(self,\n                 model_name_pairs=[],\n                 key=None,\n                 name=\"ctc_logits\",\n                 reduction=\"mean\"):\n        super().__init__(reduction=reduction)\n        self.model_name_pairs = self._check_model_name_pairs(model_name_pairs)\n        self.key = key\n        self.name = name",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.distillation_loss",
        "documentation": {}
    },
    {
        "label": "PGLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.e2e_pg_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.e2e_pg_loss",
        "peekOfCode": "class PGLoss(nn.Layer):\n    def __init__(self,\n                 tcl_bs,\n                 max_text_length,\n                 max_text_nums,\n                 pad_num,\n                 eps=1e-6,\n                 **kwargs):\n        super(PGLoss, self).__init__()\n        self.tcl_bs = tcl_bs",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.e2e_pg_loss",
        "documentation": {}
    },
    {
        "label": "SDMGRLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.kie_sdmgr_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.kie_sdmgr_loss",
        "peekOfCode": "class SDMGRLoss(nn.Layer):\n    def __init__(self, node_weight=1.0, edge_weight=1.0, ignore=0):\n        super().__init__()\n        self.loss_node = nn.CrossEntropyLoss(ignore_index=ignore)\n        self.loss_edge = nn.CrossEntropyLoss(ignore_index=-1)\n        self.node_weight = node_weight\n        self.edge_weight = edge_weight\n        self.ignore = ignore\n    def pre_process(self, gts, tag):\n        gts, tag = gts.numpy(), tag.numpy().tolist()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.kie_sdmgr_loss",
        "documentation": {}
    },
    {
        "label": "CosineEmbeddingLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_aster_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_aster_loss",
        "peekOfCode": "class CosineEmbeddingLoss(nn.Layer):\n    def __init__(self, margin=0.):\n        super(CosineEmbeddingLoss, self).__init__()\n        self.margin = margin\n        self.epsilon = 1e-12\n    def forward(self, x1, x2, target):\n        similarity = paddle.sum(\n            x1 * x2, axis=-1) / (paddle.norm(\n                x1, axis=-1) * paddle.norm(\n                    x2, axis=-1) + self.epsilon)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_aster_loss",
        "documentation": {}
    },
    {
        "label": "AsterLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_aster_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_aster_loss",
        "peekOfCode": "class AsterLoss(nn.Layer):\n    def __init__(self,\n                 weight=None,\n                 size_average=True,\n                 ignore_index=-100,\n                 sequence_normalize=False,\n                 sample_normalize=True,\n                 **kwargs):\n        super(AsterLoss, self).__init__()\n        self.weight = weight",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_aster_loss",
        "documentation": {}
    },
    {
        "label": "AttentionLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_att_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_att_loss",
        "peekOfCode": "class AttentionLoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super(AttentionLoss, self).__init__()\n        self.loss_func = nn.CrossEntropyLoss(weight=None, reduction='none')\n    def forward(self, predicts, batch):\n        targets = batch[1].astype(\"int64\")\n        label_lengths = batch[2].astype('int64')\n        batch_size, num_steps, num_classes = predicts.shape[0], predicts.shape[\n            1], predicts.shape[2]\n        assert len(targets.shape) == len(list(predicts.shape)) - 1, \\",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_att_loss",
        "documentation": {}
    },
    {
        "label": "CANLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_can_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_can_loss",
        "peekOfCode": "class CANLoss(nn.Layer):\n    '''\n    CANLoss is consist of two part:\n        word_average_loss: average accuracy of the symbol\n        counting_loss: counting loss of every symbol\n    '''\n    def __init__(self):\n        super(CANLoss, self).__init__()\n        self.use_label_mask = False\n        self.out_channel = 111",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_can_loss",
        "documentation": {}
    },
    {
        "label": "gen_counting_label",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_can_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_can_loss",
        "peekOfCode": "def gen_counting_label(labels, channel, tag):\n    b, t = labels.shape\n    counting_labels = np.zeros([b, channel])\n    if tag:\n        ignore = [0, 1, 107, 108, 109, 110]\n    else:\n        ignore = []\n    for i in range(b):\n        for j in range(t):\n            k = labels[i][j]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_can_loss",
        "documentation": {}
    },
    {
        "label": "CELoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_ce_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_ce_loss",
        "peekOfCode": "class CELoss(nn.Layer):\n    def __init__(self,\n                 smoothing=False,\n                 with_all=False,\n                 ignore_index=-1,\n                 **kwargs):\n        super(CELoss, self).__init__()\n        if ignore_index >= 0:\n            self.loss_func = nn.CrossEntropyLoss(\n                reduction='mean', ignore_index=ignore_index)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_ce_loss",
        "documentation": {}
    },
    {
        "label": "CTCLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_ctc_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_ctc_loss",
        "peekOfCode": "class CTCLoss(nn.Layer):\n    def __init__(self, use_focal_loss=False, **kwargs):\n        super(CTCLoss, self).__init__()\n        self.loss_func = nn.CTCLoss(blank=0, reduction='none')\n        self.use_focal_loss = use_focal_loss\n    def forward(self, predicts, batch):\n        if isinstance(predicts, (list, tuple)):\n            predicts = predicts[-1]\n        predicts = predicts.transpose((1, 0, 2))\n        N, B, _ = predicts.shape",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_ctc_loss",
        "documentation": {}
    },
    {
        "label": "EnhancedCTCLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_enhanced_ctc_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_enhanced_ctc_loss",
        "peekOfCode": "class EnhancedCTCLoss(nn.Layer):\n    def __init__(self,\n                 use_focal_loss=False,\n                 use_ace_loss=False,\n                 ace_loss_weight=0.1,\n                 use_center_loss=False,\n                 center_loss_weight=0.05,\n                 num_classes=6625,\n                 feat_dim=96,\n                 init_center=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_enhanced_ctc_loss",
        "documentation": {}
    },
    {
        "label": "MultiLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_multi_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_multi_loss",
        "peekOfCode": "class MultiLoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.loss_funcs = {}\n        self.loss_list = kwargs.pop('loss_config_list')\n        self.weight_1 = kwargs.get('weight_1', 1.0)\n        self.weight_2 = kwargs.get('weight_2', 1.0)\n        for loss_info in self.loss_list:\n            for name, param in loss_info.items():\n                if param is not None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_multi_loss",
        "documentation": {}
    },
    {
        "label": "NRTRLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_nrtr_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_nrtr_loss",
        "peekOfCode": "class NRTRLoss(nn.Layer):\n    def __init__(self, smoothing=True, ignore_index=0, **kwargs):\n        super(NRTRLoss, self).__init__()\n        if ignore_index >= 0 and not smoothing:\n            self.loss_func = nn.CrossEntropyLoss(\n                reduction='mean', ignore_index=ignore_index)\n        self.smoothing = smoothing\n    def forward(self, pred, batch):\n        max_len = batch[2].max()\n        tgt = batch[1][:, 1:2 + max_len]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_nrtr_loss",
        "documentation": {}
    },
    {
        "label": "PRENLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_pren_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_pren_loss",
        "peekOfCode": "class PRENLoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super(PRENLoss, self).__init__()\n        # note: 0 is padding idx\n        self.loss_func = nn.CrossEntropyLoss(reduction='mean', ignore_index=0)\n    def forward(self, predicts, batch):\n        loss = self.loss_func(predicts, batch[1].astype('int64'))\n        return {'loss': loss}",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_pren_loss",
        "documentation": {}
    },
    {
        "label": "RFLLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_rfl_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_rfl_loss",
        "peekOfCode": "class RFLLoss(nn.Layer):\n    def __init__(self, ignore_index=-100, **kwargs):\n        super().__init__()\n        self.cnt_loss = nn.MSELoss(**kwargs)\n        self.seq_loss = nn.CrossEntropyLoss(ignore_index=ignore_index)\n    def forward(self, predicts, batch):\n        self.total_loss = {}\n        total_loss = 0.0\n        if isinstance(predicts, tuple) or isinstance(predicts, list):\n            cnt_outputs, seq_outputs = predicts",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_rfl_loss",
        "documentation": {}
    },
    {
        "label": "SARLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_sar_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_sar_loss",
        "peekOfCode": "class SARLoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super(SARLoss, self).__init__()\n        ignore_index = kwargs.get('ignore_index', 92)  # 6626\n        self.loss_func = paddle.nn.loss.CrossEntropyLoss(\n            reduction=\"mean\", ignore_index=ignore_index)\n    def forward(self, predicts, batch):\n        predict = predicts[:, :\n                           -1, :]  # ignore last index of outputs to be in same seq_len with targets\n        label = batch[1].astype(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_sar_loss",
        "documentation": {}
    },
    {
        "label": "SATRNLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_satrn_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_satrn_loss",
        "peekOfCode": "class SATRNLoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super(SATRNLoss, self).__init__()\n        ignore_index = kwargs.get('ignore_index', 92)  # 6626\n        self.loss_func = paddle.nn.loss.CrossEntropyLoss(\n            reduction=\"none\", ignore_index=ignore_index)\n    def forward(self, predicts, batch):\n        predict = predicts[:, :\n                           -1, :]  # ignore last index of outputs to be in same seq_len with targets\n        label = batch[1].astype(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_satrn_loss",
        "documentation": {}
    },
    {
        "label": "SPINAttentionLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_spin_att_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_spin_att_loss",
        "peekOfCode": "class SPINAttentionLoss(nn.Layer):\n    def __init__(self, reduction='mean', ignore_index=-100, **kwargs):\n        super(SPINAttentionLoss, self).__init__()\n        self.loss_func = nn.CrossEntropyLoss(weight=None, reduction=reduction, ignore_index=ignore_index)\n    def forward(self, predicts, batch):\n        targets = batch[1].astype(\"int64\")\n        targets = targets[:, 1:] # remove [eos] in label\n        label_lengths = batch[2].astype('int64')\n        batch_size, num_steps, num_classes = predicts.shape[0], predicts.shape[\n            1], predicts.shape[2]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_spin_att_loss",
        "documentation": {}
    },
    {
        "label": "SRNLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_srn_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_srn_loss",
        "peekOfCode": "class SRNLoss(nn.Layer):\n    def __init__(self, **kwargs):\n        super(SRNLoss, self).__init__()\n        self.loss_func = paddle.nn.loss.CrossEntropyLoss(reduction=\"sum\")\n    def forward(self, predicts, batch):\n        predict = predicts['predict']\n        word_predict = predicts['word_out']\n        gsrm_predict = predicts['gsrm_out']\n        label = batch[1]\n        casted_label = paddle.cast(x=label, dtype='int64')",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_srn_loss",
        "documentation": {}
    },
    {
        "label": "VLLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_vl_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_vl_loss",
        "peekOfCode": "class VLLoss(nn.Layer):\n    def __init__(self, mode='LF_1', weight_res=0.5, weight_mas=0.5, **kwargs):\n        super(VLLoss, self).__init__()\n        self.loss_func = paddle.nn.loss.CrossEntropyLoss(reduction=\"mean\")\n        assert mode in ['LF_1', 'LF_2', 'LA']\n        self.mode = mode\n        self.weight_res = weight_res\n        self.weight_mas = weight_mas\n    def flatten_label(self, target):\n        label_flatten = []",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.rec_vl_loss",
        "documentation": {}
    },
    {
        "label": "StrokeFocusLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.stroke_focus_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.stroke_focus_loss",
        "peekOfCode": "class StrokeFocusLoss(nn.Layer):\n    def __init__(self, character_dict_path=None, **kwargs):\n        super(StrokeFocusLoss, self).__init__(character_dict_path)\n        self.mse_loss = nn.MSELoss()\n        self.ce_loss = nn.CrossEntropyLoss()\n        self.l1_loss = nn.L1Loss()\n        self.english_stroke_alphabet = '0123456789'\n        self.english_stroke_dict = {}\n        for index in range(len(self.english_stroke_alphabet)):\n            self.english_stroke_dict[self.english_stroke_alphabet[",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.stroke_focus_loss",
        "documentation": {}
    },
    {
        "label": "TableAttentionLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.table_att_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.table_att_loss",
        "peekOfCode": "class TableAttentionLoss(nn.Layer):\n    def __init__(self, structure_weight, loc_weight, **kwargs):\n        super(TableAttentionLoss, self).__init__()\n        self.loss_func = nn.CrossEntropyLoss(weight=None, reduction='none')\n        self.structure_weight = structure_weight\n        self.loc_weight = loc_weight\n    def forward(self, predicts, batch):\n        structure_probs = predicts['structure_probs']\n        structure_targets = batch[1].astype(\"int64\")\n        structure_targets = structure_targets[:, 1:]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.table_att_loss",
        "documentation": {}
    },
    {
        "label": "SLALoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.table_att_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.table_att_loss",
        "peekOfCode": "class SLALoss(nn.Layer):\n    def __init__(self, structure_weight, loc_weight, loc_loss='mse', **kwargs):\n        super(SLALoss, self).__init__()\n        self.loss_func = nn.CrossEntropyLoss(weight=None, reduction='mean')\n        self.structure_weight = structure_weight\n        self.loc_weight = loc_weight\n        self.loc_loss = loc_loss\n        self.eps = 1e-12\n    def forward(self, predicts, batch):\n        structure_probs = predicts['structure_probs']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.table_att_loss",
        "documentation": {}
    },
    {
        "label": "TableMasterLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.table_master_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.table_master_loss",
        "peekOfCode": "class TableMasterLoss(nn.Layer):\n    def __init__(self, ignore_index=-1):\n        super(TableMasterLoss, self).__init__()\n        self.structure_loss = nn.CrossEntropyLoss(\n            ignore_index=ignore_index, reduction='mean')\n        self.box_loss = nn.L1Loss(reduction='sum')\n        self.eps = 1e-12\n    def forward(self, predicts, batch):\n        # structure_loss\n        structure_probs = predicts['structure_probs']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.table_master_loss",
        "documentation": {}
    },
    {
        "label": "TelescopeLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "peekOfCode": "class TelescopeLoss(nn.Layer):\n    def __init__(self, confuse_dict_path):\n        super(TelescopeLoss, self).__init__()\n        self.weight_table = load_confuse_matrix(confuse_dict_path)\n        self.mse_loss = nn.MSELoss()\n        self.ce_loss = nn.CrossEntropyLoss()\n        self.l1_loss = nn.L1Loss()\n    def forward(self, pred, data):\n        sr_img = pred[\"sr_img\"]\n        hr_img = pred[\"hr_img\"]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "documentation": {}
    },
    {
        "label": "load_confuse_matrix",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "peekOfCode": "def load_confuse_matrix(confuse_dict_path):\n    f = open(confuse_dict_path, 'rb')\n    data = pkl.load(f)\n    f.close()\n    number = data[:10]\n    upper = data[10:36]\n    lower = data[36:]\n    end = np.ones((1, 62))\n    pad = np.ones((63, 1))\n    rearrange_data = np.concatenate((end, number, lower, upper), axis=0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "documentation": {}
    },
    {
        "label": "weight_cross_entropy",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "peekOfCode": "def weight_cross_entropy(pred, gt, weight_table):\n    batch = gt.shape[0]\n    weight = weight_table[gt]\n    pred_exp = paddle.exp(pred)\n    pred_exp_weight = weight * pred_exp\n    loss = 0\n    for i in range(len(gt)):\n        loss -= paddle.log(pred_exp_weight[i][gt[i]] / paddle.sum(pred_exp_weight, 1)[i])\n    return loss / batch\nclass TelescopeLoss(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "documentation": {}
    },
    {
        "label": "standard_alphebet",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "peekOfCode": "standard_alphebet = '-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\nstandard_dict = {}\nfor index in range(len(standard_alphebet)):\n    standard_dict[standard_alphebet[index]] = index\ndef load_confuse_matrix(confuse_dict_path):\n    f = open(confuse_dict_path, 'rb')\n    data = pkl.load(f)\n    f.close()\n    number = data[:10]\n    upper = data[10:36]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "documentation": {}
    },
    {
        "label": "standard_dict",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "peekOfCode": "standard_dict = {}\nfor index in range(len(standard_alphebet)):\n    standard_dict[standard_alphebet[index]] = index\ndef load_confuse_matrix(confuse_dict_path):\n    f = open(confuse_dict_path, 'rb')\n    data = pkl.load(f)\n    f.close()\n    number = data[:10]\n    upper = data[10:36]\n    lower = data[36:]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.text_focus_loss",
        "documentation": {}
    },
    {
        "label": "VQASerTokenLayoutLMLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.losses.vqa_token_layoutlm_loss",
        "description": "Vision.Paddle.PaddleOCR.ppocr.losses.vqa_token_layoutlm_loss",
        "peekOfCode": "class VQASerTokenLayoutLMLoss(nn.Layer):\n    def __init__(self, num_classes, key=None):\n        super().__init__()\n        self.loss_class = nn.CrossEntropyLoss()\n        self.num_classes = num_classes\n        self.ignore_index = self.loss_class.ignore_index\n        self.key = key\n    def forward(self, predicts, batch):\n        if isinstance(predicts, dict) and self.key is not None:\n            predicts = predicts[self.key]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.losses.vqa_token_layoutlm_loss",
        "documentation": {}
    },
    {
        "label": "ClsMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.cls_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.cls_metric",
        "peekOfCode": "class ClsMetric(object):\n    def __init__(self, main_indicator='acc', **kwargs):\n        self.main_indicator = main_indicator\n        self.eps = 1e-5\n        self.reset()\n    def __call__(self, pred_label, *args, **kwargs):\n        preds, labels = pred_label\n        correct_num = 0\n        all_num = 0\n        for (pred, pred_conf), (target, _) in zip(preds, labels):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.cls_metric",
        "documentation": {}
    },
    {
        "label": "CTMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.ct_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.ct_metric",
        "peekOfCode": "class CTMetric(object):\n    def __init__(self, main_indicator, delimiter='\\t', **kwargs):\n        self.delimiter = delimiter\n        self.main_indicator = main_indicator\n        self.reset()\n    def reset(self):\n        self.results = []  # clear results\n    def __call__(self, preds, batch, **kwargs):\n        # NOTE: only support bs=1 now, as the label length of different sample is Unequal \n        assert len(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.ct_metric",
        "documentation": {}
    },
    {
        "label": "DetMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "peekOfCode": "class DetMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.evaluator = DetectionIoUEvaluator()\n        self.main_indicator = main_indicator\n        self.reset()\n    def __call__(self, preds, batch, **kwargs):\n        '''\n       batch: a list produced by dataloaders.\n           image: np.ndarray  of shape (N, C, H, W).\n           ratio_list: np.ndarray  of shape(N,2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "documentation": {}
    },
    {
        "label": "DetFCEMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "peekOfCode": "class DetFCEMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.evaluator = DetectionIoUEvaluator()\n        self.main_indicator = main_indicator\n        self.reset()\n    def __call__(self, preds, batch, **kwargs):\n        '''\n       batch: a list produced by dataloaders.\n           image: np.ndarray  of shape (N, C, H, W).\n           ratio_list: np.ndarray  of shape(N,2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "peekOfCode": "__all__ = ['DetMetric', 'DetFCEMetric']\nfrom .eval_det_iou import DetectionIoUEvaluator\nclass DetMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.evaluator = DetectionIoUEvaluator()\n        self.main_indicator = main_indicator\n        self.reset()\n    def __call__(self, preds, batch, **kwargs):\n        '''\n       batch: a list produced by dataloaders.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.det_metric",
        "documentation": {}
    },
    {
        "label": "DistillationMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.distillation_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.distillation_metric",
        "peekOfCode": "class DistillationMetric(object):\n    def __init__(self,\n                 key=None,\n                 base_metric_name=None,\n                 main_indicator=None,\n                 **kwargs):\n        self.main_indicator = main_indicator\n        self.key = key\n        self.main_indicator = main_indicator\n        self.base_metric_name = base_metric_name",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.distillation_metric",
        "documentation": {}
    },
    {
        "label": "E2EMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.e2e_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.e2e_metric",
        "peekOfCode": "class E2EMetric(object):\n    def __init__(self,\n                 mode,\n                 gt_mat_dir,\n                 character_dict_path,\n                 main_indicator='f_score_e2e',\n                 **kwargs):\n        self.mode = mode\n        self.gt_mat_dir = gt_mat_dir\n        self.label_list = get_dict(character_dict_path)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.e2e_metric",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.e2e_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.e2e_metric",
        "peekOfCode": "__all__ = ['E2EMetric']\nfrom ppocr.utils.e2e_metric.Deteval import get_socre_A, get_socre_B, combine_results\nfrom ppocr.utils.e2e_utils.extract_textpoint_slow import get_dict\nclass E2EMetric(object):\n    def __init__(self,\n                 mode,\n                 gt_mat_dir,\n                 character_dict_path,\n                 main_indicator='f_score_e2e',\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.e2e_metric",
        "documentation": {}
    },
    {
        "label": "DetectionIoUEvaluator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.eval_det_iou",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.eval_det_iou",
        "peekOfCode": "class DetectionIoUEvaluator(object):\n    def __init__(self, iou_constraint=0.5, area_precision_constraint=0.5):\n        self.iou_constraint = iou_constraint\n        self.area_precision_constraint = area_precision_constraint\n    def evaluate_image(self, gt, pred):\n        def get_union(pD, pG):\n            return Polygon(pD).union(Polygon(pG)).area\n        def get_intersection_over_union(pD, pG):\n            return get_intersection(pD, pG) / get_union(pD, pG)\n        def get_intersection(pD, pG):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.eval_det_iou",
        "documentation": {}
    },
    {
        "label": "KIEMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.kie_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.kie_metric",
        "peekOfCode": "class KIEMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.main_indicator = main_indicator\n        self.reset()\n        self.node = []\n        self.gt = []\n    def __call__(self, preds, batch, **kwargs):\n        nodes, _ = preds\n        gts, tag = batch[4].squeeze(0), batch[5].tolist()[0]\n        gts = gts[:tag[0], :1].reshape([-1])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.kie_metric",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.kie_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.kie_metric",
        "peekOfCode": "__all__ = ['KIEMetric']\nclass KIEMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.main_indicator = main_indicator\n        self.reset()\n        self.node = []\n        self.gt = []\n    def __call__(self, preds, batch, **kwargs):\n        nodes, _ = preds\n        gts, tag = batch[4].squeeze(0), batch[5].tolist()[0]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.kie_metric",
        "documentation": {}
    },
    {
        "label": "RecMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "peekOfCode": "class RecMetric(object):\n    def __init__(self,\n                 main_indicator='acc',\n                 is_filter=False,\n                 ignore_space=True,\n                 **kwargs):\n        self.main_indicator = main_indicator\n        self.is_filter = is_filter\n        self.ignore_space = ignore_space\n        self.eps = 1e-5",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "documentation": {}
    },
    {
        "label": "CNTMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "peekOfCode": "class CNTMetric(object):\n    def __init__(self, main_indicator='acc', **kwargs):\n        self.main_indicator = main_indicator\n        self.eps = 1e-5\n        self.reset()\n    def __call__(self, pred_label, *args, **kwargs):\n        preds, labels = pred_label\n        correct_num = 0\n        all_num = 0\n        for pred, target in zip(preds, labels):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "documentation": {}
    },
    {
        "label": "CANMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "peekOfCode": "class CANMetric(object):\n    def __init__(self, main_indicator='exp_rate', **kwargs):\n        self.main_indicator = main_indicator\n        self.word_right = []\n        self.exp_right = []\n        self.word_total_length = 0\n        self.exp_total_num = 0\n        self.word_rate = 0\n        self.exp_rate = 0\n        self.reset()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.rec_metric",
        "documentation": {}
    },
    {
        "label": "SSIM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.sr_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.sr_metric",
        "peekOfCode": "class SSIM(nn.Layer):\n    def __init__(self, window_size=11, size_average=True):\n        super(SSIM, self).__init__()\n        self.window_size = window_size\n        self.size_average = size_average\n        self.channel = 1\n        self.window = self.create_window(window_size, self.channel)\n    def gaussian(self, window_size, sigma):\n        gauss = paddle.to_tensor([\n            exp(-(x - window_size // 2)**2 / float(2 * sigma**2))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.sr_metric",
        "documentation": {}
    },
    {
        "label": "SRMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.sr_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.sr_metric",
        "peekOfCode": "class SRMetric(object):\n    def __init__(self, main_indicator='all', **kwargs):\n        self.main_indicator = main_indicator\n        self.eps = 1e-5\n        self.psnr_result = []\n        self.ssim_result = []\n        self.calculate_ssim = SSIM()\n        self.reset()\n    def reset(self):\n        self.correct_num = 0",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.sr_metric",
        "documentation": {}
    },
    {
        "label": "TableStructureMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.table_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.table_metric",
        "peekOfCode": "class TableStructureMetric(object):\n    def __init__(self,\n                 main_indicator='acc',\n                 eps=1e-6,\n                 del_thead_tbody=False,\n                 **kwargs):\n        self.main_indicator = main_indicator\n        self.eps = eps\n        self.del_thead_tbody = del_thead_tbody\n        self.reset()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.table_metric",
        "documentation": {}
    },
    {
        "label": "TableMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.table_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.table_metric",
        "peekOfCode": "class TableMetric(object):\n    def __init__(self,\n                 main_indicator='acc',\n                 compute_bbox_metric=False,\n                 box_format='xyxy',\n                 del_thead_tbody=False,\n                 **kwargs):\n        \"\"\"\n        @param sub_metrics: configs of sub_metric\n        @param main_matric: main_matric for save best_model",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.table_metric",
        "documentation": {}
    },
    {
        "label": "VQAReTokenMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_re_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_re_metric",
        "peekOfCode": "class VQAReTokenMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.main_indicator = main_indicator\n        self.reset()\n    def __call__(self, preds, batch, **kwargs):\n        pred_relations, relations, entities = preds\n        self.pred_relations_list.extend(pred_relations)\n        self.relations_list.extend(relations)\n        self.entities_list.extend(entities)\n    def get_metric(self):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_re_metric",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_re_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_re_metric",
        "peekOfCode": "__all__ = ['KIEMetric']\nclass VQAReTokenMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.main_indicator = main_indicator\n        self.reset()\n    def __call__(self, preds, batch, **kwargs):\n        pred_relations, relations, entities = preds\n        self.pred_relations_list.extend(pred_relations)\n        self.relations_list.extend(relations)\n        self.entities_list.extend(entities)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_re_metric",
        "documentation": {}
    },
    {
        "label": "VQASerTokenMetric",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_ser_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_ser_metric",
        "peekOfCode": "class VQASerTokenMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.main_indicator = main_indicator\n        self.reset()\n    def __call__(self, preds, batch, **kwargs):\n        preds, labels = preds\n        self.pred_list.extend(preds)\n        self.gt_list.extend(labels)\n    def get_metric(self):\n        from seqeval.metrics import f1_score, precision_score, recall_score",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_ser_metric",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_ser_metric",
        "description": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_ser_metric",
        "peekOfCode": "__all__ = ['KIEMetric']\nclass VQASerTokenMetric(object):\n    def __init__(self, main_indicator='hmean', **kwargs):\n        self.main_indicator = main_indicator\n        self.reset()\n    def __call__(self, preds, batch, **kwargs):\n        preds, labels = preds\n        self.pred_list.extend(preds)\n        self.gt_list.extend(labels)\n    def get_metric(self):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.metrics.vqa_token_ser_metric",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.base_model",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.base_model",
        "peekOfCode": "class BaseModel(nn.Layer):\n    def __init__(self, config):\n        \"\"\"\n        the module for OCR.\n        args:\n            config (dict): the super parameters for module.\n        \"\"\"\n        super(BaseModel, self).__init__()\n        in_channels = config.get('in_channels', 3)\n        model_type = config['model_type']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.base_model",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.base_model",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.base_model",
        "peekOfCode": "__all__ = ['BaseModel']\nclass BaseModel(nn.Layer):\n    def __init__(self, config):\n        \"\"\"\n        the module for OCR.\n        args:\n            config (dict): the super parameters for module.\n        \"\"\"\n        super(BaseModel, self).__init__()\n        in_channels = config.get('in_channels', 3)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.base_model",
        "documentation": {}
    },
    {
        "label": "DistillationModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.distillation_model",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.distillation_model",
        "peekOfCode": "class DistillationModel(nn.Layer):\n    def __init__(self, config):\n        \"\"\"\n        the module for OCR distillation.\n        args:\n            config (dict): the super parameters for module.\n        \"\"\"\n        super().__init__()\n        self.model_list = []\n        self.model_name_list = []",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.distillation_model",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.distillation_model",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.distillation_model",
        "peekOfCode": "__all__ = ['DistillationModel']\nclass DistillationModel(nn.Layer):\n    def __init__(self, config):\n        \"\"\"\n        the module for OCR distillation.\n        args:\n            config (dict): the super parameters for module.\n        \"\"\"\n        super().__init__()\n        self.model_list = []",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.architectures.distillation_model",
        "documentation": {}
    },
    {
        "label": "MobileNetV3",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "peekOfCode": "class MobileNetV3(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 model_name='large',\n                 scale=0.5,\n                 disable_se=False,\n                 **kwargs):\n        \"\"\"\n        the MobilenetV3 backbone network for detection module.\n        Args:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 padding,\n                 groups=1,\n                 if_act=True,\n                 act=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "ResidualUnit",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "peekOfCode": "class ResidualUnit(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 mid_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 use_se,\n                 act=None):\n        super(ResidualUnit, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "SEModule",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "peekOfCode": "class SEModule(nn.Layer):\n    def __init__(self, in_channels, reduction=4):\n        super(SEModule, self).__init__()\n        self.avg_pool = nn.AdaptiveAvgPool2D(1)\n        self.conv1 = nn.Conv2D(\n            in_channels=in_channels,\n            out_channels=in_channels // reduction,\n            kernel_size=1,\n            stride=1,\n            padding=0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "peekOfCode": "def make_divisible(v, divisor=8, min_value=None):\n    if min_value is None:\n        min_value = divisor\n    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)\n    if new_v < 0.9 * v:\n        new_v += divisor\n    return new_v\nclass MobileNetV3(nn.Layer):\n    def __init__(self,\n                 in_channels=3,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "peekOfCode": "__all__ = ['MobileNetV3']\ndef make_divisible(v, divisor=8, min_value=None):\n    if min_value is None:\n        min_value = divisor\n    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)\n    if new_v < 0.9 * v:\n        new_v += divisor\n    return new_v\nclass MobileNetV3(nn.Layer):\n    def __init__(self,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 filter_size,\n                 num_filters,\n                 stride,\n                 num_groups=1):\n        super().__init__()\n        self.conv = Conv2D(\n            in_channels=num_channels,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "DepthwiseSeparable",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "class DepthwiseSeparable(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 num_filters,\n                 stride,\n                 dw_size=3,\n                 use_se=False):\n        super().__init__()\n        self.use_se = use_se\n        self.dw_conv = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "SEModule",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "class SEModule(nn.Layer):\n    def __init__(self, channel, reduction=4):\n        super().__init__()\n        self.avg_pool = AdaptiveAvgPool2D(1)\n        self.conv1 = Conv2D(\n            in_channels=channel,\n            out_channels=channel // reduction,\n            kernel_size=1,\n            stride=1,\n            padding=0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "PPLCNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "class PPLCNet(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 scale=1.0,\n                 pretrained=False,\n                 use_ssld=False):\n        super().__init__()\n        self.out_channels = [\n            int(NET_CONFIG[\"blocks3\"][-1][2] * scale),\n            int(NET_CONFIG[\"blocks4\"][-1][2] * scale),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "def make_divisible(v, divisor=8, min_value=None):\n    if min_value is None:\n        min_value = divisor\n    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)\n    if new_v < 0.9 * v:\n        new_v += divisor\n    return new_v\nclass ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 num_channels,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "MODEL_URLS",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "MODEL_URLS = {\n    \"PPLCNet_x0.25\":\n    \"https://paddle-imagenet-models-name.bj.bcebos.com/dygraph/legendary_models/PPLCNet_x0_25_pretrained.pdparams\",\n    \"PPLCNet_x0.35\":\n    \"https://paddle-imagenet-models-name.bj.bcebos.com/dygraph/legendary_models/PPLCNet_x0_35_pretrained.pdparams\",\n    \"PPLCNet_x0.5\":\n    \"https://paddle-imagenet-models-name.bj.bcebos.com/dygraph/legendary_models/PPLCNet_x0_5_pretrained.pdparams\",\n    \"PPLCNet_x0.75\":\n    \"https://paddle-imagenet-models-name.bj.bcebos.com/dygraph/legendary_models/PPLCNet_x0_75_pretrained.pdparams\",\n    \"PPLCNet_x1.0\":",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "MODEL_STAGES_PATTERN",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "MODEL_STAGES_PATTERN = {\n    \"PPLCNet\": [\"blocks2\", \"blocks3\", \"blocks4\", \"blocks5\", \"blocks6\"]\n}\n__all__ = list(MODEL_URLS.keys())\n# Each element(list) represents a depthwise block, which is composed of k, in_c, out_c, s, use_se.\n# k: kernel_size\n# in_c: input channel number in depthwise block\n# out_c: output channel number in depthwise block\n# s: stride in depthwise block\n# use_se: whether to use SE block",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "__all__ = list(MODEL_URLS.keys())\n# Each element(list) represents a depthwise block, which is composed of k, in_c, out_c, s, use_se.\n# k: kernel_size\n# in_c: input channel number in depthwise block\n# out_c: output channel number in depthwise block\n# s: stride in depthwise block\n# use_se: whether to use SE block\nNET_CONFIG = {\n    \"blocks2\":\n    # k, in_c, out_c, s, use_se",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "NET_CONFIG",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "peekOfCode": "NET_CONFIG = {\n    \"blocks2\":\n    # k, in_c, out_c, s, use_se\n    [[3, 16, 32, 1, False]],\n    \"blocks3\": [[3, 32, 64, 2, False], [3, 64, 64, 1, False]],\n    \"blocks4\": [[3, 64, 128, 2, False], [3, 128, 128, 1, False]],\n    \"blocks5\":\n    [[3, 128, 256, 2, False], [5, 256, 256, 1, False], [5, 256, 256, 1, False],\n     [5, 256, 256, 1, False], [5, 256, 256, 1, False], [5, 256, 256, 1, False]],\n    \"blocks6\": [[5, 256, 512, 2, True], [5, 512, 512, 1, True]]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_pp_lcnet",
        "documentation": {}
    },
    {
        "label": "BottleneckBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "peekOfCode": "class BottleneckBlock(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 num_filters,\n                 stride,\n                 shortcut=True,\n                 is_dcn=False):\n        super(BottleneckBlock, self).__init__()\n        self.conv0 = ConvBNLayer(\n            in_channels=num_channels,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 num_filters,\n                 stride,\n                 shortcut=True,\n                 name=None):\n        super(BasicBlock, self).__init__()\n        self.stride = stride\n        self.conv0 = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "documentation": {}
    },
    {
        "label": "ResNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "peekOfCode": "class ResNet(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 layers=50,\n                 out_indices=None,\n                 dcn_stage=None):\n        super(ResNet, self).__init__()\n        self.layers = layers\n        self.input_image_channel = in_channels\n        supported_layers = [18, 34, 50, 101, 152]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet",
        "documentation": {}
    },
    {
        "label": "DeformableConvV2",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "peekOfCode": "class DeformableConvV2(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 padding=0,\n                 dilation=1,\n                 groups=1,\n                 weight_attr=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 groups=1,\n                 dcn_groups=1,\n                 is_vd_mode=False,\n                 act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "documentation": {}
    },
    {
        "label": "BottleneckBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "peekOfCode": "class BottleneckBlock(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            stride,\n            shortcut=True,\n            if_first=False,\n            is_dcn=False, ):\n        super(BottleneckBlock, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            stride,\n            shortcut=True,\n            if_first=False, ):\n        super(BasicBlock, self).__init__()\n        self.stride = stride",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "documentation": {}
    },
    {
        "label": "ResNet_vd",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "peekOfCode": "class ResNet_vd(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 layers=50,\n                 dcn_stage=None,\n                 out_indices=None,\n                 **kwargs):\n        super(ResNet_vd, self).__init__()\n        self.layers = layers\n        supported_layers = [18, 34, 50, 101, 152, 200]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "peekOfCode": "__all__ = [\"ResNet_vd\", \"ConvBNLayer\", \"DeformableConvV2\"]\nclass DeformableConvV2(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 padding=0,\n                 dilation=1,\n                 groups=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            kernel_size,\n            stride=1,\n            groups=1,\n            is_vd_mode=False,\n            act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "documentation": {}
    },
    {
        "label": "BottleneckBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "peekOfCode": "class BottleneckBlock(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 stride,\n                 shortcut=True,\n                 if_first=False,\n                 name=None):\n        super(BottleneckBlock, self).__init__()\n        self.conv0 = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 stride,\n                 shortcut=True,\n                 if_first=False,\n                 name=None):\n        super(BasicBlock, self).__init__()\n        self.stride = stride",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "documentation": {}
    },
    {
        "label": "ResNet_SAST",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "peekOfCode": "class ResNet_SAST(nn.Layer):\n    def __init__(self, in_channels=3, layers=50, **kwargs):\n        super(ResNet_SAST, self).__init__()\n        self.layers = layers\n        supported_layers = [18, 34, 50, 101, 152, 200]\n        assert layers in supported_layers, \\\n            \"supported layers are {} but input layer is {}\".format(\n                supported_layers, layers)\n        if layers == 18:\n            depth = [2, 2, 2, 2]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "peekOfCode": "__all__ = [\"ResNet_SAST\"]\nclass ConvBNLayer(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            kernel_size,\n            stride=1,\n            groups=1,\n            is_vd_mode=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.det_resnet_vd_sast",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            kernel_size,\n            stride=1,\n            groups=1,\n            is_vd_mode=False,\n            act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "documentation": {}
    },
    {
        "label": "BottleneckBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "peekOfCode": "class BottleneckBlock(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 stride,\n                 shortcut=True,\n                 if_first=False,\n                 name=None):\n        super(BottleneckBlock, self).__init__()\n        self.conv0 = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 stride,\n                 shortcut=True,\n                 if_first=False,\n                 name=None):\n        super(BasicBlock, self).__init__()\n        self.stride = stride",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "documentation": {}
    },
    {
        "label": "ResNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "peekOfCode": "class ResNet(nn.Layer):\n    def __init__(self, in_channels=3, layers=50, **kwargs):\n        super(ResNet, self).__init__()\n        self.layers = layers\n        supported_layers = [18, 34, 50, 101, 152, 200]\n        assert layers in supported_layers, \\\n            \"supported layers are {} but input layer is {}\".format(\n                supported_layers, layers)\n        if layers == 18:\n            depth = [2, 2, 2, 2]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "peekOfCode": "__all__ = [\"ResNet\"]\nclass ConvBNLayer(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            kernel_size,\n            stride=1,\n            groups=1,\n            is_vd_mode=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.e2e_resnet_vd_pg",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "peekOfCode": "class Encoder(nn.Layer):\n    def __init__(self, num_channels, num_filters):\n        super(Encoder, self).__init__()\n        self.conv1 = nn.Conv2D(\n            num_channels,\n            num_filters,\n            kernel_size=3,\n            stride=1,\n            padding=1,\n            bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "peekOfCode": "class Decoder(nn.Layer):\n    def __init__(self, num_channels, num_filters):\n        super(Decoder, self).__init__()\n        self.conv1 = nn.Conv2D(\n            num_channels,\n            num_filters,\n            kernel_size=3,\n            stride=1,\n            padding=1,\n            bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "documentation": {}
    },
    {
        "label": "UNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "peekOfCode": "class UNet(nn.Layer):\n    def __init__(self):\n        super(UNet, self).__init__()\n        self.down1 = Encoder(num_channels=3, num_filters=16)\n        self.down2 = Encoder(num_channels=16, num_filters=32)\n        self.down3 = Encoder(num_channels=32, num_filters=64)\n        self.down4 = Encoder(num_channels=64, num_filters=128)\n        self.down5 = Encoder(num_channels=128, num_filters=256)\n        self.up1 = Decoder(32, 16)\n        self.up2 = Decoder(64, 32)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "documentation": {}
    },
    {
        "label": "Kie_backbone",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "peekOfCode": "class Kie_backbone(nn.Layer):\n    def __init__(self, in_channels, **kwargs):\n        super(Kie_backbone, self).__init__()\n        self.out_channels = 16\n        self.img_feat = UNet()\n        self.maxpool = nn.MaxPool2D(kernel_size=7)\n    def bbox2roi(self, bbox_list):\n        rois_list = []\n        rois_num = []\n        for img_id, bboxes in enumerate(bbox_list):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "peekOfCode": "__all__ = [\"Kie_backbone\"]\nclass Encoder(nn.Layer):\n    def __init__(self, num_channels, num_filters):\n        super(Encoder, self).__init__()\n        self.conv1 = nn.Conv2D(\n            num_channels,\n            num_filters,\n            kernel_size=3,\n            stride=1,\n            padding=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.kie_unet_sdmgr",
        "documentation": {}
    },
    {
        "label": "Bottleneck",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "peekOfCode": "class Bottleneck(nn.Layer):\n    def __init__(self, nChannels, growthRate, use_dropout):\n        super(Bottleneck, self).__init__()\n        interChannels = 4 * growthRate\n        self.bn1 = nn.BatchNorm2D(interChannels)\n        self.conv1 = nn.Conv2D(\n            nChannels, interChannels, kernel_size=1,\n            bias_attr=None)  # Xavier initialization\n        self.bn2 = nn.BatchNorm2D(growthRate)\n        self.conv2 = nn.Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "documentation": {}
    },
    {
        "label": "SingleLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "peekOfCode": "class SingleLayer(nn.Layer):\n    def __init__(self, nChannels, growthRate, use_dropout):\n        super(SingleLayer, self).__init__()\n        self.bn1 = nn.BatchNorm2D(nChannels)\n        self.conv1 = nn.Conv2D(\n            nChannels, growthRate, kernel_size=3, padding=1, bias_attr=False)\n        self.use_dropout = use_dropout\n        self.dropout = nn.Dropout(p=0.2)\n    def forward(self, x):\n        out = self.conv1(F.relu(x))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "documentation": {}
    },
    {
        "label": "Transition",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "peekOfCode": "class Transition(nn.Layer):\n    def __init__(self, nChannels, out_channels, use_dropout):\n        super(Transition, self).__init__()\n        self.bn1 = nn.BatchNorm2D(out_channels)\n        self.conv1 = nn.Conv2D(\n            nChannels, out_channels, kernel_size=1, bias_attr=False)\n        self.use_dropout = use_dropout\n        self.dropout = nn.Dropout(p=0.2)\n    def forward(self, x):\n        out = F.relu(self.bn1(self.conv1(x)))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "documentation": {}
    },
    {
        "label": "DenseNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "peekOfCode": "class DenseNet(nn.Layer):\n    def __init__(self, growthRate, reduction, bottleneck, use_dropout,\n                 input_channel, **kwargs):\n        super(DenseNet, self).__init__()\n        nDenseBlocks = 16\n        nChannels = 2 * growthRate\n        self.conv1 = nn.Conv2D(\n            input_channel,\n            nChannels,\n            kernel_size=7,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_densenet",
        "documentation": {}
    },
    {
        "label": "BlockDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "class BlockDecoder:\n    @staticmethod\n    def _decode_block_string(block_string):\n        assert isinstance(block_string, str)\n        ops = block_string.split('_')\n        options = {}\n        for op in ops:\n            splits = re.split(r'(\\d.*)', op)\n            if len(splits) >= 2:\n                key, value = splits[:2]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "EffUtils",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "class EffUtils:\n    @staticmethod\n    def round_filters(filters, global_params):\n        \"\"\" Calculate and round number of filters based on depth multiplier. \"\"\"\n        multiplier = global_params.width_coefficient\n        if not multiplier:\n            return filters\n        divisor = global_params.depth_divisor\n        min_depth = global_params.min_depth\n        filters *= multiplier",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "MbConvBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "class MbConvBlock(nn.Layer):\n    def __init__(self, block_args):\n        super(MbConvBlock, self).__init__()\n        self._block_args = block_args\n        self.has_se = (self._block_args.se_ratio is not None) and \\\n            (0 < self._block_args.se_ratio <= 1)\n        self.id_skip = block_args.id_skip\n        # expansion phase\n        self.inp = self._block_args.input_filters\n        oup = self._block_args.input_filters * self._block_args.expand_ratio",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "EfficientNetb3_PREN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "class EfficientNetb3_PREN(nn.Layer):\n    def __init__(self, in_channels):\n        super(EfficientNetb3_PREN, self).__init__()\n        \"\"\"\n        the fllowing are efficientnetb3's superparams,\n        they means efficientnetb3 network's width, depth, resolution and \n        dropout respectively, to fit for text recognition task, the resolution \n        here is changed from 300 to 64.\n        \"\"\"\n        w, d, s, p = 1.2, 1.4, 64, 0.3",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "efficientnet",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "def efficientnet(width_coefficient=None,\n                 depth_coefficient=None,\n                 dropout_rate=0.2,\n                 drop_connect_rate=0.2,\n                 image_size=None,\n                 num_classes=1000):\n    blocks_args = [\n        'r1_k3_s11_e1_i32_o16_se0.25',\n        'r2_k3_s22_e6_i16_o24_se0.25',\n        'r2_k5_s22_e6_i24_o40_se0.25',",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "__all__ = ['EfficientNetb3']\nGlobalParams = collections.namedtuple('GlobalParams', [\n    'batch_norm_momentum', 'batch_norm_epsilon', 'dropout_rate', 'num_classes',\n    'width_coefficient', 'depth_coefficient', 'depth_divisor', 'min_depth',\n    'drop_connect_rate', 'image_size'\n])\nBlockArgs = collections.namedtuple('BlockArgs', [\n    'kernel_size', 'num_repeat', 'input_filters', 'output_filters',\n    'expand_ratio', 'id_skip', 'stride', 'se_ratio'\n])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "GlobalParams",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "GlobalParams = collections.namedtuple('GlobalParams', [\n    'batch_norm_momentum', 'batch_norm_epsilon', 'dropout_rate', 'num_classes',\n    'width_coefficient', 'depth_coefficient', 'depth_divisor', 'min_depth',\n    'drop_connect_rate', 'image_size'\n])\nBlockArgs = collections.namedtuple('BlockArgs', [\n    'kernel_size', 'num_repeat', 'input_filters', 'output_filters',\n    'expand_ratio', 'id_skip', 'stride', 'se_ratio'\n])\nclass BlockDecoder:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "BlockArgs",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "peekOfCode": "BlockArgs = collections.namedtuple('BlockArgs', [\n    'kernel_size', 'num_repeat', 'input_filters', 'output_filters',\n    'expand_ratio', 'id_skip', 'stride', 'se_ratio'\n])\nclass BlockDecoder:\n    @staticmethod\n    def _decode_block_string(block_string):\n        assert isinstance(block_string, str)\n        ops = block_string.split('_')\n        options = {}",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_efficientb3_pren",
        "documentation": {}
    },
    {
        "label": "ConvBNAct",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "class ConvBNAct(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,\n                 use_act=True):\n        super().__init__()\n        self.use_act = use_act",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "ESEModule",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "class ESEModule(nn.Layer):\n    def __init__(self, channels):\n        super().__init__()\n        self.avg_pool = AdaptiveAvgPool2D(1)\n        self.conv = Conv2D(\n            in_channels=channels,\n            out_channels=channels,\n            kernel_size=1,\n            stride=1,\n            padding=0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "HG_Block",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "class HG_Block(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            mid_channels,\n            out_channels,\n            layer_num,\n            identity=False, ):\n        super().__init__()\n        self.identity = identity",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "HG_Stage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "class HG_Stage(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 mid_channels,\n                 out_channels,\n                 block_num,\n                 layer_num,\n                 downsample=True,\n                 stride=[2, 1]):\n        super().__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "PPHGNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "class PPHGNet(nn.Layer):\n    \"\"\"\n    PPHGNet\n    Args:\n        stem_channels: list. Stem channel list of PPHGNet.\n        stage_config: dict. The configuration of each stage of PPHGNet. such as the number of channels, stride, etc.\n        layer_num: int. Number of layers of HG_Block.\n        use_last_conv: boolean. Whether to use a 1x1 convolutional layer before the classification layer.\n        class_expand: int=2048. Number of channels for the last 1x1 convolutional layer.\n        dropout_prob: float. Parameters of dropout, 0.0 means dropout is not used.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "PPHGNet_tiny",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "def PPHGNet_tiny(pretrained=False, use_ssld=False, **kwargs):\n    \"\"\"\n    PPHGNet_tiny\n    Args:\n        pretrained: bool=False or str. If `True` load pretrained parameters, `False` otherwise.\n                    If str, means the path of the pretrained model.\n        use_ssld: bool=False. Whether using distillation pretrained model when pretrained=True.\n    Returns:\n        model: nn.Layer. Specific `PPHGNet_tiny` model depends on args.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "PPHGNet_small",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "def PPHGNet_small(pretrained=False, use_ssld=False, det=False, **kwargs):\n    \"\"\"\n    PPHGNet_small\n    Args:\n        pretrained: bool=False or str. If `True` load pretrained parameters, `False` otherwise.\n                    If str, means the path of the pretrained model.\n        use_ssld: bool=False. Whether using distillation pretrained model when pretrained=True.\n    Returns:\n        model: nn.Layer. Specific `PPHGNet_small` model depends on args.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "PPHGNet_base",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "def PPHGNet_base(pretrained=False, use_ssld=True, **kwargs):\n    \"\"\"\n    PPHGNet_base\n    Args:\n        pretrained: bool=False or str. If `True` load pretrained parameters, `False` otherwise.\n                    If str, means the path of the pretrained model.\n        use_ssld: bool=False. Whether using distillation pretrained model when pretrained=True.\n    Returns:\n        model: nn.Layer. Specific `PPHGNet_base` model depends on args.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "kaiming_normal_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "kaiming_normal_ = KaimingNormal()\nzeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass ConvBNAct(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "zeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass ConvBNAct(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,\n                 use_act=True):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "ones_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "peekOfCode": "ones_ = Constant(value=1.)\nclass ConvBNAct(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,\n                 use_act=True):\n        super().__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_hgnet",
        "documentation": {}
    },
    {
        "label": "LearnableAffineBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "class LearnableAffineBlock(nn.Layer):\n    def __init__(self, scale_value=1.0, bias_value=0.0, lr_mult=1.0,\n                 lab_lr=0.1):\n        super().__init__()\n        self.scale = self.create_parameter(\n            shape=[1, ],\n            default_initializer=Constant(value=scale_value),\n            attr=ParamAttr(learning_rate=lr_mult * lab_lr))\n        self.add_parameter(\"scale\", self.scale)\n        self.bias = self.create_parameter(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,\n                 lr_mult=1.0):\n        super().__init__()\n        self.conv = Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "Act",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "class Act(nn.Layer):\n    def __init__(self, act=\"hswish\", lr_mult=1.0, lab_lr=0.1):\n        super().__init__()\n        if act == \"hswish\":\n            self.act = Hardswish()\n        else:\n            assert act == \"relu\"\n            self.act = ReLU()\n        self.lab = LearnableAffineBlock(lr_mult=lr_mult, lab_lr=lab_lr)\n    def forward(self, x):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "LearnableRepLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "class LearnableRepLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 groups=1,\n                 num_conv_branches=1,\n                 lr_mult=1.0,\n                 lab_lr=0.1):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "SELayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "class SELayer(nn.Layer):\n    def __init__(self, channel, reduction=4, lr_mult=1.0):\n        super().__init__()\n        self.avg_pool = AdaptiveAvgPool2D(1)\n        self.conv1 = Conv2D(\n            in_channels=channel,\n            out_channels=channel // reduction,\n            kernel_size=1,\n            stride=1,\n            padding=0,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "LCNetV3Block",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "class LCNetV3Block(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 stride,\n                 dw_size,\n                 use_se=False,\n                 conv_kxk_num=4,\n                 lr_mult=1.0,\n                 lab_lr=0.1):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "PPLCNetV3",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "class PPLCNetV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,\n                 conv_kxk_num=4,\n                 lr_mult_list=[1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n                 lab_lr=0.1,\n                 det=False,\n                 **kwargs):\n        super().__init__()\n        self.scale = scale",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "def make_divisible(v, divisor=16, min_value=None):\n    if min_value is None:\n        min_value = divisor\n    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)\n    if new_v < 0.9 * v:\n        new_v += divisor\n    return new_v\nclass LearnableAffineBlock(nn.Layer):\n    def __init__(self, scale_value=1.0, bias_value=0.0, lr_mult=1.0,\n                 lab_lr=0.1):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "NET_CONFIG_det",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "NET_CONFIG_det = {\n    \"blocks2\":\n    #k, in_c, out_c, s, use_se\n    [[3, 16, 32, 1, False]],\n    \"blocks3\": [[3, 32, 64, 2, False], [3, 64, 64, 1, False]],\n    \"blocks4\": [[3, 64, 128, 2, False], [3, 128, 128, 1, False]],\n    \"blocks5\":\n    [[3, 128, 256, 2, False], [5, 256, 256, 1, False], [5, 256, 256, 1, False],\n     [5, 256, 256, 1, False], [5, 256, 256, 1, False]],\n    \"blocks6\": [[5, 256, 512, 2, True], [5, 512, 512, 1, True],",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "NET_CONFIG_rec",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "peekOfCode": "NET_CONFIG_rec = {\n    \"blocks2\":\n    #k, in_c, out_c, s, use_se\n    [[3, 16, 32, 1, False]],\n    \"blocks3\": [[3, 32, 64, 1, False], [3, 64, 64, 1, False]],\n    \"blocks4\": [[3, 64, 128, (2, 1), False], [3, 128, 128, 1, False]],\n    \"blocks5\":\n    [[3, 128, 256, (1, 2), False], [5, 256, 256, 1, False],\n     [5, 256, 256, 1, False], [5, 256, 256, 1, False], [5, 256, 256, 1, False]],\n    \"blocks6\": [[5, 256, 512, (2, 1), True], [5, 512, 512, 1, True],",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_lcnetv3",
        "documentation": {}
    },
    {
        "label": "MaxGroupPooling",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class MaxGroupPooling(nn.Layer):\n    def __init__(self, channel_per_group=2):\n        super(MaxGroupPooling, self).__init__()\n        self.channel_per_group = channel_per_group\n    def forward(self, x):\n        if self.channel_per_group == 1:\n            return x\n        # max op\n        b, c, h, w = x.shape\n        # reshape",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "SpatialSepConvSF",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class SpatialSepConvSF(nn.Layer):\n    def __init__(self, inp, oups, kernel_size, stride):\n        super(SpatialSepConvSF, self).__init__()\n        oup1, oup2 = oups\n        self.conv = nn.Sequential(\n            nn.Conv2D(\n                inp,\n                oup1, (kernel_size, 1), (stride, 1), (kernel_size // 2, 0),\n                bias_attr=False,\n                groups=1),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "ChannelShuffle",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class ChannelShuffle(nn.Layer):\n    def __init__(self, groups):\n        super(ChannelShuffle, self).__init__()\n        self.groups = groups\n    def forward(self, x):\n        b, c, h, w = x.shape\n        channels_per_group = c // self.groups\n        # reshape\n        x = paddle.reshape(x, [b, self.groups, channels_per_group, h, w])\n        x = paddle.transpose(x, (0, 2, 1, 3, 4))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "StemLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class StemLayer(nn.Layer):\n    def __init__(self, inp, oup, stride, groups=(4, 4)):\n        super(StemLayer, self).__init__()\n        g1, g2 = groups\n        self.stem = nn.Sequential(\n            SpatialSepConvSF(inp, groups, 3, stride),\n            MaxGroupPooling(2) if g1 * g2 == 2 * oup else nn.ReLU6())\n    def forward(self, x):\n        out = self.stem(x)\n        return out",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "DepthSpatialSepConv",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class DepthSpatialSepConv(nn.Layer):\n    def __init__(self, inp, expand, kernel_size, stride):\n        super(DepthSpatialSepConv, self).__init__()\n        exp1, exp2 = expand\n        hidden_dim = inp * exp1\n        oup = inp * exp1 * exp2\n        self.conv = nn.Sequential(\n            nn.Conv2D(\n                inp,\n                inp * exp1, (kernel_size, 1), (stride, 1),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "GroupConv",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class GroupConv(nn.Layer):\n    def __init__(self, inp, oup, groups=2):\n        super(GroupConv, self).__init__()\n        self.inp = inp\n        self.oup = oup\n        self.groups = groups\n        self.conv = nn.Sequential(\n            nn.Conv2D(\n                inp, oup, 1, 1, 0, bias_attr=False, groups=self.groups[0]),\n            nn.BatchNorm2D(oup))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "DepthConv",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class DepthConv(nn.Layer):\n    def __init__(self, inp, oup, kernel_size, stride):\n        super(DepthConv, self).__init__()\n        self.conv = nn.Sequential(\n            nn.Conv2D(\n                inp,\n                oup,\n                kernel_size,\n                stride,\n                kernel_size // 2,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "DYShiftMax",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class DYShiftMax(nn.Layer):\n    def __init__(self,\n                 inp,\n                 oup,\n                 reduction=4,\n                 act_max=1.0,\n                 act_relu=True,\n                 init_a=[0.0, 0.0],\n                 init_b=[0.0, 0.0],\n                 relu_before_pool=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "DYMicroBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class DYMicroBlock(nn.Layer):\n    def __init__(self,\n                 inp,\n                 oup,\n                 kernel_size=3,\n                 stride=1,\n                 ch_exp=(2, 2),\n                 ch_per_group=4,\n                 groups_1x1=(1, 1),\n                 depthsep=True,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "MicroNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "class MicroNet(nn.Layer):\n    \"\"\"\n        the MicroNet backbone network for recognition module.\n        Args:\n            mode(str): {'M0', 'M1', 'M2', 'M3'} \n                Four models are proposed based on four different computational costs (4M, 6M, 12M, 21M MAdds)\n                Default: 'M3'.\n    \"\"\"\n    def __init__(self, mode='M3', **kwargs):\n        super(MicroNet, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "get_micronet_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "def get_micronet_config(mode):\n    return eval(mode + '_cfgs')\nclass MaxGroupPooling(nn.Layer):\n    def __init__(self, channel_per_group=2):\n        super(MaxGroupPooling, self).__init__()\n        self.channel_per_group = channel_per_group\n    def forward(self, x):\n        if self.channel_per_group == 1:\n            return x\n        # max op",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "M0_cfgs",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "M0_cfgs = [\n    # s, n, c, ks, c1, c2, g1, g2, c3, g3, g4, y1, y2, y3, r\n    [2, 1, 8, 3, 2, 2, 0, 4, 8, 2, 2, 2, 0, 1, 1],\n    [2, 1, 12, 3, 2, 2, 0, 8, 12, 4, 4, 2, 2, 1, 1],\n    [2, 1, 16, 5, 2, 2, 0, 12, 16, 4, 4, 2, 2, 1, 1],\n    [1, 1, 32, 5, 1, 4, 4, 4, 32, 4, 4, 2, 2, 1, 1],\n    [2, 1, 64, 5, 1, 4, 8, 8, 64, 8, 8, 2, 2, 1, 1],\n    [1, 1, 96, 3, 1, 4, 8, 8, 96, 8, 8, 2, 2, 1, 2],\n    [1, 1, 384, 3, 1, 4, 12, 12, 0, 0, 0, 2, 2, 1, 2],\n]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "M1_cfgs",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "M1_cfgs = [\n    # s, n, c, ks, c1, c2, g1, g2, c3, g3, g4\n    [2, 1, 8, 3, 2, 2, 0, 6, 8, 2, 2, 2, 0, 1, 1],\n    [2, 1, 16, 3, 2, 2, 0, 8, 16, 4, 4, 2, 2, 1, 1],\n    [2, 1, 16, 5, 2, 2, 0, 16, 16, 4, 4, 2, 2, 1, 1],\n    [1, 1, 32, 5, 1, 6, 4, 4, 32, 4, 4, 2, 2, 1, 1],\n    [2, 1, 64, 5, 1, 6, 8, 8, 64, 8, 8, 2, 2, 1, 1],\n    [1, 1, 96, 3, 1, 6, 8, 8, 96, 8, 8, 2, 2, 1, 2],\n    [1, 1, 576, 3, 1, 6, 12, 12, 0, 0, 0, 2, 2, 1, 2],\n]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "M2_cfgs",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "M2_cfgs = [\n    # s, n, c, ks, c1, c2, g1, g2, c3, g3, g4\n    [2, 1, 12, 3, 2, 2, 0, 8, 12, 4, 4, 2, 0, 1, 1],\n    [2, 1, 16, 3, 2, 2, 0, 12, 16, 4, 4, 2, 2, 1, 1],\n    [1, 1, 24, 3, 2, 2, 0, 16, 24, 4, 4, 2, 2, 1, 1],\n    [2, 1, 32, 5, 1, 6, 6, 6, 32, 4, 4, 2, 2, 1, 1],\n    [1, 1, 32, 5, 1, 6, 8, 8, 32, 4, 4, 2, 2, 1, 2],\n    [1, 1, 64, 5, 1, 6, 8, 8, 64, 8, 8, 2, 2, 1, 2],\n    [2, 1, 96, 5, 1, 6, 8, 8, 96, 8, 8, 2, 2, 1, 2],\n    [1, 1, 128, 3, 1, 6, 12, 12, 128, 8, 8, 2, 2, 1, 2],",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "M3_cfgs",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "peekOfCode": "M3_cfgs = [\n    # s, n, c, ks, c1, c2, g1, g2, c3, g3, g4\n    [2, 1, 16, 3, 2, 2, 0, 12, 16, 4, 4, 0, 2, 0, 1],\n    [2, 1, 24, 3, 2, 2, 0, 16, 24, 4, 4, 0, 2, 0, 1],\n    [1, 1, 24, 3, 2, 2, 0, 24, 24, 4, 4, 0, 2, 0, 1],\n    [2, 1, 32, 5, 1, 6, 6, 6, 32, 4, 4, 0, 2, 0, 1],\n    [1, 1, 32, 5, 1, 6, 8, 8, 32, 4, 4, 0, 2, 0, 2],\n    [1, 1, 64, 5, 1, 6, 8, 8, 48, 8, 8, 0, 2, 0, 2],\n    [1, 1, 80, 5, 1, 6, 8, 8, 80, 8, 8, 0, 2, 0, 2],\n    [1, 1, 80, 5, 1, 6, 10, 10, 80, 8, 8, 0, 2, 0, 2],",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_micronet",
        "documentation": {}
    },
    {
        "label": "MobileNetV3",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mobilenet_v3",
        "peekOfCode": "class MobileNetV3(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 model_name='small',\n                 scale=0.5,\n                 large_stride=None,\n                 small_stride=None,\n                 disable_se=False,\n                 **kwargs):\n        super(MobileNetV3, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mobilenet_v3",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mobilenet_v3",
        "peekOfCode": "__all__ = ['MobileNetV3']\nclass MobileNetV3(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 model_name='small',\n                 scale=0.5,\n                 large_stride=None,\n                 small_stride=None,\n                 disable_se=False,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mobilenet_v3",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 filter_size,\n                 num_filters,\n                 stride,\n                 padding,\n                 channels=None,\n                 num_groups=1,\n                 act='hard_swish'):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "documentation": {}
    },
    {
        "label": "DepthwiseSeparable",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "peekOfCode": "class DepthwiseSeparable(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 num_filters1,\n                 num_filters2,\n                 num_groups,\n                 stride,\n                 scale,\n                 dw_size=3,\n                 padding=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "documentation": {}
    },
    {
        "label": "MobileNetV1Enhance",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "peekOfCode": "class MobileNetV1Enhance(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 scale=0.5,\n                 last_conv_stride=1,\n                 last_pool_type='max',\n                 last_pool_kernel_size=[3, 2],\n                 **kwargs):\n        super().__init__()\n        self.scale = scale",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "documentation": {}
    },
    {
        "label": "SEModule",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "peekOfCode": "class SEModule(nn.Layer):\n    def __init__(self, channel, reduction=4):\n        super(SEModule, self).__init__()\n        self.avg_pool = AdaptiveAvgPool2D(1)\n        self.conv1 = Conv2D(\n            in_channels=channel,\n            out_channels=channel // reduction,\n            kernel_size=1,\n            stride=1,\n            padding=0,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_mv1_enhance",
        "documentation": {}
    },
    {
        "label": "MTB",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_nrtr_mtb",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_nrtr_mtb",
        "peekOfCode": "class MTB(nn.Layer):\n    def __init__(self, cnn_num, in_channels):\n        super(MTB, self).__init__()\n        self.block = nn.Sequential()\n        self.out_channels = in_channels\n        self.cnn_num = cnn_num\n        if self.cnn_num == 2:\n            for i in range(self.cnn_num):\n                self.block.add_sublayer(\n                    'conv_{}'.format(i),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_nrtr_mtb",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    expansion = 1\n    def __init__(self, in_channels, channels, stride=1, downsample=False, conv_weight_attr=None, bn_weight_attr=None):\n        super().__init__()\n        self.conv1 = conv3x3(in_channels, channels, stride, \n            conv_weight_attr=conv_weight_attr)\n        self.bn1 = nn.BatchNorm2D(channels, weight_attr=bn_weight_attr)\n        self.relu = nn.ReLU()\n        self.conv2 = conv3x3(channels, channels,\n            conv_weight_attr=conv_weight_attr)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "documentation": {}
    },
    {
        "label": "ResNet31",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "peekOfCode": "class ResNet31(nn.Layer):\n    '''\n    Args:\n        in_channels (int): Number of channels of input image tensor.\n        layers (list[int]): List of BasicBlock number for each stage.\n        channels (list[int]): List of out_channels of Conv2d layer.\n        out_indices (None | Sequence[int]): Indices of output stages.\n        last_stage_pool (bool): If True, add `MaxPool2d` layer to last stage.\n        init_type (None | str): the config to control the initialization.\n    '''",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "documentation": {}
    },
    {
        "label": "conv3x3",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "peekOfCode": "def conv3x3(in_channel, out_channel, stride=1, conv_weight_attr=None):\n    return nn.Conv2D(\n        in_channel,\n        out_channel,\n        kernel_size=3,\n        stride=stride,\n        padding=1,\n        weight_attr=conv_weight_attr,\n        bias_attr=False)\nclass BasicBlock(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "peekOfCode": "__all__ = [\"ResNet31\"]\ndef conv3x3(in_channel, out_channel, stride=1, conv_weight_attr=None):\n    return nn.Conv2D(\n        in_channel,\n        out_channel,\n        kernel_size=3,\n        stride=stride,\n        padding=1,\n        weight_attr=conv_weight_attr,\n        bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_31",
        "documentation": {}
    },
    {
        "label": "ResNet32",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "peekOfCode": "class ResNet32(nn.Layer):\n    \"\"\"\n    Feature Extractor is proposed in  FAN Ref [1]\n    Ref [1]: Focusing Attention: Towards Accurate Text Recognition in Neural Images ICCV-2017\n    \"\"\"\n    def __init__(self, in_channels, out_channels=512):\n        \"\"\"\n        Args:\n            in_channels (int): input channel\n            output_channel (int): output channel",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    \"\"\"Res-net Basic Block\"\"\"\n    expansion = 1\n    def __init__(self, inplanes, planes,\n                 stride=1, downsample=None,\n                 norm_type='BN', **kwargs):\n        \"\"\"\n        Args:\n            inplanes (int): input channel\n            planes (int): channels of the middle feature",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "documentation": {}
    },
    {
        "label": "ResNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "peekOfCode": "class ResNet(nn.Layer):\n    \"\"\"Res-Net network structure\"\"\"\n    def __init__(self, input_channel,\n                 output_channel, block, layers):\n        \"\"\"\n        Args:\n            input_channel (int): input channel\n            output_channel (int): output channel\n            block (BasicBlock): convolution block\n            layers (list): layers of the block",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "peekOfCode": "__all__ = [\"ResNet32\"]\nconv_weight_attr = nn.initializer.KaimingNormal()\nclass ResNet32(nn.Layer):\n    \"\"\"\n    Feature Extractor is proposed in  FAN Ref [1]\n    Ref [1]: Focusing Attention: Towards Accurate Text Recognition in Neural Images ICCV-2017\n    \"\"\"\n    def __init__(self, in_channels, out_channels=512):\n        \"\"\"\n        Args:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "documentation": {}
    },
    {
        "label": "conv_weight_attr",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "peekOfCode": "conv_weight_attr = nn.initializer.KaimingNormal()\nclass ResNet32(nn.Layer):\n    \"\"\"\n    Feature Extractor is proposed in  FAN Ref [1]\n    Ref [1]: Focusing Attention: Towards Accurate Text Recognition in Neural Images ICCV-2017\n    \"\"\"\n    def __init__(self, in_channels, out_channels=512):\n        \"\"\"\n        Args:\n            in_channels (int): input channel",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_32",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    expansion = 1\n    def __init__(self, in_channels, channels, stride=1, downsample=None):\n        super().__init__()\n        self.conv1 = conv1x1(in_channels, channels)\n        self.bn1 = nn.BatchNorm2D(channels)\n        self.relu = nn.ReLU()\n        self.conv2 = conv3x3(channels, channels, stride)\n        self.bn2 = nn.BatchNorm2D(channels)\n        self.downsample = downsample",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "documentation": {}
    },
    {
        "label": "ResNet45",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "peekOfCode": "class ResNet45(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 block=BasicBlock,\n                 layers=[3, 4, 6, 6, 3],\n                 strides=[2, 1, 2, 1, 1]):\n        self.inplanes = 32\n        super(ResNet45, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "documentation": {}
    },
    {
        "label": "conv1x1",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "peekOfCode": "def conv1x1(in_planes, out_planes, stride=1):\n    return nn.Conv2D(\n        in_planes,\n        out_planes,\n        kernel_size=1,\n        stride=1,\n        weight_attr=ParamAttr(initializer=KaimingNormal()),\n        bias_attr=False)\ndef conv3x3(in_channel, out_channel, stride=1):\n    return nn.Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "documentation": {}
    },
    {
        "label": "conv3x3",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "peekOfCode": "def conv3x3(in_channel, out_channel, stride=1):\n    return nn.Conv2D(\n        in_channel,\n        out_channel,\n        kernel_size=3,\n        stride=stride,\n        padding=1,\n        weight_attr=ParamAttr(initializer=KaimingNormal()),\n        bias_attr=False)\nclass BasicBlock(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "peekOfCode": "__all__ = [\"ResNet45\"]\ndef conv1x1(in_planes, out_planes, stride=1):\n    return nn.Conv2D(\n        in_planes,\n        out_planes,\n        kernel_size=1,\n        stride=1,\n        weight_attr=ParamAttr(initializer=KaimingNormal()),\n        bias_attr=False)\ndef conv3x3(in_channel, out_channel, stride=1):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_45",
        "documentation": {}
    },
    {
        "label": "AsterBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "peekOfCode": "class AsterBlock(nn.Layer):\n    def __init__(self, inplanes, planes, stride=1, downsample=None):\n        super(AsterBlock, self).__init__()\n        self.conv1 = conv1x1(inplanes, planes, stride)\n        self.bn1 = nn.BatchNorm2D(planes)\n        self.relu = nn.ReLU()\n        self.conv2 = conv3x3(planes, planes)\n        self.bn2 = nn.BatchNorm2D(planes)\n        self.downsample = downsample\n        self.stride = stride",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "documentation": {}
    },
    {
        "label": "ResNet_ASTER",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "peekOfCode": "class ResNet_ASTER(nn.Layer):\n    \"\"\"For aster or crnn\"\"\"\n    def __init__(self, with_lstm=True, n_group=1, in_channels=3):\n        super(ResNet_ASTER, self).__init__()\n        self.with_lstm = with_lstm\n        self.n_group = n_group\n        self.layer0 = nn.Sequential(\n            nn.Conv2D(\n                in_channels,\n                32,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "documentation": {}
    },
    {
        "label": "conv3x3",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "peekOfCode": "def conv3x3(in_planes, out_planes, stride=1):\n    \"\"\"3x3 convolution with padding\"\"\"\n    return nn.Conv2D(\n        in_planes,\n        out_planes,\n        kernel_size=3,\n        stride=stride,\n        padding=1,\n        bias_attr=False)\ndef conv1x1(in_planes, out_planes, stride=1):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "documentation": {}
    },
    {
        "label": "conv1x1",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "peekOfCode": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2D(\n        in_planes, out_planes, kernel_size=1, stride=stride, bias_attr=False)\ndef get_sinusoid_encoding(n_position, feat_dim, wave_length=10000):\n    # [n_position]\n    positions = paddle.arange(0, n_position)\n    # [feat_dim]\n    dim_range = paddle.arange(0, feat_dim)\n    dim_range = paddle.pow(wave_length, 2 * (dim_range // 2) / feat_dim)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "documentation": {}
    },
    {
        "label": "get_sinusoid_encoding",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "peekOfCode": "def get_sinusoid_encoding(n_position, feat_dim, wave_length=10000):\n    # [n_position]\n    positions = paddle.arange(0, n_position)\n    # [feat_dim]\n    dim_range = paddle.arange(0, feat_dim)\n    dim_range = paddle.pow(wave_length, 2 * (dim_range // 2) / feat_dim)\n    # [n_position, feat_dim]\n    angles = paddle.unsqueeze(\n        positions, axis=1) / paddle.unsqueeze(\n            dim_range, axis=0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_aster",
        "documentation": {}
    },
    {
        "label": "ResNetFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "peekOfCode": "class ResNetFPN(nn.Layer):\n    def __init__(self, in_channels=1, layers=50, **kwargs):\n        super(ResNetFPN, self).__init__()\n        supported_layers = {\n            18: {\n                'depth': [2, 2, 2, 2],\n                'block_class': BasicBlock\n            },\n            34: {\n                'depth': [3, 4, 6, 3],",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 groups=1,\n                 act=None,\n                 name=None):\n        super(ConvBNLayer, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "documentation": {}
    },
    {
        "label": "ShortCut",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "peekOfCode": "class ShortCut(nn.Layer):\n    def __init__(self, in_channels, out_channels, stride, name, is_first=False):\n        super(ShortCut, self).__init__()\n        self.use_conv = True\n        if in_channels != out_channels or stride != 1 or is_first == True:\n            if stride == (1, 1):\n                self.conv = ConvBNLayer(\n                    in_channels, out_channels, 1, 1, name=name)\n            else:  # stride==(2,2)\n                self.conv = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "documentation": {}
    },
    {
        "label": "BottleneckBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "peekOfCode": "class BottleneckBlock(nn.Layer):\n    def __init__(self, in_channels, out_channels, stride, name):\n        super(BottleneckBlock, self).__init__()\n        self.conv0 = ConvBNLayer(\n            in_channels=in_channels,\n            out_channels=out_channels,\n            kernel_size=1,\n            act='relu',\n            name=name + \"_branch2a\")\n        self.conv1 = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    def __init__(self, in_channels, out_channels, stride, name, is_first):\n        super(BasicBlock, self).__init__()\n        self.conv0 = ConvBNLayer(\n            in_channels=in_channels,\n            out_channels=out_channels,\n            kernel_size=3,\n            act='relu',\n            stride=stride,\n            name=name + \"_branch2a\")",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "peekOfCode": "__all__ = [\"ResNetFPN\"]\nclass ResNetFPN(nn.Layer):\n    def __init__(self, in_channels=1, layers=50, **kwargs):\n        super(ResNetFPN, self).__init__()\n        supported_layers = {\n            18: {\n                'depth': [2, 2, 2, 2],\n                'block_class': BasicBlock\n            },\n            34: {",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_fpn",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    \"\"\"Res-net Basic Block\"\"\"\n    expansion = 1\n    def __init__(self,\n                 inplanes,\n                 planes,\n                 stride=1,\n                 downsample=None,\n                 norm_type='BN',\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "documentation": {}
    },
    {
        "label": "ResNetRFL",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "peekOfCode": "class ResNetRFL(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels=512,\n                 use_cnt=True,\n                 use_seq=True):\n        \"\"\"\n        Args:\n            in_channels (int): input channel\n            out_channels (int): output channel",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "documentation": {}
    },
    {
        "label": "ResNetBase",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "peekOfCode": "class ResNetBase(nn.Layer):\n    def __init__(self, in_channels, out_channels, block, layers):\n        super(ResNetBase, self).__init__()\n        self.out_channels_block = [\n            int(out_channels / 4), int(out_channels / 2), out_channels,\n            out_channels\n        ]\n        self.inplanes = int(out_channels / 8)\n        self.conv0_1 = nn.Conv2D(\n            in_channels,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "documentation": {}
    },
    {
        "label": "RFLBase",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "peekOfCode": "class RFLBase(nn.Layer):\n    \"\"\" Reciprocal feature learning share backbone network\"\"\"\n    def __init__(self, in_channels, out_channels=512):\n        super(RFLBase, self).__init__()\n        self.ConvNet = ResNetBase(in_channels, out_channels, BasicBlock,\n                                  [1, 2, 5, 3])\n    def forward(self, inputs):\n        return self.ConvNet(inputs)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "documentation": {}
    },
    {
        "label": "kaiming_init_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "peekOfCode": "kaiming_init_ = KaimingNormal()\nzeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass BasicBlock(nn.Layer):\n    \"\"\"Res-net Basic Block\"\"\"\n    expansion = 1\n    def __init__(self,\n                 inplanes,\n                 planes,\n                 stride=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "peekOfCode": "zeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass BasicBlock(nn.Layer):\n    \"\"\"Res-net Basic Block\"\"\"\n    expansion = 1\n    def __init__(self,\n                 inplanes,\n                 planes,\n                 stride=1,\n                 downsample=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "documentation": {}
    },
    {
        "label": "ones_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "peekOfCode": "ones_ = Constant(value=1.)\nclass BasicBlock(nn.Layer):\n    \"\"\"Res-net Basic Block\"\"\"\n    expansion = 1\n    def __init__(self,\n                 inplanes,\n                 planes,\n                 stride=1,\n                 downsample=None,\n                 norm_type='BN',",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_rfl",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            kernel_size,\n            stride=1,\n            groups=1,\n            is_vd_mode=False,\n            act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "documentation": {}
    },
    {
        "label": "BottleneckBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "peekOfCode": "class BottleneckBlock(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 stride,\n                 shortcut=True,\n                 if_first=False,\n                 name=None):\n        super(BottleneckBlock, self).__init__()\n        self.conv0 = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 stride,\n                 shortcut=True,\n                 if_first=False,\n                 name=None):\n        super(BasicBlock, self).__init__()\n        self.stride = stride",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "documentation": {}
    },
    {
        "label": "ResNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "peekOfCode": "class ResNet(nn.Layer):\n    def __init__(self, in_channels=3, layers=50, **kwargs):\n        super(ResNet, self).__init__()\n        self.layers = layers\n        supported_layers = [18, 34, 50, 101, 152, 200]\n        assert layers in supported_layers, \\\n            \"supported layers are {} but input layer is {}\".format(\n                supported_layers, layers)\n        if layers == 18:\n            depth = [2, 2, 2, 2]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "peekOfCode": "__all__ = [\"ResNet\"]\nclass ConvBNLayer(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            out_channels,\n            kernel_size,\n            stride=1,\n            groups=1,\n            is_vd_mode=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_resnet_vd",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_shallow_cnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_shallow_cnn",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 filter_size,\n                 num_filters,\n                 stride,\n                 padding,\n                 num_groups=1):\n        super(ConvBNLayer, self).__init__()\n        self.conv = nn.Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_shallow_cnn",
        "documentation": {}
    },
    {
        "label": "ShallowCNN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_shallow_cnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_shallow_cnn",
        "peekOfCode": "class ShallowCNN(nn.Layer):\n    def __init__(self, in_channels=1, hidden_dim=512):\n        super().__init__()\n        assert isinstance(in_channels, int)\n        assert isinstance(hidden_dim, int)\n        self.conv1 = ConvBNLayer(\n            in_channels, 3, hidden_dim // 2, stride=1, padding=1)\n        self.conv2 = ConvBNLayer(\n            hidden_dim // 2, 3, hidden_dim, stride=1, padding=1)\n        self.pool = nn.MaxPool2D(kernel_size=2, stride=2, padding=0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_shallow_cnn",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size=3,\n                 stride=1,\n                 padding=0,\n                 bias_attr=False,\n                 groups=1,\n                 act=nn.GELU):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "DropPath",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class DropPath(nn.Layer):\n    \"\"\"Drop paths (Stochastic Depth) per sample  (when applied in main path of residual blocks).\n    \"\"\"\n    def __init__(self, drop_prob=None):\n        super(DropPath, self).__init__()\n        self.drop_prob = drop_prob\n    def forward(self, x):\n        return drop_path(x, self.drop_prob, self.training)\nclass Identity(nn.Layer):\n    def __init__(self):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "Identity",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class Identity(nn.Layer):\n    def __init__(self):\n        super(Identity, self).__init__()\n    def forward(self, input):\n        return input\nclass Mlp(nn.Layer):\n    def __init__(self,\n                 in_features,\n                 hidden_features=None,\n                 out_features=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class Mlp(nn.Layer):\n    def __init__(self,\n                 in_features,\n                 hidden_features=None,\n                 out_features=None,\n                 act_layer=nn.GELU,\n                 drop=0.):\n        super().__init__()\n        out_features = out_features or in_features\n        hidden_features = hidden_features or in_features",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "ConvMixer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class ConvMixer(nn.Layer):\n    def __init__(\n            self,\n            dim,\n            num_heads=8,\n            HW=[8, 25],\n            local_k=[3, 3], ):\n        super().__init__()\n        self.HW = HW\n        self.dim = dim",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class Attention(nn.Layer):\n    def __init__(self,\n                 dim,\n                 num_heads=8,\n                 mixer='Global',\n                 HW=None,\n                 local_k=[7, 11],\n                 qkv_bias=False,\n                 qk_scale=None,\n                 attn_drop=0.,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "Block",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class Block(nn.Layer):\n    def __init__(self,\n                 dim,\n                 num_heads,\n                 mixer='Global',\n                 local_mixer=[7, 11],\n                 HW=None,\n                 mlp_ratio=4.,\n                 qkv_bias=False,\n                 qk_scale=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "PatchEmbed",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class PatchEmbed(nn.Layer):\n    \"\"\" Image to Patch Embedding\n    \"\"\"\n    def __init__(self,\n                 img_size=[32, 100],\n                 in_channels=3,\n                 embed_dim=768,\n                 sub_num=2,\n                 patch_size=[4, 4],\n                 mode='pope'):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "SubSample",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class SubSample(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 types='Pool',\n                 stride=[2, 1],\n                 sub_norm='nn.LayerNorm',\n                 act=None):\n        super().__init__()\n        self.types = types",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "SVTRNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "class SVTRNet(nn.Layer):\n    def __init__(\n            self,\n            img_size=[32, 100],\n            in_channels=3,\n            embed_dim=[64, 128, 256],\n            depth=[3, 6, 3],\n            num_heads=[2, 4, 8],\n            mixer=['Local'] * 6 + ['Global'] *\n            6,  # Local atten, Global atten, Conv",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "drop_path",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "def drop_path(x, drop_prob=0., training=False):\n    \"\"\"Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).\n    the original name is misleading as 'Drop Connect' is a different form of dropout in a separate paper...\n    See discussion: https://github.com/tensorflow/tpu/issues/494#issuecomment-532968956 ...\n    \"\"\"\n    if drop_prob == 0. or not training:\n        return x\n    keep_prob = paddle.to_tensor(1 - drop_prob, dtype=x.dtype)\n    shape = (paddle.shape(x)[0], ) + (1, ) * (x.ndim - 1)\n    random_tensor = keep_prob + paddle.rand(shape, dtype=x.dtype)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "trunc_normal_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "trunc_normal_ = TruncatedNormal(std=.02)\nnormal_ = Normal\nzeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\ndef drop_path(x, drop_prob=0., training=False):\n    \"\"\"Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).\n    the original name is misleading as 'Drop Connect' is a different form of dropout in a separate paper...\n    See discussion: https://github.com/tensorflow/tpu/issues/494#issuecomment-532968956 ...\n    \"\"\"\n    if drop_prob == 0. or not training:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "normal_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "normal_ = Normal\nzeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\ndef drop_path(x, drop_prob=0., training=False):\n    \"\"\"Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).\n    the original name is misleading as 'Drop Connect' is a different form of dropout in a separate paper...\n    See discussion: https://github.com/tensorflow/tpu/issues/494#issuecomment-532968956 ...\n    \"\"\"\n    if drop_prob == 0. or not training:\n        return x",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "zeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\ndef drop_path(x, drop_prob=0., training=False):\n    \"\"\"Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).\n    the original name is misleading as 'Drop Connect' is a different form of dropout in a separate paper...\n    See discussion: https://github.com/tensorflow/tpu/issues/494#issuecomment-532968956 ...\n    \"\"\"\n    if drop_prob == 0. or not training:\n        return x\n    keep_prob = paddle.to_tensor(1 - drop_prob, dtype=x.dtype)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "ones_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "peekOfCode": "ones_ = Constant(value=1.)\ndef drop_path(x, drop_prob=0., training=False):\n    \"\"\"Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).\n    the original name is misleading as 'Drop Connect' is a different form of dropout in a separate paper...\n    See discussion: https://github.com/tensorflow/tpu/issues/494#issuecomment-532968956 ...\n    \"\"\"\n    if drop_prob == 0. or not training:\n        return x\n    keep_prob = paddle.to_tensor(1 - drop_prob, dtype=x.dtype)\n    shape = (paddle.shape(x)[0], ) + (1, ) * (x.ndim - 1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_svtrnet",
        "documentation": {}
    },
    {
        "label": "ViTSTR",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_vitstr",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_vitstr",
        "peekOfCode": "class ViTSTR(nn.Layer):\n    def __init__(self,\n                 img_size=[224, 224],\n                 in_channels=1,\n                 scale='tiny',\n                 seqlen=27,\n                 patch_size=[16, 16],\n                 embed_dim=None,\n                 depth=12,\n                 num_heads=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_vitstr",
        "documentation": {}
    },
    {
        "label": "scale_dim_heads",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_vitstr",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_vitstr",
        "peekOfCode": "scale_dim_heads = {'tiny': [192, 3], 'small': [384, 6], 'base': [768, 12]}\nclass ViTSTR(nn.Layer):\n    def __init__(self,\n                 img_size=[224, 224],\n                 in_channels=1,\n                 scale='tiny',\n                 seqlen=27,\n                 patch_size=[16, 16],\n                 embed_dim=None,\n                 depth=12,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.rec_vitstr",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    expansion = 1\n    def __init__(self,\n                 inplanes,\n                 planes,\n                 stride=1,\n                 downsample=None,\n                 gcb_config=None):\n        super(BasicBlock, self).__init__()\n        self.conv1 = nn.Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "documentation": {}
    },
    {
        "label": "TableResNetExtra",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "peekOfCode": "class TableResNetExtra(nn.Layer):\n    def __init__(self, layers, in_channels=3, gcb_config=None):\n        assert len(layers) >= 4\n        super(TableResNetExtra, self).__init__()\n        self.inplanes = 128\n        self.conv1 = nn.Conv2D(\n            in_channels,\n            64,\n            kernel_size=3,\n            stride=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "documentation": {}
    },
    {
        "label": "MultiAspectGCAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "peekOfCode": "class MultiAspectGCAttention(nn.Layer):\n    def __init__(self,\n                 inplanes,\n                 ratio,\n                 headers,\n                 pooling_type='att',\n                 att_scale=False,\n                 fusion_type='channel_add'):\n        super(MultiAspectGCAttention, self).__init__()\n        assert pooling_type in ['avg', 'att']",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "documentation": {}
    },
    {
        "label": "get_gcb_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "peekOfCode": "def get_gcb_config(gcb_config, layer):\n    if gcb_config is None or not gcb_config['layers'][layer]:\n        return None\n    else:\n        return gcb_config\nclass TableResNetExtra(nn.Layer):\n    def __init__(self, layers, in_channels=3, gcb_config=None):\n        assert len(layers) >= 4\n        super(TableResNetExtra, self).__init__()\n        self.inplanes = 128",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.table_master_resnet",
        "documentation": {}
    },
    {
        "label": "NLPBaseModel",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "class NLPBaseModel(nn.Layer):\n    def __init__(self,\n                 base_model_class,\n                 model_class,\n                 mode=\"base\",\n                 type=\"ser\",\n                 pretrained=True,\n                 checkpoints=None,\n                 **kwargs):\n        super(NLPBaseModel, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "LayoutLMForSer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "class LayoutLMForSer(NLPBaseModel):\n    def __init__(self,\n                 num_classes,\n                 pretrained=True,\n                 checkpoints=None,\n                 mode=\"base\",\n                 **kwargs):\n        super(LayoutLMForSer, self).__init__(\n            LayoutLMModel,\n            LayoutLMForTokenClassification,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "LayoutLMv2ForSer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "class LayoutLMv2ForSer(NLPBaseModel):\n    def __init__(self,\n                 num_classes,\n                 pretrained=True,\n                 checkpoints=None,\n                 mode=\"base\",\n                 **kwargs):\n        super(LayoutLMv2ForSer, self).__init__(\n            LayoutLMv2Model,\n            LayoutLMv2ForTokenClassification,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "LayoutXLMForSer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "class LayoutXLMForSer(NLPBaseModel):\n    def __init__(self,\n                 num_classes,\n                 pretrained=True,\n                 checkpoints=None,\n                 mode=\"base\",\n                 **kwargs):\n        super(LayoutXLMForSer, self).__init__(\n            LayoutXLMModel,\n            LayoutXLMForTokenClassification,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "LayoutLMv2ForRe",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "class LayoutLMv2ForRe(NLPBaseModel):\n    def __init__(self, pretrained=True, checkpoints=None, mode=\"base\",\n                 **kwargs):\n        super(LayoutLMv2ForRe, self).__init__(\n            LayoutLMv2Model, LayoutLMv2ForRelationExtraction, mode, \"re\",\n            pretrained, checkpoints)\n        if hasattr(self.model.layoutlmv2, \"use_visual_backbone\"\n                   ) and self.model.layoutlmv2.use_visual_backbone is False:\n            self.use_visual_backbone = False\n    def forward(self, x):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "LayoutXLMForRe",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "class LayoutXLMForRe(NLPBaseModel):\n    def __init__(self, pretrained=True, checkpoints=None, mode=\"base\",\n                 **kwargs):\n        super(LayoutXLMForRe, self).__init__(\n            LayoutXLMModel, LayoutXLMForRelationExtraction, mode, \"re\",\n            pretrained, checkpoints)\n        if hasattr(self.model.layoutxlm, \"use_visual_backbone\"\n                   ) and self.model.layoutxlm.use_visual_backbone is False:\n            self.use_visual_backbone = False\n    def forward(self, x):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "__all__ = [\"LayoutXLMForSer\", \"LayoutLMForSer\"]\npretrained_model_dict = {\n    LayoutXLMModel: {\n        \"base\": \"layoutxlm-base-uncased\",\n        \"vi\": \"vi-layoutxlm-base-uncased\",\n    },\n    LayoutLMModel: {\n        \"base\": \"layoutlm-base-uncased\",\n    },\n    LayoutLMv2Model: {",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "pretrained_model_dict",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "peekOfCode": "pretrained_model_dict = {\n    LayoutXLMModel: {\n        \"base\": \"layoutxlm-base-uncased\",\n        \"vi\": \"vi-layoutxlm-base-uncased\",\n    },\n    LayoutLMModel: {\n        \"base\": \"layoutlm-base-uncased\",\n    },\n    LayoutLMv2Model: {\n        \"base\": \"layoutlmv2-base-uncased\",",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.backbones.vqa_layoutlm",
        "documentation": {}
    },
    {
        "label": "ClsHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.cls_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.cls_head",
        "peekOfCode": "class ClsHead(nn.Layer):\n    \"\"\"\n    Class orientation\n    Args:\n        params(dict): super parameters for build Class network\n    \"\"\"\n    def __init__(self, in_channels, class_dim, **kwargs):\n        super(ClsHead, self).__init__()\n        self.pool = nn.AdaptiveAvgPool2D(1)\n        stdv = 1.0 / math.sqrt(in_channels * 1.0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.cls_head",
        "documentation": {}
    },
    {
        "label": "CT_Head",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "peekOfCode": "class CT_Head(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 hidden_dim,\n                 num_classes,\n                 loss_kernel=None,\n                 loss_loc=None):\n        super(CT_Head, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels, hidden_dim, kernel_size=3, stride=1, padding=1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "documentation": {}
    },
    {
        "label": "ones_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "peekOfCode": "ones_ = Constant(value=1.)\nzeros_ = Constant(value=0.)\nclass CT_Head(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 hidden_dim,\n                 num_classes,\n                 loss_kernel=None,\n                 loss_loc=None):\n        super(CT_Head, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "peekOfCode": "zeros_ = Constant(value=0.)\nclass CT_Head(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 hidden_dim,\n                 num_classes,\n                 loss_kernel=None,\n                 loss_loc=None):\n        super(CT_Head, self).__init__()\n        self.conv1 = nn.Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_ct_head",
        "documentation": {}
    },
    {
        "label": "Head",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "peekOfCode": "class Head(nn.Layer):\n    def __init__(self, in_channels, kernel_list=[3, 2, 2], **kwargs):\n        super(Head, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels=in_channels,\n            out_channels=in_channels // 4,\n            kernel_size=kernel_list[0],\n            padding=int(kernel_list[0] // 2),\n            weight_attr=ParamAttr(),\n            bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "documentation": {}
    },
    {
        "label": "DBHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "peekOfCode": "class DBHead(nn.Layer):\n    \"\"\"\n    Differentiable Binarization (DB) for text detection:\n        see https://arxiv.org/abs/1911.08947\n    args:\n        params(dict): super parameters for build DB network\n    \"\"\"\n    def __init__(self, in_channels, k=50, **kwargs):\n        super(DBHead, self).__init__()\n        self.k = k",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "documentation": {}
    },
    {
        "label": "LocalModule",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "peekOfCode": "class LocalModule(nn.Layer):\n    def __init__(self, in_c, mid_c, use_distance=True):\n        super(self.__class__, self).__init__()\n        self.last_3 = ConvBNLayer(in_c + 1, mid_c, 3, 1, 1, act='relu')\n        self.last_1 = nn.Conv2D(mid_c, 1, 1, 1, 0)\n    def forward(self, x, init_map, distance_map):\n        outf = paddle.concat([init_map, x], axis=1)\n        # last Conv\n        out = self.last_1(self.last_3(outf))\n        return out",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "documentation": {}
    },
    {
        "label": "PFHeadLocal",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "peekOfCode": "class PFHeadLocal(DBHead):\n    def __init__(self, in_channels, k=50, mode='small', **kwargs):\n        super(PFHeadLocal, self).__init__(in_channels, k, **kwargs)\n        self.mode = mode\n        self.up_conv = nn.Upsample(scale_factor=2, mode=\"nearest\", align_mode=1)\n        if self.mode == 'large':\n            self.cbn_layer = LocalModule(in_channels // 4, in_channels // 4)\n        elif self.mode == 'small':\n            self.cbn_layer = LocalModule(in_channels // 4, in_channels // 8)\n    def forward(self, x, targets=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "documentation": {}
    },
    {
        "label": "get_bias_attr",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "peekOfCode": "def get_bias_attr(k):\n    stdv = 1.0 / math.sqrt(k * 1.0)\n    initializer = paddle.nn.initializer.Uniform(-stdv, stdv)\n    bias_attr = ParamAttr(initializer=initializer)\n    return bias_attr\nclass Head(nn.Layer):\n    def __init__(self, in_channels, kernel_list=[3, 2, 2], **kwargs):\n        super(Head, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels=in_channels,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_db_head",
        "documentation": {}
    },
    {
        "label": "DRRGHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_drrg_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_drrg_head",
        "peekOfCode": "class DRRGHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 k_at_hops=(8, 4),\n                 num_adjacent_linkages=3,\n                 node_geo_feat_len=120,\n                 pooling_scale=1.0,\n                 pooling_output_size=(4, 3),\n                 nms_thr=0.3,\n                 min_width=8.0,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_drrg_head",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_east_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_east_head",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 padding,\n                 groups=1,\n                 if_act=True,\n                 act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_east_head",
        "documentation": {}
    },
    {
        "label": "EASTHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_east_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_east_head",
        "peekOfCode": "class EASTHead(nn.Layer):\n    \"\"\"\n    \"\"\"\n    def __init__(self, in_channels, model_name, **kwargs):\n        super(EASTHead, self).__init__()\n        self.model_name = model_name\n        if self.model_name == \"large\":\n            num_outputs = [128, 64, 1, 8]\n        else:\n            num_outputs = [64, 32, 1, 8]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_east_head",
        "documentation": {}
    },
    {
        "label": "FCEHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_fce_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_fce_head",
        "peekOfCode": "class FCEHead(nn.Layer):\n    \"\"\"The class for implementing FCENet head.\n    FCENet(CVPR2021): Fourier Contour Embedding for Arbitrary-shaped Text\n    Detection.\n    [https://arxiv.org/abs/2104.10442]\n    Args:\n        in_channels (int): The number of input channels.\n        scales (list[int]) : The scale of each layer.\n        fourier_degree (int) : The maximum Fourier transform degree k.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_fce_head",
        "documentation": {}
    },
    {
        "label": "multi_apply",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_fce_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_fce_head",
        "peekOfCode": "def multi_apply(func, *args, **kwargs):\n    pfunc = partial(func, **kwargs) if kwargs else func\n    map_results = map(pfunc, *args)\n    return tuple(map(list, zip(*map_results)))\nclass FCEHead(nn.Layer):\n    \"\"\"The class for implementing FCENet head.\n    FCENet(CVPR2021): Fourier Contour Embedding for Arbitrary-shaped Text\n    Detection.\n    [https://arxiv.org/abs/2104.10442]\n    Args:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_fce_head",
        "documentation": {}
    },
    {
        "label": "PSEHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_pse_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_pse_head",
        "peekOfCode": "class PSEHead(nn.Layer):\n    def __init__(self, in_channels, hidden_dim=256, out_channels=7, **kwargs):\n        super(PSEHead, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels, hidden_dim, kernel_size=3, stride=1, padding=1)\n        self.bn1 = nn.BatchNorm2D(hidden_dim)\n        self.relu1 = nn.ReLU()\n        self.conv2 = nn.Conv2D(\n            hidden_dim, out_channels, kernel_size=1, stride=1, padding=0)\n    def forward(self, x, **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_pse_head",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,\n                 if_act=True,\n                 act=None,\n                 name=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "documentation": {}
    },
    {
        "label": "SAST_Header1",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "peekOfCode": "class SAST_Header1(nn.Layer):\n    def __init__(self, in_channels, **kwargs):\n        super(SAST_Header1, self).__init__()\n        out_channels = [64, 64, 128]\n        self.score_conv = nn.Sequential(\n            ConvBNLayer(in_channels, out_channels[0], 1, 1, act='relu', name='f_score1'),\n            ConvBNLayer(out_channels[0], out_channels[1], 3, 1, act='relu', name='f_score2'),\n            ConvBNLayer(out_channels[1], out_channels[2], 1, 1, act='relu', name='f_score3'),\n            ConvBNLayer(out_channels[2], 1, 3, 1, act=None, name='f_score4')\n        )",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "documentation": {}
    },
    {
        "label": "SAST_Header2",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "peekOfCode": "class SAST_Header2(nn.Layer):\n    def __init__(self, in_channels, **kwargs):\n        super(SAST_Header2, self).__init__()\n        out_channels = [64, 64, 128]\n        self.tvo_conv = nn.Sequential(\n            ConvBNLayer(in_channels, out_channels[0], 1, 1, act='relu', name='f_tvo1'),\n            ConvBNLayer(out_channels[0], out_channels[1], 3, 1, act='relu', name='f_tvo2'),\n            ConvBNLayer(out_channels[1], out_channels[2], 1, 1, act='relu', name='f_tvo3'),\n            ConvBNLayer(out_channels[2], 8, 3, 1, act=None, name='f_tvo4')\n        )",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "documentation": {}
    },
    {
        "label": "SASTHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "peekOfCode": "class SASTHead(nn.Layer):\n    \"\"\"\n    \"\"\"\n    def __init__(self, in_channels, **kwargs):\n        super(SASTHead, self).__init__()\n        self.head1 = SAST_Header1(in_channels)\n        self.head2 = SAST_Header2(in_channels)\n    def forward(self, x, targets=None):\n        f_score, f_border = self.head1(x)\n        f_tvo, f_tco = self.head2(x)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.det_sast_head",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.e2e_pg_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.e2e_pg_head",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 padding,\n                 groups=1,\n                 if_act=True,\n                 act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.e2e_pg_head",
        "documentation": {}
    },
    {
        "label": "PGHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.e2e_pg_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.e2e_pg_head",
        "peekOfCode": "class PGHead(nn.Layer):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 in_channels,\n                 character_dict_path='ppocr/utils/ic15_dict.txt',\n                 **kwargs):\n        super(PGHead, self).__init__()\n        # get character_length\n        with open(character_dict_path, \"rb\") as fin:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.e2e_pg_head",
        "documentation": {}
    },
    {
        "label": "BatchNorm1D",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "peekOfCode": "class BatchNorm1D(nn.BatchNorm1D):\n    def __init__(self,\n                 num_features,\n                 eps=1e-05,\n                 momentum=0.1,\n                 affine=True,\n                 track_running_stats=True):\n        momentum = 1 - momentum\n        weight_attr = None\n        bias_attr = None",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "documentation": {}
    },
    {
        "label": "MeanAggregator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "peekOfCode": "class MeanAggregator(nn.Layer):\n    def forward(self, features, A):\n        x = paddle.bmm(A, features)\n        return x\nclass GraphConv(nn.Layer):\n    def __init__(self, in_dim, out_dim):\n        super().__init__()\n        self.in_dim = in_dim\n        self.out_dim = out_dim\n        self.weight = self.create_parameter(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "documentation": {}
    },
    {
        "label": "GraphConv",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "peekOfCode": "class GraphConv(nn.Layer):\n    def __init__(self, in_dim, out_dim):\n        super().__init__()\n        self.in_dim = in_dim\n        self.out_dim = out_dim\n        self.weight = self.create_parameter(\n            [in_dim * 2, out_dim],\n            default_initializer=nn.initializer.XavierUniform())\n        self.bias = self.create_parameter(\n            [out_dim],",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "documentation": {}
    },
    {
        "label": "GCN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "peekOfCode": "class GCN(nn.Layer):\n    def __init__(self, feat_len):\n        super(GCN, self).__init__()\n        self.bn0 = BatchNorm1D(feat_len, affine=False)\n        self.conv1 = GraphConv(feat_len, 512)\n        self.conv2 = GraphConv(512, 256)\n        self.conv3 = GraphConv(256, 128)\n        self.conv4 = GraphConv(128, 64)\n        self.classifier = nn.Sequential(\n            nn.Linear(64, 32), nn.PReLU(32), nn.Linear(32, 2))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.gcn",
        "documentation": {}
    },
    {
        "label": "SDMGRHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "peekOfCode": "class SDMGRHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 num_chars=92,\n                 visual_dim=16,\n                 fusion_dim=1024,\n                 node_input=32,\n                 node_embed=256,\n                 edge_input=5,\n                 edge_embed=256,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "documentation": {}
    },
    {
        "label": "GNNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "peekOfCode": "class GNNLayer(nn.Layer):\n    def __init__(self, node_dim=256, edge_dim=256):\n        super().__init__()\n        self.in_fc = nn.Linear(node_dim * 2 + edge_dim, node_dim)\n        self.coef_fc = nn.Linear(node_dim, 1)\n        self.out_fc = nn.Linear(node_dim, node_dim)\n        self.relu = nn.ReLU()\n    def forward(self, nodes, edges, nums):\n        start, cat_nodes = 0, []\n        for num in nums:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "documentation": {}
    },
    {
        "label": "Block",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "peekOfCode": "class Block(nn.Layer):\n    def __init__(self,\n                 input_dims,\n                 output_dim,\n                 mm_dim=1600,\n                 chunks=20,\n                 rank=15,\n                 shared=False,\n                 dropout_input=0.,\n                 dropout_pre_lin=0.,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.kie_sdmgr_head",
        "documentation": {}
    },
    {
        "label": "LocalGraphs",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "peekOfCode": "class LocalGraphs:\n    def __init__(self, k_at_hops, num_adjacent_linkages, node_geo_feat_len,\n                 pooling_scale, pooling_output_size, local_graph_thr):\n        assert len(k_at_hops) == 2\n        assert all(isinstance(n, int) for n in k_at_hops)\n        assert isinstance(num_adjacent_linkages, int)\n        assert isinstance(node_geo_feat_len, int)\n        assert isinstance(pooling_scale, float)\n        assert all(isinstance(n, int) for n in pooling_output_size)\n        assert isinstance(local_graph_thr, float)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "documentation": {}
    },
    {
        "label": "normalize_adjacent_matrix",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "peekOfCode": "def normalize_adjacent_matrix(A):\n    assert A.ndim == 2\n    assert A.shape[0] == A.shape[1]\n    A = A + np.eye(A.shape[0])\n    d = np.sum(A, axis=0)\n    d = np.clip(d, 0, None)\n    d_inv = np.power(d, -0.5).flatten()\n    d_inv[np.isinf(d_inv)] = 0.0\n    d_inv = np.diag(d_inv)\n    G = A.dot(d_inv).transpose().dot(d_inv)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "documentation": {}
    },
    {
        "label": "euclidean_distance_matrix",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "peekOfCode": "def euclidean_distance_matrix(A, B):\n    \"\"\"Calculate the Euclidean distance matrix.\n    Args:\n        A (ndarray): The point sequence.\n        B (ndarray): The point sequence with the same dimensions as A.\n    returns:\n        D (ndarray): The Euclidean distance matrix.\n    \"\"\"\n    assert A.ndim == 2\n    assert B.ndim == 2",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "documentation": {}
    },
    {
        "label": "feature_embedding",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "peekOfCode": "def feature_embedding(input_feats, out_feat_len):\n    \"\"\"Embed features. This code was partially adapted from\n    https://github.com/GXYM/DRRG licensed under the MIT license.\n    Args:\n        input_feats (ndarray): The input features of shape (N, d), where N is\n            the number of nodes in graph, d is the input feature vector length.\n        out_feat_len (int): The length of output feature vector.\n    Returns:\n        embedded_feats (ndarray): The embedded features.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.local_graph",
        "documentation": {}
    },
    {
        "label": "ProposalLocalGraphs",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.proposal_local_graph",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.proposal_local_graph",
        "peekOfCode": "class ProposalLocalGraphs:\n    def __init__(self, k_at_hops, num_adjacent_linkages, node_geo_feat_len,\n                 pooling_scale, pooling_output_size, nms_thr, min_width,\n                 max_width, comp_shrink_ratio, comp_w_h_ratio, comp_score_thr,\n                 text_region_thr, center_region_thr, center_region_area_thr):\n        assert len(k_at_hops) == 2\n        assert isinstance(k_at_hops, tuple)\n        assert isinstance(num_adjacent_linkages, int)\n        assert isinstance(node_geo_feat_len, int)\n        assert isinstance(pooling_scale, float)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.proposal_local_graph",
        "documentation": {}
    },
    {
        "label": "fill_hole",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.proposal_local_graph",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.proposal_local_graph",
        "peekOfCode": "def fill_hole(input_mask):\n    h, w = input_mask.shape\n    canvas = np.zeros((h + 2, w + 2), np.uint8)\n    canvas[1:h + 1, 1:w + 1] = input_mask.copy()\n    mask = np.zeros((h + 4, w + 4), np.uint8)\n    cv2.floodFill(canvas, mask, (0, 0), 1)\n    canvas = canvas[1:h + 1, 1:w + 1].astype(np.bool_)\n    return ~canvas | input_mask\nclass ProposalLocalGraphs:\n    def __init__(self, k_at_hops, num_adjacent_linkages, node_geo_feat_len,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.proposal_local_graph",
        "documentation": {}
    },
    {
        "label": "BCNLanguage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "peekOfCode": "class BCNLanguage(nn.Layer):\n    def __init__(self,\n                 d_model=512,\n                 nhead=8,\n                 num_layers=4,\n                 dim_feedforward=2048,\n                 dropout=0.,\n                 max_length=25,\n                 detach=True,\n                 num_classes=37):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "documentation": {}
    },
    {
        "label": "PositionAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "peekOfCode": "class PositionAttention(nn.Layer):\n    def __init__(self,\n                 max_length,\n                 in_channels=512,\n                 num_channels=64,\n                 h=8,\n                 w=32,\n                 mode='nearest',\n                 **kwargs):\n        super().__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "documentation": {}
    },
    {
        "label": "ABINetHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "peekOfCode": "class ABINetHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 d_model=512,\n                 nhead=8,\n                 num_layers=3,\n                 dim_feedforward=2048,\n                 dropout=0.1,\n                 max_length=25,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "documentation": {}
    },
    {
        "label": "encoder_layer",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "peekOfCode": "def encoder_layer(in_c, out_c, k=3, s=2, p=1):\n    return nn.Sequential(\n        nn.Conv2D(in_c, out_c, k, s, p), nn.BatchNorm2D(out_c), nn.ReLU())\ndef decoder_layer(in_c,\n                  out_c,\n                  k=3,\n                  s=1,\n                  p=1,\n                  mode='nearest',\n                  scale_factor=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "documentation": {}
    },
    {
        "label": "decoder_layer",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "peekOfCode": "def decoder_layer(in_c,\n                  out_c,\n                  k=3,\n                  s=1,\n                  p=1,\n                  mode='nearest',\n                  scale_factor=None,\n                  size=None):\n    align_corners = False if mode == 'nearest' else True\n    return nn.Sequential(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_abinet_head",
        "documentation": {}
    },
    {
        "label": "AsterHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "peekOfCode": "class AsterHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 sDim,\n                 attDim,\n                 max_len_labels,\n                 time_step=25,\n                 beam_width=5,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "documentation": {}
    },
    {
        "label": "Embedding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "peekOfCode": "class Embedding(nn.Layer):\n    def __init__(self, in_timestep, in_planes, mid_dim=4096, embed_dim=300):\n        super(Embedding, self).__init__()\n        self.in_timestep = in_timestep\n        self.in_planes = in_planes\n        self.embed_dim = embed_dim\n        self.mid_dim = mid_dim\n        self.eEmbed = nn.Linear(\n            in_timestep * in_planes,\n            self.embed_dim)  # Embed encoder output to a word-embedding like",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "documentation": {}
    },
    {
        "label": "AttentionRecognitionHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "peekOfCode": "class AttentionRecognitionHead(nn.Layer):\n    \"\"\"\n  input: [b x 16 x 64 x in_planes]\n  output: probability sequence: [b x T x num_classes]\n  \"\"\"\n    def __init__(self, in_channels, out_channels, sDim, attDim, max_len_labels):\n        super(AttentionRecognitionHead, self).__init__()\n        self.num_classes = out_channels  # this is the output classes. So it includes the <EOS>.\n        self.in_planes = in_channels\n        self.sDim = sDim",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "documentation": {}
    },
    {
        "label": "AttentionUnit",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "peekOfCode": "class AttentionUnit(nn.Layer):\n    def __init__(self, sDim, xDim, attDim):\n        super(AttentionUnit, self).__init__()\n        self.sDim = sDim\n        self.xDim = xDim\n        self.attDim = attDim\n        self.sEmbed = nn.Linear(sDim, attDim)\n        self.xEmbed = nn.Linear(xDim, attDim)\n        self.wEmbed = nn.Linear(attDim, 1)\n    def forward(self, x, sPrev):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "documentation": {}
    },
    {
        "label": "DecoderUnit",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "peekOfCode": "class DecoderUnit(nn.Layer):\n    def __init__(self, sDim, xDim, yDim, attDim):\n        super(DecoderUnit, self).__init__()\n        self.sDim = sDim\n        self.xDim = xDim\n        self.yDim = yDim\n        self.attDim = attDim\n        self.emdDim = attDim\n        self.attention_unit = AttentionUnit(sDim, xDim, attDim)\n        self.tgt_embedding = nn.Embedding(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_aster_head",
        "documentation": {}
    },
    {
        "label": "AttentionHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "peekOfCode": "class AttentionHead(nn.Layer):\n    def __init__(self, in_channels, out_channels, hidden_size, **kwargs):\n        super(AttentionHead, self).__init__()\n        self.input_size = in_channels\n        self.hidden_size = hidden_size\n        self.num_classes = out_channels\n        self.attention_cell = AttentionGRUCell(\n            in_channels, hidden_size, out_channels, use_gru=False)\n        self.generator = nn.Linear(hidden_size, out_channels)\n    def _char_to_onehot(self, input_char, onehot_dim):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "documentation": {}
    },
    {
        "label": "AttentionGRUCell",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "peekOfCode": "class AttentionGRUCell(nn.Layer):\n    def __init__(self, input_size, hidden_size, num_embeddings, use_gru=False):\n        super(AttentionGRUCell, self).__init__()\n        self.i2h = nn.Linear(input_size, hidden_size, bias_attr=False)\n        self.h2h = nn.Linear(hidden_size, hidden_size)\n        self.score = nn.Linear(hidden_size, 1, bias_attr=False)\n        self.rnn = nn.GRUCell(\n            input_size=input_size + num_embeddings, hidden_size=hidden_size)\n        self.hidden_size = hidden_size\n    def forward(self, prev_hidden, batch_H, char_onehots):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "documentation": {}
    },
    {
        "label": "AttentionLSTM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "peekOfCode": "class AttentionLSTM(nn.Layer):\n    def __init__(self, in_channels, out_channels, hidden_size, **kwargs):\n        super(AttentionLSTM, self).__init__()\n        self.input_size = in_channels\n        self.hidden_size = hidden_size\n        self.num_classes = out_channels\n        self.attention_cell = AttentionLSTMCell(\n            in_channels, hidden_size, out_channels, use_gru=False)\n        self.generator = nn.Linear(hidden_size, out_channels)\n    def _char_to_onehot(self, input_char, onehot_dim):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "documentation": {}
    },
    {
        "label": "AttentionLSTMCell",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "peekOfCode": "class AttentionLSTMCell(nn.Layer):\n    def __init__(self, input_size, hidden_size, num_embeddings, use_gru=False):\n        super(AttentionLSTMCell, self).__init__()\n        self.i2h = nn.Linear(input_size, hidden_size, bias_attr=False)\n        self.h2h = nn.Linear(hidden_size, hidden_size)\n        self.score = nn.Linear(hidden_size, 1, bias_attr=False)\n        if not use_gru:\n            self.rnn = nn.LSTMCell(\n                input_size=input_size + num_embeddings, hidden_size=hidden_size)\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_att_head",
        "documentation": {}
    },
    {
        "label": "ChannelAtt",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "peekOfCode": "class ChannelAtt(nn.Layer):\n    def __init__(self, channel, reduction):\n        super(ChannelAtt, self).__init__()\n        self.avg_pool = nn.AdaptiveAvgPool2D(1)\n        self.fc = nn.Sequential(\n            nn.Linear(channel, channel // reduction),\n            nn.ReLU(), nn.Linear(channel // reduction, channel), nn.Sigmoid())\n    def forward(self, x):\n        b, c, _, _ = x.shape\n        y = paddle.reshape(self.avg_pool(x), [b, c])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "documentation": {}
    },
    {
        "label": "CountingDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "peekOfCode": "class CountingDecoder(nn.Layer):\n    def __init__(self, in_channel, out_channel, kernel_size):\n        super(CountingDecoder, self).__init__()\n        self.in_channel = in_channel\n        self.out_channel = out_channel\n        self.trans_layer = nn.Sequential(\n            nn.Conv2D(\n                self.in_channel,\n                512,\n                kernel_size=kernel_size,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "documentation": {}
    },
    {
        "label": "PositionEmbeddingSine",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "peekOfCode": "class PositionEmbeddingSine(nn.Layer):\n    def __init__(self,\n                 num_pos_feats=64,\n                 temperature=10000,\n                 normalize=False,\n                 scale=None):\n        super().__init__()\n        self.num_pos_feats = num_pos_feats\n        self.temperature = temperature\n        self.normalize = normalize",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "documentation": {}
    },
    {
        "label": "AttDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "peekOfCode": "class AttDecoder(nn.Layer):\n    def __init__(self, ratio, is_train, input_size, hidden_size,\n                 encoder_out_channel, dropout, dropout_ratio, word_num,\n                 counting_decoder_out_channel, attention):\n        super(AttDecoder, self).__init__()\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        self.out_channel = encoder_out_channel\n        self.attention_dim = attention['attention_dim']\n        self.dropout_prob = dropout",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "peekOfCode": "class Attention(nn.Layer):\n    def __init__(self, hidden_size, attention_dim):\n        super(Attention, self).__init__()\n        self.hidden = hidden_size\n        self.attention_dim = attention_dim\n        self.hidden_weight = nn.Linear(self.hidden, self.attention_dim)\n        self.attention_conv = nn.Conv2D(\n            1, 512, kernel_size=11, padding=5, bias_attr=False)\n        self.attention_weight = nn.Linear(\n            512, self.attention_dim, bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "documentation": {}
    },
    {
        "label": "CANHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "peekOfCode": "class CANHead(nn.Layer):\n    def __init__(self, in_channel, out_channel, ratio, attdecoder, **kwargs):\n        super(CANHead, self).__init__()\n        self.in_channel = in_channel\n        self.out_channel = out_channel\n        self.counting_decoder1 = CountingDecoder(self.in_channel,\n                                                 self.out_channel, 3)  # mscm\n        self.counting_decoder2 = CountingDecoder(self.in_channel,\n                                                 self.out_channel, 5)\n        self.decoder = AttDecoder(ratio, **attdecoder)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_can_head",
        "documentation": {}
    },
    {
        "label": "CTCHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_ctc_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_ctc_head",
        "peekOfCode": "class CTCHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 fc_decay=0.0004,\n                 mid_channels=None,\n                 return_feats=False,\n                 **kwargs):\n        super(CTCHead, self).__init__()\n        if mid_channels is None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_ctc_head",
        "documentation": {}
    },
    {
        "label": "get_para_bias_attr",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_ctc_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_ctc_head",
        "peekOfCode": "def get_para_bias_attr(l2_decay, k):\n    regularizer = paddle.regularizer.L2Decay(l2_decay)\n    stdv = 1.0 / math.sqrt(k * 1.0)\n    initializer = nn.initializer.Uniform(-stdv, stdv)\n    weight_attr = ParamAttr(regularizer=regularizer, initializer=initializer)\n    bias_attr = ParamAttr(regularizer=regularizer, initializer=initializer)\n    return [weight_attr, bias_attr]\nclass CTCHead(nn.Layer):\n    def __init__(self,\n                 in_channels,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_ctc_head",
        "documentation": {}
    },
    {
        "label": "FCTranspose",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_multi_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_multi_head",
        "peekOfCode": "class FCTranspose(nn.Layer):\n    def __init__(self, in_channels, out_channels, only_transpose=False):\n        super().__init__()\n        self.only_transpose = only_transpose\n        if not self.only_transpose:\n            self.fc = nn.Linear(in_channels, out_channels, bias_attr=False)\n    def forward(self, x):\n        if self.only_transpose:\n            return x.transpose([0, 2, 1])\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_multi_head",
        "documentation": {}
    },
    {
        "label": "MultiHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_multi_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_multi_head",
        "peekOfCode": "class MultiHead(nn.Layer):\n    def __init__(self, in_channels, out_channels_list, **kwargs):\n        super().__init__()\n        self.head_list = kwargs.pop('head_list')\n        self.gtc_head = 'sar'\n        assert len(self.head_list) >= 2\n        for idx, head_name in enumerate(self.head_list):\n            name = list(head_name)[0]\n            if name == 'SARHead':\n                # sar head",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_multi_head",
        "documentation": {}
    },
    {
        "label": "Transformer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "peekOfCode": "class Transformer(nn.Layer):\n    \"\"\"A transformer model. User is able to modify the attributes as needed. The architechture\n    is based on the paper \"Attention Is All You Need\". Ashish Vaswani, Noam Shazeer,\n    Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and\n    Illia Polosukhin. 2017. Attention is all you need. In Advances in Neural Information\n    Processing Systems, pages 6000-6010.\n    Args:\n        d_model: the number of expected features in the encoder/decoder inputs (default=512).\n        nhead: the number of heads in the multiheadattention models (default=8).\n        num_encoder_layers: the number of sub-encoder-layers in the encoder (default=6).",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "MultiheadAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "peekOfCode": "class MultiheadAttention(nn.Layer):\n    \"\"\"Allows the model to jointly attend to information\n    from different representation subspaces.\n    See reference: Attention Is All You Need\n    .. math::\n        \\text{MultiHead}(Q, K, V) = \\text{Concat}(head_1,\\dots,head_h)W^O\n        \\text{where} head_i = \\text{Attention}(QW_i^Q, KW_i^K, VW_i^V)\n    Args:\n        embed_dim: total dimension of the model\n        num_heads: parallel attention layers, or heads",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "TransformerBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "peekOfCode": "class TransformerBlock(nn.Layer):\n    def __init__(self,\n                 d_model,\n                 nhead,\n                 dim_feedforward=2048,\n                 attention_dropout_rate=0.0,\n                 residual_dropout_rate=0.1,\n                 with_self_attn=True,\n                 with_cross_attn=False,\n                 epsilon=1e-5):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "peekOfCode": "class PositionalEncoding(nn.Layer):\n    \"\"\"Inject some information about the relative or absolute position of the tokens\n        in the sequence. The positional encodings have the same dimension as\n        the embeddings, so that the two can be summed. Here, we use sine and cosine\n        functions of different frequencies.\n    .. math::\n        \\text{PosEncoder}(pos, 2i) = sin(pos/10000^(2i/d_model))\n        \\text{PosEncoder}(pos, 2i+1) = cos(pos/10000^(2i/d_model))\n        \\text{where pos is the word position and i is the embed idx)\n    Args:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding_2d",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "peekOfCode": "class PositionalEncoding_2d(nn.Layer):\n    \"\"\"Inject some information about the relative or absolute position of the tokens\n        in the sequence. The positional encodings have the same dimension as\n        the embeddings, so that the two can be summed. Here, we use sine and cosine\n        functions of different frequencies.\n    .. math::\n        \\text{PosEncoder}(pos, 2i) = sin(pos/10000^(2i/d_model))\n        \\text{PosEncoder}(pos, 2i+1) = cos(pos/10000^(2i/d_model))\n        \\text{where pos is the word position and i is the embed idx)\n    Args:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "Embeddings",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "peekOfCode": "class Embeddings(nn.Layer):\n    def __init__(self, d_model, vocab, padding_idx=None, scale_embedding=True):\n        super(Embeddings, self).__init__()\n        self.embedding = nn.Embedding(vocab, d_model, padding_idx=padding_idx)\n        w0 = np.random.normal(0.0, d_model**-0.5,\n                              (vocab, d_model)).astype(np.float32)\n        self.embedding.weight.set_value(w0)\n        self.d_model = d_model\n        self.scale_embedding = scale_embedding\n    def forward(self, x):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "Beam",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "peekOfCode": "class Beam():\n    \"\"\" Beam search \"\"\"\n    def __init__(self, size, device=False):\n        self.size = size\n        self._done = False\n        # The score for each translation on the beam.\n        self.scores = paddle.zeros((size, ), dtype=paddle.float32)\n        self.all_scores = []\n        # The backpointers at each time-step.\n        self.prev_ks = []",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_nrtr_head",
        "documentation": {}
    },
    {
        "label": "PRENHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_pren_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_pren_head",
        "peekOfCode": "class PRENHead(nn.Layer):\n    def __init__(self, in_channels, out_channels, **kwargs):\n        super(PRENHead, self).__init__()\n        self.linear = nn.Linear(in_channels, out_channels)\n    def forward(self, x, targets=None):\n        predicts = self.linear(x)\n        if not self.training:\n            predicts = F.softmax(predicts, axis=2)\n        return predicts",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_pren_head",
        "documentation": {}
    },
    {
        "label": "CNTHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "peekOfCode": "class CNTHead(nn.Layer):\n    def __init__(self,\n                 embed_size=512,\n                 encode_length=26,\n                 out_channels=38,\n                 **kwargs):\n        super(CNTHead, self).__init__()\n        self.out_channels = out_channels\n        self.Wv_fusion = nn.Linear(embed_size, embed_size, bias_attr=False)\n        self.Prediction_visual = nn.Linear(encode_length * embed_size,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "documentation": {}
    },
    {
        "label": "RFLHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "peekOfCode": "class RFLHead(nn.Layer):\n    def __init__(self,\n                 in_channels=512,\n                 hidden_size=256,\n                 batch_max_legnth=25,\n                 out_channels=38,\n                 use_cnt=True,\n                 use_seq=True,\n                 **kwargs):\n        super(RFLHead, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "documentation": {}
    },
    {
        "label": "kaiming_init_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "peekOfCode": "kaiming_init_ = KaimingNormal()\nzeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass CNTHead(nn.Layer):\n    def __init__(self,\n                 embed_size=512,\n                 encode_length=26,\n                 out_channels=38,\n                 **kwargs):\n        super(CNTHead, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "peekOfCode": "zeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass CNTHead(nn.Layer):\n    def __init__(self,\n                 embed_size=512,\n                 encode_length=26,\n                 out_channels=38,\n                 **kwargs):\n        super(CNTHead, self).__init__()\n        self.out_channels = out_channels",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "documentation": {}
    },
    {
        "label": "ones_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "peekOfCode": "ones_ = Constant(value=1.)\nclass CNTHead(nn.Layer):\n    def __init__(self,\n                 embed_size=512,\n                 encode_length=26,\n                 out_channels=38,\n                 **kwargs):\n        super(CNTHead, self).__init__()\n        self.out_channels = out_channels\n        self.Wv_fusion = nn.Linear(embed_size, embed_size, bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_rfl_head",
        "documentation": {}
    },
    {
        "label": "BaseDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class BaseDecoder(nn.Layer):\n    def __init__(self, **kwargs):\n        super().__init__()\n    def forward_train(self, feat, out_enc, targets, img_metas):\n        raise NotImplementedError\n    def forward_test(self, feat, out_enc, img_metas):\n        raise NotImplementedError\n    def forward(self,\n                feat,\n                out_enc,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "ChannelReductionEncoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class ChannelReductionEncoder(nn.Layer):\n    \"\"\"Change the channel number with a one by one convoluational layer.\n    Args:\n        in_channels (int): Number of input channels.\n        out_channels (int): Number of output channels.\n    \"\"\"\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "DotProductAttentionLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class DotProductAttentionLayer(nn.Layer):\n    def __init__(self, dim_model=None):\n        super().__init__()\n        self.scale = dim_model**-0.5 if dim_model is not None else 1.\n    def forward(self, query, key, value, h, w, valid_ratios=None):\n        query = paddle.transpose(query, (0, 2, 1))\n        logits = paddle.matmul(query, key) * self.scale\n        n, c, t = logits.shape\n        # reshape to (n, c, h, w)\n        logits = paddle.reshape(logits, [n, c, h, w])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "SequenceAttentionDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class SequenceAttentionDecoder(BaseDecoder):\n    \"\"\"Sequence attention decoder for RobustScanner.\n    RobustScanner: `RobustScanner: Dynamically Enhancing Positional Clues for\n    Robust Text Recognition <https://arxiv.org/abs/2007.07542>`_\n    Args:\n        num_classes (int): Number of output classes :math:`C`.\n        rnn_layers (int): Number of RNN layers.\n        dim_input (int): Dimension :math:`D_i` of input vector ``feat``.\n        dim_model (int): Dimension :math:`D_m` of the model. Should also be the\n            same as encoder output vector ``out_enc``.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "PositionAwareLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class PositionAwareLayer(nn.Layer):\n    def __init__(self, dim_model, rnn_layers=2):\n        super().__init__()\n        self.dim_model = dim_model\n        self.rnn = nn.LSTM(\n            input_size=dim_model,\n            hidden_size=dim_model,\n            num_layers=rnn_layers,\n            time_major=False)\n        self.mixer = nn.Sequential(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "PositionAttentionDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class PositionAttentionDecoder(BaseDecoder):\n    \"\"\"Position attention decoder for RobustScanner.\n    RobustScanner: `RobustScanner: Dynamically Enhancing Positional Clues for\n    Robust Text Recognition <https://arxiv.org/abs/2007.07542>`_\n    Args:\n        num_classes (int): Number of output classes :math:`C`.\n        rnn_layers (int): Number of RNN layers.\n        dim_input (int): Dimension :math:`D_i` of input vector ``feat``.\n        dim_model (int): Dimension :math:`D_m` of the model. Should also be the\n            same as encoder output vector ``out_enc``.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "RobustScannerFusionLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class RobustScannerFusionLayer(nn.Layer):\n    def __init__(self, dim_model, dim=-1):\n        super(RobustScannerFusionLayer, self).__init__()\n        self.dim_model = dim_model\n        self.dim = dim\n        self.linear_layer = nn.Linear(dim_model * 2, dim_model * 2)\n    def forward(self, x0, x1):\n        assert x0.shape == x1.shape\n        fusion_input = paddle.concat([x0, x1], self.dim)\n        output = self.linear_layer(fusion_input)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "RobustScannerDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class RobustScannerDecoder(BaseDecoder):\n    \"\"\"Decoder for RobustScanner.\n    RobustScanner: `RobustScanner: Dynamically Enhancing Positional Clues for\n    Robust Text Recognition <https://arxiv.org/abs/2007.07542>`_\n    Args:\n        num_classes (int): Number of output classes :math:`C`.\n        dim_input (int): Dimension :math:`D_i` of input vector ``feat``.\n        dim_model (int): Dimension :math:`D_m` of the model. Should also be the\n            same as encoder output vector ``out_enc``.\n        max_seq_len (int): Maximum output sequence length :math:`T`.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "RobustScannerHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "class RobustScannerHead(nn.Layer):\n    def __init__(self,\n                 out_channels, # 90 + unknown + start + padding\n                 in_channels,\n                 enc_outchannles=128,\n                 hybrid_dec_rnn_layers=2,\n                 hybrid_dec_dropout=0,\n                 position_dec_rnn_layers=2,\n                 start_idx=0,\n                 max_text_length=40,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "masked_fill",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "peekOfCode": "def masked_fill(x, mask, value):\n    y = paddle.full(x.shape, value, x.dtype)\n    return paddle.where(mask, y, x)\nclass DotProductAttentionLayer(nn.Layer):\n    def __init__(self, dim_model=None):\n        super().__init__()\n        self.scale = dim_model**-0.5 if dim_model is not None else 1.\n    def forward(self, query, key, value, h, w, valid_ratios=None):\n        query = paddle.transpose(query, (0, 2, 1))\n        logits = paddle.matmul(query, key) * self.scale",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_robustscanner_head",
        "documentation": {}
    },
    {
        "label": "SAREncoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "peekOfCode": "class SAREncoder(nn.Layer):\n    \"\"\"\n    Args:\n        enc_bi_rnn (bool): If True, use bidirectional RNN in encoder.\n        enc_drop_rnn (float): Dropout probability of RNN layer in encoder.\n        enc_gru (bool): If True, use GRU, else LSTM in encoder.\n        d_model (int): Dim of channels from backbone.\n        d_enc (int): Dim of encoder RNN layer.\n        mask (bool): If True, mask padding in RNN sequence.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "documentation": {}
    },
    {
        "label": "BaseDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "peekOfCode": "class BaseDecoder(nn.Layer):\n    def __init__(self, **kwargs):\n        super().__init__()\n    def forward_train(self, feat, out_enc, targets, img_metas):\n        raise NotImplementedError\n    def forward_test(self, feat, out_enc, img_metas):\n        raise NotImplementedError\n    def forward(self,\n                feat,\n                out_enc,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "documentation": {}
    },
    {
        "label": "ParallelSARDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "peekOfCode": "class ParallelSARDecoder(BaseDecoder):\n    \"\"\"\n    Args:\n        out_channels (int): Output class number.\n        enc_bi_rnn (bool): If True, use bidirectional RNN in encoder.\n        dec_bi_rnn (bool): If True, use bidirectional RNN in decoder.\n        dec_drop_rnn (float): Dropout of RNN layer in decoder.\n        dec_gru (bool): If True, use GRU, else LSTM in decoder.\n        d_model (int): Dim of channels from backbone.\n        d_enc (int): Dim of encoder RNN layer.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "documentation": {}
    },
    {
        "label": "SARHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "peekOfCode": "class SARHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 enc_dim=512,\n                 max_text_length=30,\n                 enc_bi_rnn=False,\n                 enc_drop_rnn=0.1,\n                 enc_gru=False,\n                 dec_bi_rnn=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_sar_head",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 num_channels,\n                 filter_size,\n                 num_filters,\n                 stride,\n                 padding,\n                 num_groups=1):\n        super(ConvBNLayer, self).__init__()\n        self.conv = nn.Conv2D(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "SATRNEncoderLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class SATRNEncoderLayer(nn.Layer):\n    def __init__(self,\n                 d_model=512,\n                 d_inner=512,\n                 n_head=8,\n                 d_k=64,\n                 d_v=64,\n                 dropout=0.1,\n                 qkv_bias=False):\n        super().__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "LocalityAwareFeedforward",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class LocalityAwareFeedforward(nn.Layer):\n    def __init__(\n            self,\n            d_in,\n            d_hid,\n            dropout=0.1, ):\n        super().__init__()\n        self.conv1 = ConvBNLayer(d_in, 1, d_hid, stride=1, padding=0)\n        self.depthwise_conv = ConvBNLayer(\n            d_hid, 3, d_hid, stride=1, padding=1, num_groups=d_hid)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "Adaptive2DPositionalEncoding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class Adaptive2DPositionalEncoding(nn.Layer):\n    def __init__(self, d_hid=512, n_height=100, n_width=100, dropout=0.1):\n        super().__init__()\n        h_position_encoder = self._get_sinusoid_encoding_table(n_height, d_hid)\n        h_position_encoder = h_position_encoder.transpose([1, 0])\n        h_position_encoder = h_position_encoder.reshape([1, d_hid, n_height, 1])\n        w_position_encoder = self._get_sinusoid_encoding_table(n_width, d_hid)\n        w_position_encoder = w_position_encoder.transpose([1, 0])\n        w_position_encoder = w_position_encoder.reshape([1, d_hid, 1, n_width])\n        self.register_buffer('h_position_encoder', h_position_encoder)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "ScaledDotProductAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class ScaledDotProductAttention(nn.Layer):\n    def __init__(self, temperature, attn_dropout=0.1):\n        super().__init__()\n        self.temperature = temperature\n        self.dropout = nn.Dropout(attn_dropout)\n    def forward(self, q, k, v, mask=None):\n        def masked_fill(x, mask, value):\n            y = paddle.full(x.shape, value, x.dtype)\n            return paddle.where(mask, y, x)\n        attn = paddle.matmul(q / self.temperature, k.transpose([0, 1, 3, 2]))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "MultiHeadAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class MultiHeadAttention(nn.Layer):\n    def __init__(self,\n                 n_head=8,\n                 d_model=512,\n                 d_k=64,\n                 d_v=64,\n                 dropout=0.1,\n                 qkv_bias=False):\n        super().__init__()\n        self.n_head = n_head",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "SATRNEncoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class SATRNEncoder(nn.Layer):\n    def __init__(self,\n                 n_layers=12,\n                 n_head=8,\n                 d_k=64,\n                 d_v=64,\n                 d_model=512,\n                 n_position=100,\n                 d_inner=256,\n                 dropout=0.1):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "PositionwiseFeedForward",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class PositionwiseFeedForward(nn.Layer):\n    def __init__(self, d_in, d_hid, dropout=0.1):\n        super().__init__()\n        self.w_1 = nn.Linear(d_in, d_hid)\n        self.w_2 = nn.Linear(d_hid, d_in)\n        self.act = nn.GELU()\n        self.dropout = nn.Dropout(dropout)\n    def forward(self, x):\n        x = self.w_1(x)\n        x = self.act(x)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class PositionalEncoding(nn.Layer):\n    def __init__(self, d_hid=512, n_position=200, dropout=0):\n        super().__init__()\n        self.dropout = nn.Dropout(p=dropout)\n        # Not a parameter\n        # Position table of shape (1, n_position, d_hid)\n        self.register_buffer(\n            'position_table',\n            self._get_sinusoid_encoding_table(n_position, d_hid))\n    def _get_sinusoid_encoding_table(self, n_position, d_hid):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "TFDecoderLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class TFDecoderLayer(nn.Layer):\n    def __init__(self,\n                 d_model=512,\n                 d_inner=256,\n                 n_head=8,\n                 d_k=64,\n                 d_v=64,\n                 dropout=0.1,\n                 qkv_bias=False,\n                 operation_order=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "SATRNDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class SATRNDecoder(nn.Layer):\n    def __init__(self,\n                 n_layers=6,\n                 d_embedding=512,\n                 n_head=8,\n                 d_k=64,\n                 d_v=64,\n                 d_model=512,\n                 d_inner=256,\n                 n_position=200,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "SATRNHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "peekOfCode": "class SATRNHead(nn.Layer):\n    def __init__(self, enc_cfg, dec_cfg, **kwargs):\n        super(SATRNHead, self).__init__()\n        # encoder module\n        self.encoder = SATRNEncoder(**enc_cfg)\n        # decoder module\n        self.decoder = SATRNDecoder(**dec_cfg)\n    def forward(self, feat, targets=None):\n        if targets is not None:\n            targets, valid_ratio = targets",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_satrn_head",
        "documentation": {}
    },
    {
        "label": "SPINAttentionHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_spin_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_spin_att_head",
        "peekOfCode": "class SPINAttentionHead(nn.Layer):\n    def __init__(self, in_channels, out_channels, hidden_size, **kwargs):\n        super(SPINAttentionHead, self).__init__()\n        self.input_size = in_channels\n        self.hidden_size = hidden_size\n        self.num_classes = out_channels\n        self.attention_cell = AttentionLSTMCell(\n            in_channels, hidden_size, out_channels, use_gru=False)\n        self.generator = nn.Linear(hidden_size, out_channels)\n    def _char_to_onehot(self, input_char, onehot_dim):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_spin_att_head",
        "documentation": {}
    },
    {
        "label": "AttentionLSTMCell",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_spin_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_spin_att_head",
        "peekOfCode": "class AttentionLSTMCell(nn.Layer):\n    def __init__(self, input_size, hidden_size, num_embeddings, use_gru=False):\n        super(AttentionLSTMCell, self).__init__()\n        self.i2h = nn.Linear(input_size, hidden_size, bias_attr=False)\n        self.h2h = nn.Linear(hidden_size, hidden_size)\n        self.score = nn.Linear(hidden_size, 1, bias_attr=False)\n        if not use_gru:\n            self.rnn = nn.LSTMCell(\n                input_size=input_size + num_embeddings, hidden_size=hidden_size)\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_spin_att_head",
        "documentation": {}
    },
    {
        "label": "PVAM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "peekOfCode": "class PVAM(nn.Layer):\n    def __init__(self, in_channels, char_num, max_text_length, num_heads,\n                 num_encoder_tus, hidden_dims):\n        super(PVAM, self).__init__()\n        self.char_num = char_num\n        self.max_length = max_text_length\n        self.num_heads = num_heads\n        self.num_encoder_TUs = num_encoder_tus\n        self.hidden_dims = hidden_dims\n        # Transformer encoder",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "documentation": {}
    },
    {
        "label": "GSRM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "peekOfCode": "class GSRM(nn.Layer):\n    def __init__(self, in_channels, char_num, max_text_length, num_heads,\n                 num_encoder_tus, num_decoder_tus, hidden_dims):\n        super(GSRM, self).__init__()\n        self.char_num = char_num\n        self.max_length = max_text_length\n        self.num_heads = num_heads\n        self.num_encoder_TUs = num_encoder_tus\n        self.num_decoder_TUs = num_decoder_tus\n        self.hidden_dims = hidden_dims",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "documentation": {}
    },
    {
        "label": "VSFD",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "peekOfCode": "class VSFD(nn.Layer):\n    def __init__(self, in_channels=512, pvam_ch=512, char_num=38):\n        super(VSFD, self).__init__()\n        self.char_num = char_num\n        self.fc0 = paddle.nn.Linear(\n            in_features=in_channels * 2, out_features=pvam_ch)\n        self.fc1 = paddle.nn.Linear(\n            in_features=pvam_ch, out_features=self.char_num)\n    def forward(self, pvam_feature, gsrm_feature):\n        b, t, c1 = pvam_feature.shape",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "documentation": {}
    },
    {
        "label": "SRNHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "peekOfCode": "class SRNHead(nn.Layer):\n    def __init__(self, in_channels, out_channels, max_text_length, num_heads,\n                 num_encoder_TUs, num_decoder_TUs, hidden_dims, **kwargs):\n        super(SRNHead, self).__init__()\n        self.char_num = out_channels\n        self.max_length = max_text_length\n        self.num_heads = num_heads\n        self.num_encoder_TUs = num_encoder_TUs\n        self.num_decoder_TUs = num_decoder_TUs\n        self.hidden_dims = hidden_dims",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "documentation": {}
    },
    {
        "label": "gradient_clip",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "peekOfCode": "gradient_clip = 10\nclass PVAM(nn.Layer):\n    def __init__(self, in_channels, char_num, max_text_length, num_heads,\n                 num_encoder_tus, hidden_dims):\n        super(PVAM, self).__init__()\n        self.char_num = char_num\n        self.max_length = max_text_length\n        self.num_heads = num_heads\n        self.num_encoder_TUs = num_encoder_tus\n        self.hidden_dims = hidden_dims",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_srn_head",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class PositionalEncoding(nn.Layer):\n    def __init__(self, d_hid, n_position=200):\n        super(PositionalEncoding, self).__init__()\n        self.register_buffer(\n            'pos_table', self._get_sinusoid_encoding_table(n_position, d_hid))\n    def _get_sinusoid_encoding_table(self, n_position, d_hid):\n        ''' Sinusoid position encoding table '''\n        def get_position_angle_vec(position):\n            return [\n                position / np.power(10000, 2 * (hid_j // 2) / d_hid)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "ScaledDotProductAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class ScaledDotProductAttention(nn.Layer):\n    \"Scaled Dot-Product Attention\"\n    def __init__(self, temperature, attn_dropout=0.1):\n        super(ScaledDotProductAttention, self).__init__()\n        self.temperature = temperature\n        self.dropout = nn.Dropout(attn_dropout)\n        self.softmax = nn.Softmax(axis=2)\n    def forward(self, q, k, v, mask=None):\n        k = paddle.transpose(k, perm=[0, 2, 1])\n        attn = paddle.bmm(q, k)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "MultiHeadAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class MultiHeadAttention(nn.Layer):\n    \" Multi-Head Attention module\"\n    def __init__(self, n_head, d_model, d_k, d_v, dropout=0.1):\n        super(MultiHeadAttention, self).__init__()\n        self.n_head = n_head\n        self.d_k = d_k\n        self.d_v = d_v\n        self.w_qs = nn.Linear(\n            d_model,\n            n_head * d_k,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "PositionwiseFeedForward",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class PositionwiseFeedForward(nn.Layer):\n    def __init__(self, d_in, d_hid, dropout=0.1):\n        super(PositionwiseFeedForward, self).__init__()\n        self.w_1 = nn.Conv1D(d_in, d_hid, 1)  # position-wise\n        self.w_2 = nn.Conv1D(d_hid, d_in, 1)  # position-wise\n        self.layer_norm = nn.LayerNorm(d_in)\n        self.dropout = nn.Dropout(dropout)\n    def forward(self, x):\n        residual = x\n        x = paddle.transpose(x, perm=[0, 2, 1])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "EncoderLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class EncoderLayer(nn.Layer):\n    ''' Compose with two layers '''\n    def __init__(self, d_model, d_inner, n_head, d_k, d_v, dropout=0.1):\n        super(EncoderLayer, self).__init__()\n        self.slf_attn = MultiHeadAttention(\n            n_head, d_model, d_k, d_v, dropout=dropout)\n        self.pos_ffn = PositionwiseFeedForward(\n            d_model, d_inner, dropout=dropout)\n    def forward(self, enc_input, slf_attn_mask=None):\n        enc_output = self.slf_attn(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "Transformer_Encoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class Transformer_Encoder(nn.Layer):\n    def __init__(self,\n                 n_layers=2,\n                 n_head=8,\n                 d_word_vec=512,\n                 d_k=64,\n                 d_v=64,\n                 d_model=512,\n                 d_inner=2048,\n                 dropout=0.1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "PP_layer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class PP_layer(nn.Layer):\n    def __init__(self, n_dim=512, N_max_character=25, n_position=256):\n        super(PP_layer, self).__init__()\n        self.character_len = N_max_character\n        self.f0_embedding = nn.Embedding(N_max_character, n_dim)\n        self.w0 = nn.Linear(N_max_character, n_position)\n        self.wv = nn.Linear(n_dim, n_dim)\n        self.we = nn.Linear(n_dim, N_max_character)\n        self.active = nn.Tanh()\n        self.softmax = nn.Softmax(axis=2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "Prediction",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class Prediction(nn.Layer):\n    def __init__(self,\n                 n_dim=512,\n                 n_position=256,\n                 N_max_character=25,\n                 n_class=37):\n        super(Prediction, self).__init__()\n        self.pp = PP_layer(\n            n_dim=n_dim, N_max_character=N_max_character, n_position=n_position)\n        self.pp_share = PP_layer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "MLM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class MLM(nn.Layer):\n    \"Architecture of MLM\"\n    def __init__(self, n_dim=512, n_position=256, max_text_length=25):\n        super(MLM, self).__init__()\n        self.MLM_SequenceModeling_mask = Transformer_Encoder(\n            n_layers=2, n_position=n_position)\n        self.MLM_SequenceModeling_WCL = Transformer_Encoder(\n            n_layers=1, n_position=n_position)\n        self.pos_embedding = nn.Embedding(max_text_length, n_dim)\n        self.w0_linear = nn.Linear(1, n_position)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "MLM_VRM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class MLM_VRM(nn.Layer):\n    \"\"\"\n    MLM+VRM, MLM is only used in training.\n    ratio controls the occluded number in a batch.\n    The pipeline of VisionLAN in testing is very concise with only a backbone + sequence modeling(transformer unit) + prediction layer(pp layer).\n    x: input image\n    label_pos: character index\n    training_step: LF or LA process\n    output\n    text_pre: prediction of VRM",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "VLHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "class VLHead(nn.Layer):\n    \"\"\"\n    Architecture of VisionLAN\n    \"\"\"\n    def __init__(self,\n                 in_channels,\n                 out_channels=36,\n                 n_layers=3,\n                 n_position=256,\n                 n_dim=512,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "trans_1d_2d",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "peekOfCode": "def trans_1d_2d(x):\n    b, w_h, c = x.shape  # b, 256, 512\n    x = paddle.transpose(x, perm=[0, 2, 1])\n    x = paddle.reshape(x, [-1, c, 32, 8])\n    x = paddle.transpose(x, perm=[0, 1, 3, 2])  # [b, c, 8, 32]\n    return x\nclass MLM_VRM(nn.Layer):\n    \"\"\"\n    MLM+VRM, MLM is only used in training.\n    ratio controls the occluded number in a batch.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.rec_visionlan_head",
        "documentation": {}
    },
    {
        "label": "WrapEncoderForFeature",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class WrapEncoderForFeature(nn.Layer):\n    def __init__(self,\n                 src_vocab_size,\n                 max_length,\n                 n_layer,\n                 n_head,\n                 d_key,\n                 d_value,\n                 d_model,\n                 d_inner_hid,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "WrapEncoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class WrapEncoder(nn.Layer):\n    \"\"\"\n    embedder + encoder\n    \"\"\"\n    def __init__(self,\n                 src_vocab_size,\n                 max_length,\n                 n_layer,\n                 n_head,\n                 d_key,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class Encoder(nn.Layer):\n    \"\"\"\n    encoder\n    \"\"\"\n    def __init__(self,\n                 n_layer,\n                 n_head,\n                 d_key,\n                 d_value,\n                 d_model,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "EncoderLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class EncoderLayer(nn.Layer):\n    \"\"\"\n    EncoderLayer\n    \"\"\"\n    def __init__(self,\n                 n_head,\n                 d_key,\n                 d_value,\n                 d_model,\n                 d_inner_hid,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "MultiHeadAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class MultiHeadAttention(nn.Layer):\n    \"\"\"\n    Multi-Head Attention\n    \"\"\"\n    def __init__(self, d_key, d_value, d_model, n_head=1, dropout_rate=0.):\n        super(MultiHeadAttention, self).__init__()\n        self.n_head = n_head\n        self.d_key = d_key\n        self.d_value = d_value\n        self.d_model = d_model",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "PrePostProcessLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class PrePostProcessLayer(nn.Layer):\n    \"\"\"\n    PrePostProcessLayer\n    \"\"\"\n    def __init__(self, process_cmd, d_model, dropout_rate):\n        super(PrePostProcessLayer, self).__init__()\n        self.process_cmd = process_cmd\n        self.functors = []\n        for cmd in self.process_cmd:\n            if cmd == \"a\":  # add residual connection",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "PrepareEncoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class PrepareEncoder(nn.Layer):\n    def __init__(self,\n                 src_vocab_size,\n                 src_emb_dim,\n                 src_max_len,\n                 dropout_rate=0,\n                 bos_idx=0,\n                 word_emb_param_name=None,\n                 pos_enc_param_name=None):\n        super(PrepareEncoder, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "PrepareDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class PrepareDecoder(nn.Layer):\n    def __init__(self,\n                 src_vocab_size,\n                 src_emb_dim,\n                 src_max_len,\n                 dropout_rate=0,\n                 bos_idx=0,\n                 word_emb_param_name=None,\n                 pos_enc_param_name=None):\n        super(PrepareDecoder, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "FFN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "class FFN(nn.Layer):\n    \"\"\"\n    Feed-Forward Network\n    \"\"\"\n    def __init__(self, d_inner_hid, d_model, dropout_rate):\n        super(FFN, self).__init__()\n        self.dropout_rate = dropout_rate\n        self.fc1 = paddle.nn.Linear(\n            in_features=d_model, out_features=d_inner_hid)\n        self.fc2 = paddle.nn.Linear(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "gradient_clip",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "peekOfCode": "gradient_clip = 10\nclass WrapEncoderForFeature(nn.Layer):\n    def __init__(self,\n                 src_vocab_size,\n                 max_length,\n                 n_layer,\n                 n_head,\n                 d_key,\n                 d_value,\n                 d_model,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.self_attention",
        "documentation": {}
    },
    {
        "label": "MultiHeadedAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class MultiHeadedAttention(nn.Layer):\n    def __init__(self, h, d_model, dropout=0.1, compress_attention=False):\n        super(MultiHeadedAttention, self).__init__()\n        assert d_model % h == 0\n        self.d_k = d_model // h\n        self.h = h\n        self.linears = clones(nn.Linear(d_model, d_model), 4)\n        self.attn = None\n        self.dropout = nn.Dropout(p=dropout, mode=\"downscale_in_infer\")\n        self.compress_attention = compress_attention",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "ResNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class ResNet(nn.Layer):\n    def __init__(self, num_in, block, layers):\n        super(ResNet, self).__init__()\n        self.conv1 = nn.Conv2D(num_in, 64, kernel_size=3, stride=1, padding=1)\n        self.bn1 = nn.BatchNorm2D(64, use_global_stats=True)\n        self.relu1 = nn.ReLU()\n        self.pool = nn.MaxPool2D((2, 2), (2, 2))\n        self.conv2 = nn.Conv2D(64, 128, kernel_size=3, stride=1, padding=1)\n        self.bn2 = nn.BatchNorm2D(128, use_global_stats=True)\n        self.relu2 = nn.ReLU()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "Bottleneck",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class Bottleneck(nn.Layer):\n    def __init__(self, input_dim):\n        super(Bottleneck, self).__init__()\n        self.conv1 = nn.Conv2D(input_dim, input_dim, 1)\n        self.bn1 = nn.BatchNorm2D(input_dim, use_global_stats=True)\n        self.relu = nn.ReLU()\n        self.conv2 = nn.Conv2D(input_dim, input_dim, 3, 1, 1)\n        self.bn2 = nn.BatchNorm2D(input_dim, use_global_stats=True)\n    def forward(self, x):\n        residual = x",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class PositionalEncoding(nn.Layer):\n    \"Implement the PE function.\"\n    def __init__(self, dropout, dim, max_len=5000):\n        super(PositionalEncoding, self).__init__()\n        self.dropout = nn.Dropout(p=dropout, mode=\"downscale_in_infer\")\n        pe = paddle.zeros([max_len, dim])\n        position = paddle.arange(0, max_len, dtype=paddle.float32).unsqueeze(1)\n        div_term = paddle.exp(\n            paddle.arange(0, dim, 2).astype('float32') *\n            (-math.log(10000.0) / dim))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "PositionwiseFeedForward",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class PositionwiseFeedForward(nn.Layer):\n    \"Implements FFN equation.\"\n    def __init__(self, d_model, d_ff, dropout=0.1):\n        super(PositionwiseFeedForward, self).__init__()\n        self.w_1 = nn.Linear(d_model, d_ff)\n        self.w_2 = nn.Linear(d_ff, d_model)\n        self.dropout = nn.Dropout(dropout, mode=\"downscale_in_infer\")\n    def forward(self, x):\n        return self.w_2(self.dropout(F.relu(self.w_1(x))))\nclass Generator(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "Generator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class Generator(nn.Layer):\n    \"Define standard linear + softmax generation step.\"\n    def __init__(self, d_model, vocab):\n        super(Generator, self).__init__()\n        self.proj = nn.Linear(d_model, vocab)\n        self.relu = nn.ReLU()\n    def forward(self, x):\n        out = self.proj(x)\n        return out\nclass Embeddings(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "Embeddings",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class Embeddings(nn.Layer):\n    def __init__(self, d_model, vocab):\n        super(Embeddings, self).__init__()\n        self.lut = nn.Embedding(vocab, d_model)\n        self.d_model = d_model\n    def forward(self, x):\n        embed = self.lut(x) * math.sqrt(self.d_model)\n        return embed\nclass LayerNorm(nn.Layer):\n    \"Construct a layernorm module (See citation for details).\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class LayerNorm(nn.Layer):\n    \"Construct a layernorm module (See citation for details).\"\n    def __init__(self, features, eps=1e-6):\n        super(LayerNorm, self).__init__()\n        self.a_2 = self.create_parameter(\n            shape=[features],\n            default_initializer=paddle.nn.initializer.Constant(1.0))\n        self.b_2 = self.create_parameter(\n            shape=[features],\n            default_initializer=paddle.nn.initializer.Constant(0.0))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class Decoder(nn.Layer):\n    def __init__(self):\n        super(Decoder, self).__init__()\n        self.mask_multihead = MultiHeadedAttention(\n            h=16, d_model=1024, dropout=0.1)\n        self.mul_layernorm1 = LayerNorm(1024)\n        self.multihead = MultiHeadedAttention(h=16, d_model=1024, dropout=0.1)\n        self.mul_layernorm2 = LayerNorm(1024)\n        self.pff = PositionwiseFeedForward(1024, 2048)\n        self.mul_layernorm3 = LayerNorm(1024)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "BasicBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class BasicBlock(nn.Layer):\n    def __init__(self, inplanes, planes, downsample):\n        super(BasicBlock, self).__init__()\n        self.conv1 = nn.Conv2D(\n            inplanes, planes, kernel_size=3, stride=1, padding=1)\n        self.bn1 = nn.BatchNorm2D(planes, use_global_stats=True)\n        self.relu = nn.ReLU()\n        self.conv2 = nn.Conv2D(\n            planes, planes, kernel_size=3, stride=1, padding=1)\n        self.bn2 = nn.BatchNorm2D(planes, use_global_stats=True)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class Encoder(nn.Layer):\n    def __init__(self):\n        super(Encoder, self).__init__()\n        self.cnn = ResNet(num_in=1, block=BasicBlock, layers=[1, 2, 5, 3])\n    def forward(self, input):\n        conv_result = self.cnn(input)\n        return conv_result\nclass Transformer(nn.Layer):\n    def __init__(self, in_channels=1, alphabet='0123456789'):\n        super(Transformer, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "Transformer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "class Transformer(nn.Layer):\n    def __init__(self, in_channels=1, alphabet='0123456789'):\n        super(Transformer, self).__init__()\n        self.alphabet = alphabet\n        word_n_class = self.get_alphabet_len()\n        self.embedding_word_with_upperword = Embeddings(512, word_n_class)\n        self.pe = PositionalEncoding(dim=512, dropout=0.1, max_len=5000)\n        self.encoder = Encoder()\n        self.decoder = Decoder()\n        self.generator_word_with_upperword = Generator(1024, word_n_class)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "subsequent_mask",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "def subsequent_mask(size):\n    \"\"\"Generate a square mask for the sequence. The masked positions are filled with float('-inf').\n        Unmasked positions are filled with float(0.0).\n    \"\"\"\n    mask = paddle.ones([1, size, size], dtype='float32')\n    mask_inf = paddle.triu(\n        paddle.full(\n            shape=[1, size, size], dtype='float32', fill_value='-inf'),\n        diagonal=1)\n    mask = mask + mask_inf",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "clones",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "def clones(module, N):\n    return nn.LayerList([copy.deepcopy(module) for _ in range(N)])\ndef masked_fill(x, mask, value):\n    y = paddle.full(x.shape, value, x.dtype)\n    return paddle.where(mask, y, x)\ndef attention(query, key, value, mask=None, dropout=None, attention_map=None):\n    d_k = query.shape[-1]\n    scores = paddle.matmul(query,\n                           paddle.transpose(key, [0, 1, 3, 2])) / math.sqrt(d_k)\n    if mask is not None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "masked_fill",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "def masked_fill(x, mask, value):\n    y = paddle.full(x.shape, value, x.dtype)\n    return paddle.where(mask, y, x)\ndef attention(query, key, value, mask=None, dropout=None, attention_map=None):\n    d_k = query.shape[-1]\n    scores = paddle.matmul(query,\n                           paddle.transpose(key, [0, 1, 3, 2])) / math.sqrt(d_k)\n    if mask is not None:\n        scores = masked_fill(scores, mask == 0, float('-inf'))\n    else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "attention",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "peekOfCode": "def attention(query, key, value, mask=None, dropout=None, attention_map=None):\n    d_k = query.shape[-1]\n    scores = paddle.matmul(query,\n                           paddle.transpose(key, [0, 1, 3, 2])) / math.sqrt(d_k)\n    if mask is not None:\n        scores = masked_fill(scores, mask == 0, float('-inf'))\n    else:\n        pass\n    p_attn = F.softmax(scores, axis=-1)\n    if dropout is not None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.sr_rensnet_transformer",
        "documentation": {}
    },
    {
        "label": "TableAttentionHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "peekOfCode": "class TableAttentionHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 hidden_size,\n                 in_max_len=488,\n                 max_text_length=800,\n                 out_channels=30,\n                 loc_reg_num=4,\n                 **kwargs):\n        super(TableAttentionHead, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "documentation": {}
    },
    {
        "label": "SLAHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "peekOfCode": "class SLAHead(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 hidden_size,\n                 out_channels=30,\n                 max_text_length=500,\n                 loc_reg_num=4,\n                 fc_decay=0.0,\n                 **kwargs):\n        \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "documentation": {}
    },
    {
        "label": "get_para_bias_attr",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "peekOfCode": "def get_para_bias_attr(l2_decay, k):\n    if l2_decay > 0:\n        regularizer = paddle.regularizer.L2Decay(l2_decay)\n        stdv = 1.0 / math.sqrt(k * 1.0)\n        initializer = nn.initializer.Uniform(-stdv, stdv)\n    else:\n        regularizer = None\n        initializer = None\n    weight_attr = ParamAttr(regularizer=regularizer, initializer=initializer)\n    bias_attr = ParamAttr(regularizer=regularizer, initializer=initializer)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_att_head",
        "documentation": {}
    },
    {
        "label": "TableMasterHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "class TableMasterHead(nn.Layer):\n    \"\"\"\n    Split to two transformer header at the last layer.\n    Cls_layer is used to structure token classification.\n    Bbox_layer is used to regress bbox coord.\n    \"\"\"\n    def __init__(self,\n                 in_channels,\n                 out_channels=30,\n                 headers=8,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "DecoderLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "class DecoderLayer(nn.Layer):\n    \"\"\"\n    Decoder is made of self attention, srouce attention and feed forward.\n    \"\"\"\n    def __init__(self, headers, d_model, dropout, d_ff):\n        super(DecoderLayer, self).__init__()\n        self.self_attn = MultiHeadAttention(headers, d_model, dropout)\n        self.src_attn = MultiHeadAttention(headers, d_model, dropout)\n        self.feed_forward = FeedForward(d_model, d_ff, dropout)\n        self.sublayer = clones(SubLayerConnection(d_model, dropout), 3)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "MultiHeadAttention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "class MultiHeadAttention(nn.Layer):\n    def __init__(self, headers, d_model, dropout):\n        super(MultiHeadAttention, self).__init__()\n        assert d_model % headers == 0\n        self.d_k = int(d_model / headers)\n        self.headers = headers\n        self.linears = clones(nn.Linear(d_model, d_model), 4)\n        self.attn = None\n        self.dropout = nn.Dropout(dropout)\n    def forward(self, query, key, value, mask=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "FeedForward",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "class FeedForward(nn.Layer):\n    def __init__(self, d_model, d_ff, dropout):\n        super(FeedForward, self).__init__()\n        self.w_1 = nn.Linear(d_model, d_ff)\n        self.w_2 = nn.Linear(d_ff, d_model)\n        self.dropout = nn.Dropout(dropout)\n    def forward(self, x):\n        return self.w_2(self.dropout(F.relu(self.w_1(x))))\nclass SubLayerConnection(nn.Layer):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "SubLayerConnection",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "class SubLayerConnection(nn.Layer):\n    \"\"\"\n    A residual connection followed by a layer norm.\n    Note for code simplicity the norm is first as opposed to last.\n    \"\"\"\n    def __init__(self, size, dropout):\n        super(SubLayerConnection, self).__init__()\n        self.norm = nn.LayerNorm(size)\n        self.dropout = nn.Dropout(dropout)\n    def forward(self, x, sublayer):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "Embeddings",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "class Embeddings(nn.Layer):\n    def __init__(self, d_model, vocab):\n        super(Embeddings, self).__init__()\n        self.lut = nn.Embedding(vocab, d_model)\n        self.d_model = d_model\n    def forward(self, *input):\n        x = input[0]\n        return self.lut(x) * math.sqrt(self.d_model)\nclass PositionalEncoding(nn.Layer):\n    \"\"\" Implement the PE function. \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "class PositionalEncoding(nn.Layer):\n    \"\"\" Implement the PE function. \"\"\"\n    def __init__(self, d_model, dropout=0., max_len=5000):\n        super(PositionalEncoding, self).__init__()\n        self.dropout = nn.Dropout(p=dropout)\n        # Compute the positional encodings once in log space.\n        pe = paddle.zeros([max_len, d_model])\n        position = paddle.arange(0, max_len).unsqueeze(1).astype('float32')\n        div_term = paddle.exp(\n            paddle.arange(0, d_model, 2) * -math.log(10000.0) / d_model)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "masked_fill",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "def masked_fill(x, mask, value):\n    mask = mask.astype(x.dtype)\n    return x * paddle.logical_not(mask).astype(x.dtype) + mask * value\ndef self_attention(query, key, value, mask=None, dropout=None):\n    \"\"\"\n    Compute 'Scale Dot Product Attention'\n    \"\"\"\n    d_k = value.shape[-1]\n    score = paddle.matmul(query, key.transpose([0, 1, 3, 2]) / math.sqrt(d_k))\n    if mask is not None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "self_attention",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "def self_attention(query, key, value, mask=None, dropout=None):\n    \"\"\"\n    Compute 'Scale Dot Product Attention'\n    \"\"\"\n    d_k = value.shape[-1]\n    score = paddle.matmul(query, key.transpose([0, 1, 3, 2]) / math.sqrt(d_k))\n    if mask is not None:\n        # score = score.masked_fill(mask == 0, -1e9) # b, h, L, L\n        score = masked_fill(score, mask == 0, -6.55e4)  # for fp16\n    p_attn = F.softmax(score, axis=-1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "clones",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "peekOfCode": "def clones(module, N):\n    \"\"\" Produce N identical layers \"\"\"\n    return nn.LayerList([copy.deepcopy(module) for _ in range(N)])\nclass Embeddings(nn.Layer):\n    def __init__(self, d_model, vocab):\n        super(Embeddings, self).__init__()\n        self.lut = nn.Embedding(vocab, d_model)\n        self.d_model = d_model\n    def forward(self, *input):\n        x = input[0]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.heads.table_master_head",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channel=96,\n                 out_channel=96,\n                 kernel_size=3,\n                 stride=1,\n                 groups=1,\n                 act='leaky_relu'):\n        super(ConvBNLayer, self).__init__()\n        initializer = nn.initializer.KaimingUniform()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "documentation": {}
    },
    {
        "label": "DPModule",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "peekOfCode": "class DPModule(nn.Layer):\n    \"\"\"\n    Depth-wise and point-wise module.\n     Args:\n        in_channel (int): The input channels of this Module.\n        out_channel (int): The output channels of this Module.\n        kernel_size (int): The conv2d kernel size of this Module.\n        stride (int): The conv2d's stride of this Module.\n        act (str): The activation function of this Module,\n                   Now support `leaky_relu` and `hard_swish`.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "documentation": {}
    },
    {
        "label": "DarknetBottleneck",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "peekOfCode": "class DarknetBottleneck(nn.Layer):\n    \"\"\"The basic bottleneck block used in Darknet.\n    Each Block consists of two ConvModules and the input is added to the\n    final output. Each ConvModule is composed of Conv, BN, and act.\n    The first convLayer has filter size of 1x1 and the second one has the\n    filter size of 3x3.\n    Args:\n        in_channels (int): The input channels of this Module.\n        out_channels (int): The output channels of this Module.\n        expansion (int): The kernel size of the convolution. Default: 0.5",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "documentation": {}
    },
    {
        "label": "CSPLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "peekOfCode": "class CSPLayer(nn.Layer):\n    \"\"\"Cross Stage Partial Layer.\n    Args:\n        in_channels (int): The input channels of the CSP layer.\n        out_channels (int): The output channels of the CSP layer.\n        expand_ratio (float): Ratio to adjust the number of channels of the\n            hidden layer. Default: 0.5\n        num_blocks (int): Number of blocks. Default: 1\n        add_identity (bool): Whether to add identity in blocks.\n            Default: True",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "documentation": {}
    },
    {
        "label": "Channel_T",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "peekOfCode": "class Channel_T(nn.Layer):\n    def __init__(self,\n                 in_channels=[116, 232, 464],\n                 out_channels=96,\n                 act=\"leaky_relu\"):\n        super(Channel_T, self).__init__()\n        self.convs = nn.LayerList()\n        for i in range(len(in_channels)):\n            self.convs.append(\n                ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "documentation": {}
    },
    {
        "label": "CSPPAN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "peekOfCode": "class CSPPAN(nn.Layer):\n    \"\"\"Path Aggregation Network with CSP module.\n    Args:\n        in_channels (List[int]): Number of input channels per scale.\n        out_channels (int): Number of output channels (used at each scale)\n        kernel_size (int): The conv2d kernel size of this Module.\n        num_csp_blocks (int): Number of bottlenecks in CSPLayer. Default: 1\n        use_depthwise (bool): Whether to depthwise separable convolution in\n            blocks. Default: True\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "peekOfCode": "__all__ = ['CSPPAN']\nclass ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channel=96,\n                 out_channel=96,\n                 kernel_size=3,\n                 stride=1,\n                 groups=1,\n                 act='leaky_relu'):\n        super(ConvBNLayer, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.csp_pan",
        "documentation": {}
    },
    {
        "label": "Conv_BN_ReLU",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "peekOfCode": "class Conv_BN_ReLU(nn.Layer):\n    def __init__(self,\n                 in_planes,\n                 out_planes,\n                 kernel_size=1,\n                 stride=1,\n                 padding=0):\n        super(Conv_BN_ReLU, self).__init__()\n        self.conv = nn.Conv2D(\n            in_planes,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "documentation": {}
    },
    {
        "label": "FPEM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "peekOfCode": "class FPEM(nn.Layer):\n    def __init__(self, in_channels, out_channels):\n        super(FPEM, self).__init__()\n        planes = out_channels\n        self.dwconv3_1 = nn.Conv2D(\n            planes,\n            planes,\n            kernel_size=3,\n            stride=1,\n            padding=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "documentation": {}
    },
    {
        "label": "CTFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "peekOfCode": "class CTFPN(nn.Layer):\n    def __init__(self, in_channels, out_channel=128):\n        super(CTFPN, self).__init__()\n        self.out_channels = out_channel * 4\n        self.reduce_layer1 = Conv_BN_ReLU(in_channels[0], 128)\n        self.reduce_layer2 = Conv_BN_ReLU(in_channels[1], 128)\n        self.reduce_layer3 = Conv_BN_ReLU(in_channels[2], 128)\n        self.reduce_layer4 = Conv_BN_ReLU(in_channels[3], 128)\n        self.fpem1 = FPEM(in_channels=(64, 128, 256, 512), out_channels=128)\n        self.fpem2 = FPEM(in_channels=(64, 128, 256, 512), out_channels=128)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "documentation": {}
    },
    {
        "label": "ones_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "peekOfCode": "ones_ = Constant(value=1.)\nzeros_ = Constant(value=0.)\n__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../../..')))\nclass Conv_BN_ReLU(nn.Layer):\n    def __init__(self,\n                 in_planes,\n                 out_planes,\n                 kernel_size=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "peekOfCode": "zeros_ = Constant(value=0.)\n__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../../..')))\nclass Conv_BN_ReLU(nn.Layer):\n    def __init__(self,\n                 in_planes,\n                 out_planes,\n                 kernel_size=1,\n                 stride=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../../..')))\nclass Conv_BN_ReLU(nn.Layer):\n    def __init__(self,\n                 in_planes,\n                 out_planes,\n                 kernel_size=1,\n                 stride=1,\n                 padding=0):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.ct_fpn",
        "documentation": {}
    },
    {
        "label": "DSConv",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "peekOfCode": "class DSConv(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 padding,\n                 stride=1,\n                 groups=None,\n                 if_act=True,\n                 act=\"relu\",",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "documentation": {}
    },
    {
        "label": "DBFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "peekOfCode": "class DBFPN(nn.Layer):\n    def __init__(self, in_channels, out_channels, use_asf=False, **kwargs):\n        super(DBFPN, self).__init__()\n        self.out_channels = out_channels\n        self.use_asf = use_asf\n        weight_attr = paddle.nn.initializer.KaimingUniform()\n        self.in2_conv = nn.Conv2D(\n            in_channels=in_channels[0],\n            out_channels=self.out_channels,\n            kernel_size=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "documentation": {}
    },
    {
        "label": "RSELayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "peekOfCode": "class RSELayer(nn.Layer):\n    def __init__(self, in_channels, out_channels, kernel_size, shortcut=True):\n        super(RSELayer, self).__init__()\n        weight_attr = paddle.nn.initializer.KaimingUniform()\n        self.out_channels = out_channels\n        self.in_conv = nn.Conv2D(\n            in_channels=in_channels,\n            out_channels=self.out_channels,\n            kernel_size=kernel_size,\n            padding=int(kernel_size // 2),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "documentation": {}
    },
    {
        "label": "RSEFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "peekOfCode": "class RSEFPN(nn.Layer):\n    def __init__(self, in_channels, out_channels, shortcut=True, **kwargs):\n        super(RSEFPN, self).__init__()\n        self.out_channels = out_channels\n        self.ins_conv = nn.LayerList()\n        self.inp_conv = nn.LayerList()\n        self.intracl = False\n        if 'intracl' in kwargs.keys() and kwargs['intracl'] is True:\n            self.intracl = kwargs['intracl']\n            self.incl1 = IntraCLBlock(self.out_channels // 4, reduce_factor=2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "documentation": {}
    },
    {
        "label": "LKPAN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "peekOfCode": "class LKPAN(nn.Layer):\n    def __init__(self, in_channels, out_channels, mode='large', **kwargs):\n        super(LKPAN, self).__init__()\n        self.out_channels = out_channels\n        weight_attr = paddle.nn.initializer.KaimingUniform()\n        self.ins_conv = nn.LayerList()\n        self.inp_conv = nn.LayerList()\n        # pan head\n        self.pan_head_conv = nn.LayerList()\n        self.pan_lat_conv = nn.LayerList()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "documentation": {}
    },
    {
        "label": "ASFBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "peekOfCode": "class ASFBlock(nn.Layer):\n    \"\"\"\n    This code is refered from:\n        https://github.com/MhLiao/DB/blob/master/decoders/feature_attention.py\n    \"\"\"\n    def __init__(self, in_channels, inter_channels, out_features_num=4):\n        \"\"\"\n        Adaptive Scale Fusion (ASF) block of DBNet++\n        Args:\n            in_channels: the number of channels in the input data",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../../..')))\nfrom ppocr.modeling.backbones.det_mobilenet_v3 import SEModule\nclass DSConv(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 padding,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.db_fpn",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 padding,\n                 groups=1,\n                 if_act=True,\n                 act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "documentation": {}
    },
    {
        "label": "DeConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "peekOfCode": "class DeConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 padding,\n                 groups=1,\n                 if_act=True,\n                 act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "documentation": {}
    },
    {
        "label": "EASTFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "peekOfCode": "class EASTFPN(nn.Layer):\n    def __init__(self, in_channels, model_name, **kwargs):\n        super(EASTFPN, self).__init__()\n        self.model_name = model_name\n        if self.model_name == \"large\":\n            self.out_channels = 128\n        else:\n            self.out_channels = 64\n        self.in_channels = in_channels[::-1]\n        self.h1_conv = ConvBNLayer(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.east_fpn",
        "documentation": {}
    },
    {
        "label": "ConvNormLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "peekOfCode": "class ConvNormLayer(nn.Layer):\n    def __init__(self,\n                 ch_in,\n                 ch_out,\n                 filter_size,\n                 stride,\n                 groups=1,\n                 norm_type='bn',\n                 norm_decay=0.,\n                 norm_groups=32,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "documentation": {}
    },
    {
        "label": "FCEFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "peekOfCode": "class FCEFPN(nn.Layer):\n    \"\"\"\n    Feature Pyramid Network, see https://arxiv.org/abs/1612.03144\n    Args:\n        in_channels (list[int]): input channels of each level which can be \n            derived from the output shape of backbone by from_config\n        out_channels (list[int]): output channel of each level\n        spatial_scales (list[float]): the spatial scales between input feature\n            maps and original input image which can be derived from the output \n            shape of backbone by from_config",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "peekOfCode": "__all__ = ['FCEFPN']\nclass ConvNormLayer(nn.Layer):\n    def __init__(self,\n                 ch_in,\n                 ch_out,\n                 filter_size,\n                 stride,\n                 groups=1,\n                 norm_type='bn',\n                 norm_decay=0.,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fce_fpn",
        "documentation": {}
    },
    {
        "label": "Conv_BN_ReLU",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn",
        "peekOfCode": "class Conv_BN_ReLU(nn.Layer):\n    def __init__(self,\n                 in_planes,\n                 out_planes,\n                 kernel_size=1,\n                 stride=1,\n                 padding=0):\n        super(Conv_BN_ReLU, self).__init__()\n        self.conv = nn.Conv2D(\n            in_planes,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn",
        "documentation": {}
    },
    {
        "label": "FPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn",
        "peekOfCode": "class FPN(nn.Layer):\n    def __init__(self, in_channels, out_channels):\n        super(FPN, self).__init__()\n        # Top layer\n        self.toplayer_ = Conv_BN_ReLU(\n            in_channels[3], out_channels, kernel_size=1, stride=1, padding=0)\n        # Lateral layers\n        self.latlayer1_ = Conv_BN_ReLU(\n            in_channels[2], out_channels, kernel_size=1, stride=1, padding=0)\n        self.latlayer2_ = Conv_BN_ReLU(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn",
        "documentation": {}
    },
    {
        "label": "UpBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn_unet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn_unet",
        "peekOfCode": "class UpBlock(nn.Layer):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        assert isinstance(in_channels, int)\n        assert isinstance(out_channels, int)\n        self.conv1x1 = nn.Conv2D(\n            in_channels, in_channels, kernel_size=1, stride=1, padding=0)\n        self.conv3x3 = nn.Conv2D(\n            in_channels, out_channels, kernel_size=3, stride=1, padding=1)\n        self.deconv = nn.Conv2DTranspose(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn_unet",
        "documentation": {}
    },
    {
        "label": "FPN_UNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn_unet",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn_unet",
        "peekOfCode": "class FPN_UNet(nn.Layer):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        assert len(in_channels) == 4\n        assert isinstance(out_channels, int)\n        self.out_channels = out_channels\n        blocks_out_channels = [out_channels] + [\n            min(out_channels * 2**i, 256) for i in range(4)\n        ]\n        blocks_in_channels = [blocks_out_channels[1]] + [",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.fpn_unet",
        "documentation": {}
    },
    {
        "label": "IntraCLBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.intracl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.intracl",
        "peekOfCode": "class IntraCLBlock(nn.Layer):\n    def __init__(self, in_channels=96, reduce_factor=4):\n        super(IntraCLBlock, self).__init__()\n        self.channels = in_channels\n        self.rf = reduce_factor\n        weight_attr = paddle.nn.initializer.KaimingUniform()\n        self.conv1x1_reduce_channel = nn.Conv2D(\n            self.channels,\n            self.channels // self.rf,\n            kernel_size=1,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.intracl",
        "documentation": {}
    },
    {
        "label": "build_intraclblock_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.intracl",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.intracl",
        "peekOfCode": "def build_intraclblock_list(num_block):\n    IntraCLBlock_list = nn.LayerList()\n    for i in range(num_block):\n        IntraCLBlock_list.append(IntraCLBlock())\n    return IntraCLBlock_list",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.intracl",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 groups=1,\n                 is_vd_mode=False,\n                 act=None,\n                 name=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "documentation": {}
    },
    {
        "label": "DeConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "peekOfCode": "class DeConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size=4,\n                 stride=2,\n                 padding=1,\n                 groups=1,\n                 if_act=True,\n                 act=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "documentation": {}
    },
    {
        "label": "PGFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "peekOfCode": "class PGFPN(nn.Layer):\n    def __init__(self, in_channels, **kwargs):\n        super(PGFPN, self).__init__()\n        num_inputs = [2048, 2048, 1024, 512, 256]\n        num_outputs = [256, 256, 192, 192, 128]\n        self.out_channels = 128\n        self.conv_bn_layer_1 = ConvBNLayer(\n            in_channels=3,\n            out_channels=32,\n            kernel_size=3,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pg_fpn",
        "documentation": {}
    },
    {
        "label": "PoolAggregate",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "peekOfCode": "class PoolAggregate(nn.Layer):\n    def __init__(self, n_r, d_in, d_middle=None, d_out=None):\n        super(PoolAggregate, self).__init__()\n        if not d_middle:\n            d_middle = d_in\n        if not d_out:\n            d_out = d_in\n        self.d_in = d_in\n        self.d_middle = d_middle\n        self.d_out = d_out",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "documentation": {}
    },
    {
        "label": "WeightAggregate",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "peekOfCode": "class WeightAggregate(nn.Layer):\n    def __init__(self, n_r, d_in, d_middle=None, d_out=None):\n        super(WeightAggregate, self).__init__()\n        if not d_middle:\n            d_middle = d_in\n        if not d_out:\n            d_out = d_in\n        self.n_r = n_r\n        self.d_out = d_out\n        self.act = nn.Swish()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "documentation": {}
    },
    {
        "label": "GCN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "peekOfCode": "class GCN(nn.Layer):\n    def __init__(self, d_in, n_in, d_out=None, n_out=None, dropout=0.1):\n        super(GCN, self).__init__()\n        if not d_out:\n            d_out = d_in\n        if not n_out:\n            n_out = d_in\n        self.conv_n = nn.Conv1D(n_in, n_out, 1)\n        self.linear = nn.Linear(d_in, d_out)\n        self.dropout = nn.Dropout(dropout)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "documentation": {}
    },
    {
        "label": "PRENFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "peekOfCode": "class PRENFPN(nn.Layer):\n    def __init__(self, in_channels, n_r, d_model, max_len, dropout):\n        super(PRENFPN, self).__init__()\n        assert len(in_channels) == 3, \"in_channels' length must be 3.\"\n        c1, c2, c3 = in_channels  # the depths are from big to small\n        # build fpn\n        assert d_model % 3 == 0, \"{} can't be divided by 3.\".format(d_model)\n        self.agg_p1 = PoolAggregate(n_r, c1, d_out=d_model // 3)\n        self.agg_p2 = PoolAggregate(n_r, c2, d_out=d_model // 3)\n        self.agg_p3 = PoolAggregate(n_r, c3, d_out=d_model // 3)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.pren_fpn",
        "documentation": {}
    },
    {
        "label": "S2VAdaptor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "peekOfCode": "class S2VAdaptor(nn.Layer):\n    \"\"\" Semantic to Visual adaptation module\"\"\"\n    def __init__(self, in_channels=512):\n        super(S2VAdaptor, self).__init__()\n        self.in_channels = in_channels  # 512\n        # feature strengthen module, channel attention\n        self.channel_inter = nn.Linear(\n            self.in_channels, self.in_channels, bias_attr=False)\n        self.channel_bn = nn.BatchNorm1D(self.in_channels)\n        self.channel_act = nn.ReLU()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "documentation": {}
    },
    {
        "label": "V2SAdaptor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "peekOfCode": "class V2SAdaptor(nn.Layer):\n    \"\"\" Visual to Semantic adaptation module\"\"\"\n    def __init__(self, in_channels=512, return_mask=False):\n        super(V2SAdaptor, self).__init__()\n        # parameter initialization\n        self.in_channels = in_channels\n        self.return_mask = return_mask\n        # output transformation\n        self.channel_inter = nn.Linear(\n            self.in_channels, self.in_channels, bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "documentation": {}
    },
    {
        "label": "RFAdaptor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "peekOfCode": "class RFAdaptor(nn.Layer):\n    def __init__(self, in_channels=512, use_v2s=True, use_s2v=True, **kwargs):\n        super(RFAdaptor, self).__init__()\n        if use_v2s is True:\n            self.neck_v2s = V2SAdaptor(in_channels=in_channels, **kwargs)\n        else:\n            self.neck_v2s = None\n        if use_s2v is True:\n            self.neck_s2v = S2VAdaptor(in_channels=in_channels, **kwargs)\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "documentation": {}
    },
    {
        "label": "kaiming_init_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "peekOfCode": "kaiming_init_ = KaimingNormal()\nzeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass S2VAdaptor(nn.Layer):\n    \"\"\" Semantic to Visual adaptation module\"\"\"\n    def __init__(self, in_channels=512):\n        super(S2VAdaptor, self).__init__()\n        self.in_channels = in_channels  # 512\n        # feature strengthen module, channel attention\n        self.channel_inter = nn.Linear(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "documentation": {}
    },
    {
        "label": "zeros_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "peekOfCode": "zeros_ = Constant(value=0.)\nones_ = Constant(value=1.)\nclass S2VAdaptor(nn.Layer):\n    \"\"\" Semantic to Visual adaptation module\"\"\"\n    def __init__(self, in_channels=512):\n        super(S2VAdaptor, self).__init__()\n        self.in_channels = in_channels  # 512\n        # feature strengthen module, channel attention\n        self.channel_inter = nn.Linear(\n            self.in_channels, self.in_channels, bias_attr=False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "documentation": {}
    },
    {
        "label": "ones_",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "peekOfCode": "ones_ = Constant(value=1.)\nclass S2VAdaptor(nn.Layer):\n    \"\"\" Semantic to Visual adaptation module\"\"\"\n    def __init__(self, in_channels=512):\n        super(S2VAdaptor, self).__init__()\n        self.in_channels = in_channels  # 512\n        # feature strengthen module, channel attention\n        self.channel_inter = nn.Linear(\n            self.in_channels, self.in_channels, bias_attr=False)\n        self.channel_bn = nn.BatchNorm1D(self.in_channels)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rf_adaptor",
        "documentation": {}
    },
    {
        "label": "Im2Seq",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "peekOfCode": "class Im2Seq(nn.Layer):\n    def __init__(self, in_channels, **kwargs):\n        super().__init__()\n        self.out_channels = in_channels\n    def forward(self, x):\n        B, C, H, W = x.shape\n        assert H == 1\n        x = x.squeeze(axis=2)\n        x = x.transpose([0, 2, 1])  # (NTC)(batch, width, channels)\n        return x",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "EncoderWithRNN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "peekOfCode": "class EncoderWithRNN(nn.Layer):\n    def __init__(self, in_channels, hidden_size):\n        super(EncoderWithRNN, self).__init__()\n        self.out_channels = hidden_size * 2\n        self.lstm = nn.LSTM(\n            in_channels, hidden_size, direction='bidirectional', num_layers=2)\n    def forward(self, x):\n        x, _ = self.lstm(x)\n        return x\nclass BidirectionalLSTM(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "BidirectionalLSTM",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "peekOfCode": "class BidirectionalLSTM(nn.Layer):\n    def __init__(self,\n                 input_size,\n                 hidden_size,\n                 output_size=None,\n                 num_layers=1,\n                 dropout=0,\n                 direction=False,\n                 time_major=False,\n                 with_linear=False):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "EncoderWithCascadeRNN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "peekOfCode": "class EncoderWithCascadeRNN(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 hidden_size,\n                 out_channels,\n                 num_layers=2,\n                 with_linear=False):\n        super(EncoderWithCascadeRNN, self).__init__()\n        self.out_channels = out_channels[-1]\n        self.encoder = nn.LayerList([",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "EncoderWithFC",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "peekOfCode": "class EncoderWithFC(nn.Layer):\n    def __init__(self, in_channels, hidden_size):\n        super(EncoderWithFC, self).__init__()\n        self.out_channels = hidden_size\n        weight_attr, bias_attr = get_para_bias_attr(\n            l2_decay=0.00001, k=in_channels)\n        self.fc = nn.Linear(\n            in_channels,\n            hidden_size,\n            weight_attr=weight_attr,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "EncoderWithSVTR",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "peekOfCode": "class EncoderWithSVTR(nn.Layer):\n    def __init__(\n            self,\n            in_channels,\n            dims=64,  # XS\n            depth=2,\n            hidden_dims=120,\n            use_guide=False,\n            num_heads=8,\n            qkv_bias=True,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "SequenceEncoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "peekOfCode": "class SequenceEncoder(nn.Layer):\n    def __init__(self, in_channels, encoder_type, hidden_size=48, **kwargs):\n        super(SequenceEncoder, self).__init__()\n        self.encoder_reshape = Im2Seq(in_channels)\n        self.out_channels = self.encoder_reshape.out_channels\n        self.encoder_type = encoder_type\n        if encoder_type == 'reshape':\n            self.only_reshape = True\n        else:\n            support_encoder_dict = {",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.rnn",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,\n                 if_act=True,\n                 act=None,\n                 name=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "documentation": {}
    },
    {
        "label": "DeConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "peekOfCode": "class DeConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride,\n                 groups=1,\n                 if_act=True,\n                 act=None,\n                 name=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "documentation": {}
    },
    {
        "label": "FPN_Up_Fusion",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "peekOfCode": "class FPN_Up_Fusion(nn.Layer):\n    def __init__(self, in_channels):\n        super(FPN_Up_Fusion, self).__init__()\n        in_channels = in_channels[::-1]\n        out_channels = [256, 256, 192, 192, 128]\n        self.h0_conv = ConvBNLayer(in_channels[0], out_channels[0], 1, 1, act=None, name='fpn_up_h0')\n        self.h1_conv = ConvBNLayer(in_channels[1], out_channels[1], 1, 1, act=None, name='fpn_up_h1')\n        self.h2_conv = ConvBNLayer(in_channels[2], out_channels[2], 1, 1, act=None, name='fpn_up_h2')\n        self.h3_conv = ConvBNLayer(in_channels[3], out_channels[3], 1, 1, act=None, name='fpn_up_h3')\n        self.h4_conv = ConvBNLayer(in_channels[4], out_channels[4], 1, 1, act=None, name='fpn_up_h4')",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "documentation": {}
    },
    {
        "label": "FPN_Down_Fusion",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "peekOfCode": "class FPN_Down_Fusion(nn.Layer):\n    def __init__(self, in_channels):\n        super(FPN_Down_Fusion, self).__init__()\n        out_channels = [32, 64, 128]\n        self.h0_conv = ConvBNLayer(in_channels[0], out_channels[0], 3, 1, act=None, name='fpn_down_h0')\n        self.h1_conv = ConvBNLayer(in_channels[1], out_channels[1], 3, 1, act=None, name='fpn_down_h1')\n        self.h2_conv = ConvBNLayer(in_channels[2], out_channels[2], 3, 1, act=None, name='fpn_down_h2')\n        self.g0_conv = ConvBNLayer(out_channels[0], out_channels[1], 3, 2, act=None, name='fpn_down_g0')\n        self.g1_conv = nn.Sequential(\n            ConvBNLayer(out_channels[1], out_channels[1], 3, 1, act='relu', name='fpn_down_g1_1'),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "documentation": {}
    },
    {
        "label": "Cross_Attention",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "peekOfCode": "class Cross_Attention(nn.Layer):\n    def __init__(self, in_channels):\n        super(Cross_Attention, self).__init__()\n        self.theta_conv = ConvBNLayer(in_channels, in_channels, 1, 1, act='relu', name='f_theta')\n        self.phi_conv = ConvBNLayer(in_channels, in_channels, 1, 1, act='relu', name='f_phi')\n        self.g_conv = ConvBNLayer(in_channels, in_channels, 1, 1, act='relu', name='f_g')\n        self.fh_weight_conv = ConvBNLayer(in_channels, in_channels, 1, 1, act=None, name='fh_weight')\n        self.fh_sc_conv = ConvBNLayer(in_channels, in_channels, 1, 1, act=None, name='fh_sc')\n        self.fv_weight_conv = ConvBNLayer(in_channels, in_channels, 1, 1, act=None, name='fv_weight')\n        self.fv_sc_conv = ConvBNLayer(in_channels, in_channels, 1, 1, act=None, name='fv_sc')",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "documentation": {}
    },
    {
        "label": "SASTFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "peekOfCode": "class SASTFPN(nn.Layer):\n    def __init__(self, in_channels, with_cab=False, **kwargs):\n        super(SASTFPN, self).__init__()\n        self.in_channels = in_channels\n        self.with_cab = with_cab\n        self.FPN_Down_Fusion = FPN_Down_Fusion(self.in_channels)\n        self.FPN_Up_Fusion = FPN_Up_Fusion(self.in_channels)\n        self.out_channels = 128\n        self.cross_attention = Cross_Attention(self.out_channels)\n    def forward(self, x):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.sast_fpn",
        "documentation": {}
    },
    {
        "label": "TableFPN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.table_fpn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.table_fpn",
        "peekOfCode": "class TableFPN(nn.Layer):\n    def __init__(self, in_channels, out_channels, **kwargs):\n        super(TableFPN, self).__init__()\n        self.out_channels = 512\n        weight_attr = paddle.nn.initializer.KaimingUniform()\n        self.in2_conv = nn.Conv2D(\n            in_channels=in_channels[0],\n            out_channels=self.out_channels,\n            kernel_size=1,\n            weight_attr=ParamAttr(initializer=weight_attr),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.necks.table_fpn",
        "documentation": {}
    },
    {
        "label": "SP_TransformerNetwork",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.gaspin_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.gaspin_transformer",
        "peekOfCode": "class SP_TransformerNetwork(nn.Layer):\n    \"\"\"\n    Sturture-Preserving Transformation (SPT) as Equa. (2) in Ref. [1]\n    Ref: [1] SPIN: Structure-Preserving Inner Offset Network for Scene Text Recognition. AAAI-2021.\n    \"\"\"\n    def __init__(self, nc=1, default_type=5):\n        \"\"\" Based on SPIN\n        Args:\n            nc (int): number of input channels (usually in 1 or 3)\n            default_type (int): the complexity of transformation intensities (by default set to 6 as the paper)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.gaspin_transformer",
        "documentation": {}
    },
    {
        "label": "GA_SPIN_Transformer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.gaspin_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.gaspin_transformer",
        "peekOfCode": "class GA_SPIN_Transformer(nn.Layer):\n    \"\"\"\n    Geometric-Absorbed SPIN Transformation (GA-SPIN) proposed in Ref. [1]\n    Ref: [1] SPIN: Structure-Preserving Inner Offset Network for Scene Text Recognition. AAAI-2021.\n    \"\"\"\n    def __init__(self, in_channels=1,\n                 I_r_size=(32, 100),\n                 offsets=False,\n                 norm_type='BN',\n                 default_type=6,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.gaspin_transformer",
        "documentation": {}
    },
    {
        "label": "STN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "peekOfCode": "class STN(nn.Layer):\n    def __init__(self, in_channels, num_ctrlpoints, activation='none'):\n        super(STN, self).__init__()\n        self.in_channels = in_channels\n        self.num_ctrlpoints = num_ctrlpoints\n        self.activation = activation\n        self.stn_convnet = nn.Sequential(\n            conv3x3_block(in_channels, 32),  #32x64\n            nn.MaxPool2D(\n                kernel_size=2, stride=2),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "documentation": {}
    },
    {
        "label": "STN_ON",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "peekOfCode": "class STN_ON(nn.Layer):\n    def __init__(self, in_channels, tps_inputsize, tps_outputsize,\n                 num_control_points, tps_margins, stn_activation):\n        super(STN_ON, self).__init__()\n        self.tps = TPSSpatialTransformer(\n            output_image_size=tuple(tps_outputsize),\n            num_control_points=num_control_points,\n            margins=tuple(tps_margins))\n        self.stn_head = STN(in_channels=in_channels,\n                            num_ctrlpoints=num_control_points,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "documentation": {}
    },
    {
        "label": "conv3x3_block",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "peekOfCode": "def conv3x3_block(in_channels, out_channels, stride=1):\n    n = 3 * 3 * out_channels\n    w = math.sqrt(2. / n)\n    conv_layer = nn.Conv2D(\n        in_channels,\n        out_channels,\n        kernel_size=3,\n        stride=stride,\n        padding=1,\n        weight_attr=nn.initializer.Normal(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.stn",
        "documentation": {}
    },
    {
        "label": "FeatureEnhancer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "peekOfCode": "class FeatureEnhancer(nn.Layer):\n    def __init__(self):\n        super(FeatureEnhancer, self).__init__()\n        self.multihead = MultiHeadedAttention(h=4, d_model=128, dropout=0.1)\n        self.mul_layernorm1 = LayerNorm(features=128)\n        self.pff = PositionwiseFeedForward(128, 128)\n        self.mul_layernorm3 = LayerNorm(features=128)\n        self.linear = nn.Linear(128, 64)\n    def forward(self, conv_feature):\n        '''",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "documentation": {}
    },
    {
        "label": "TBSRN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "peekOfCode": "class TBSRN(nn.Layer):\n    def __init__(self,\n                 in_channels=3,\n                 scale_factor=2,\n                 width=128,\n                 height=32,\n                 STN=True,\n                 srb_nums=5,\n                 mask=False,\n                 hidden_units=32,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "documentation": {}
    },
    {
        "label": "RecurrentResidualBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "peekOfCode": "class RecurrentResidualBlock(nn.Layer):\n    def __init__(self, channels):\n        super(RecurrentResidualBlock, self).__init__()\n        self.conv1 = nn.Conv2D(channels, channels, kernel_size=3, padding=1)\n        self.bn1 = nn.BatchNorm2D(channels)\n        self.gru1 = GruBlock(channels, channels)\n        # self.prelu = nn.ReLU()\n        self.prelu = mish()\n        self.conv2 = nn.Conv2D(channels, channels, kernel_size=3, padding=1)\n        self.bn2 = nn.BatchNorm2D(channels)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "documentation": {}
    },
    {
        "label": "positionalencoding2d",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "peekOfCode": "def positionalencoding2d(d_model, height, width):\n    \"\"\"\n    :param d_model: dimension of the model\n    :param height: height of the positions\n    :param width: width of the positions\n    :return: d_model*height*width position matrix\n    \"\"\"\n    if d_model % 4 != 0:\n        raise ValueError(\"Cannot use sin/cos positional encoding with \"\n                         \"odd dimension (got dim={:d})\".format(d_model))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "documentation": {}
    },
    {
        "label": "str_filt",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "peekOfCode": "def str_filt(str_, voc_type):\n    alpha_dict = {\n        'digit': string.digits,\n        'lower': string.digits + string.ascii_lowercase,\n        'upper': string.digits + string.ascii_letters,\n        'all': string.digits + string.ascii_letters + string.punctuation\n    }\n    if voc_type == 'lower':\n        str_ = str_.lower()\n    for char in str_:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tbsrn",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 groups=1,\n                 act=None,\n                 name=None):\n        super(ConvBNLayer, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "documentation": {}
    },
    {
        "label": "LocalizationNetwork",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "peekOfCode": "class LocalizationNetwork(nn.Layer):\n    def __init__(self, in_channels, num_fiducial, loc_lr, model_name):\n        super(LocalizationNetwork, self).__init__()\n        self.F = num_fiducial\n        F = num_fiducial\n        if model_name == \"large\":\n            num_filters_list = [64, 128, 256, 512]\n            fc_dim = 256\n        else:\n            num_filters_list = [16, 32, 64, 128]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "documentation": {}
    },
    {
        "label": "GridGenerator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "peekOfCode": "class GridGenerator(nn.Layer):\n    def __init__(self, in_channels, num_fiducial):\n        super(GridGenerator, self).__init__()\n        self.eps = 1e-6\n        self.F = num_fiducial\n        name = \"ex_fc\"\n        initializer = nn.initializer.Constant(value=0.0)\n        param_attr = ParamAttr(\n            learning_rate=0.0, initializer=initializer, name=name + \"_w\")\n        bias_attr = ParamAttr(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "documentation": {}
    },
    {
        "label": "TPS",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "peekOfCode": "class TPS(nn.Layer):\n    def __init__(self, in_channels, num_fiducial, loc_lr, model_name):\n        super(TPS, self).__init__()\n        self.loc_net = LocalizationNetwork(in_channels, num_fiducial, loc_lr,\n                                           model_name)\n        self.grid_generator = GridGenerator(self.loc_net.out_channels,\n                                            num_fiducial)\n        self.out_channels = in_channels\n    def forward(self, image):\n        image.stop_gradient = False",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps",
        "documentation": {}
    },
    {
        "label": "TPSSpatialTransformer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "peekOfCode": "class TPSSpatialTransformer(nn.Layer):\n    def __init__(self,\n                 output_image_size=None,\n                 num_control_points=None,\n                 margins=None):\n        super(TPSSpatialTransformer, self).__init__()\n        self.output_image_size = output_image_size\n        self.num_control_points = num_control_points\n        self.margins = margins\n        self.target_height, self.target_width = output_image_size",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "documentation": {}
    },
    {
        "label": "grid_sample",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "peekOfCode": "def grid_sample(input, grid, canvas=None):\n    input.stop_gradient = False\n    is_fp16 = False\n    if grid.dtype != paddle.float32:\n        data_type = grid.dtype\n        input = input.cast(paddle.float32)\n        grid = grid.cast(paddle.float32)\n        is_fp16 = True\n    output = F.grid_sample(input, grid)\n    if is_fp16:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "documentation": {}
    },
    {
        "label": "compute_partial_repr",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "peekOfCode": "def compute_partial_repr(input_points, control_points):\n    N = input_points.shape[0]\n    M = control_points.shape[0]\n    pairwise_diff = paddle.reshape(\n        input_points, shape=[N, 1, 2]) - paddle.reshape(\n            control_points, shape=[1, M, 2])\n    # original implementation, very slow\n    # pairwise_dist = torch.sum(pairwise_diff ** 2, dim = 2) # square of distance\n    pairwise_diff_square = pairwise_diff * pairwise_diff\n    pairwise_dist = pairwise_diff_square[:, :, 0] + pairwise_diff_square[:, :,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "documentation": {}
    },
    {
        "label": "build_output_control_points",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "peekOfCode": "def build_output_control_points(num_control_points, margins):\n    margin_x, margin_y = margins\n    num_ctrl_pts_per_side = num_control_points // 2\n    ctrl_pts_x = np.linspace(margin_x, 1.0 - margin_x, num_ctrl_pts_per_side)\n    ctrl_pts_y_top = np.ones(num_ctrl_pts_per_side) * margin_y\n    ctrl_pts_y_bottom = np.ones(num_ctrl_pts_per_side) * (1.0 - margin_y)\n    ctrl_pts_top = np.stack([ctrl_pts_x, ctrl_pts_y_top], axis=1)\n    ctrl_pts_bottom = np.stack([ctrl_pts_x, ctrl_pts_y_bottom], axis=1)\n    output_ctrl_pts_arr = np.concatenate(\n        [ctrl_pts_top, ctrl_pts_bottom], axis=0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tps_spatial_transformer",
        "documentation": {}
    },
    {
        "label": "TSRN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "peekOfCode": "class TSRN(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 scale_factor=2,\n                 width=128,\n                 height=32,\n                 STN=False,\n                 srb_nums=5,\n                 mask=False,\n                 hidden_units=32,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "documentation": {}
    },
    {
        "label": "RecurrentResidualBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "peekOfCode": "class RecurrentResidualBlock(nn.Layer):\n    def __init__(self, channels):\n        super(RecurrentResidualBlock, self).__init__()\n        self.conv1 = nn.Conv2D(channels, channels, kernel_size=3, padding=1)\n        self.bn1 = nn.BatchNorm2D(channels)\n        self.gru1 = GruBlock(channels, channels)\n        self.prelu = mish()\n        self.conv2 = nn.Conv2D(channels, channels, kernel_size=3, padding=1)\n        self.bn2 = nn.BatchNorm2D(channels)\n        self.gru2 = GruBlock(channels, channels)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "documentation": {}
    },
    {
        "label": "UpsampleBLock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "peekOfCode": "class UpsampleBLock(nn.Layer):\n    def __init__(self, in_channels, up_scale):\n        super(UpsampleBLock, self).__init__()\n        self.conv = nn.Conv2D(\n            in_channels, in_channels * up_scale**2, kernel_size=3, padding=1)\n        self.pixel_shuffle = nn.PixelShuffle(up_scale)\n        self.prelu = mish()\n    def forward(self, x):\n        x = self.conv(x)\n        x = self.pixel_shuffle(x)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "documentation": {}
    },
    {
        "label": "mish",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "peekOfCode": "class mish(nn.Layer):\n    def __init__(self, ):\n        super(mish, self).__init__()\n        self.activated = True\n    def forward(self, x):\n        if self.activated:\n            x = x * (paddle.tanh(F.softplus(x)))\n        return x\nclass GruBlock(nn.Layer):\n    def __init__(self, in_channels, out_channels):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "documentation": {}
    },
    {
        "label": "GruBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "description": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "peekOfCode": "class GruBlock(nn.Layer):\n    def __init__(self, in_channels, out_channels):\n        super(GruBlock, self).__init__()\n        assert out_channels % 2 == 0\n        self.conv1 = nn.Conv2D(\n            in_channels, out_channels, kernel_size=1, padding=0)\n        self.gru = nn.GRU(out_channels,\n                          out_channels // 2,\n                          direction='bidirectional')\n    def forward(self, x):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.modeling.transforms.tsrn",
        "documentation": {}
    },
    {
        "label": "Linear",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class Linear(object):\n    \"\"\"\n    Linear learning rate decay\n    Args:\n        lr (float): The initial learning rate. It is a python float number.\n        epochs(int): The decay step size. It determines the decay cycle.\n        end_lr(float, optional): The minimum final learning rate. Default: 0.0001.\n        power(float, optional): Power of polynomial. Default: 1.0.\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "Cosine",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class Cosine(object):\n    \"\"\"\n    Cosine learning rate decay\n    lr = 0.05 * (math.cos(epoch * (math.pi / epochs)) + 1)\n    Args:\n        lr(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        epochs(int): total training epochs\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "Step",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class Step(object):\n    \"\"\"\n    Piecewise learning rate decay\n    Args:\n        step_each_epoch(int): steps each epoch\n        learning_rate (float): The initial learning rate. It is a python float number.\n        step_size (int): the interval to update.\n        gamma (float, optional): The Ratio that the learning rate will be reduced. ``new_lr = origin_lr * gamma`` .\n            It should be less than 1.0. Default: 0.1.\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "Piecewise",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class Piecewise(object):\n    \"\"\"\n    Piecewise learning rate decay\n    Args:\n        boundaries(list): A list of steps numbers. The type of element in the list is python int.\n        values(list): A list of learning rate values that will be picked during different epoch boundaries.\n            The type of element in the list is python float.\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.\n    \"\"\"\n    def __init__(self,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "CyclicalCosine",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class CyclicalCosine(object):\n    \"\"\"\n    Cyclical cosine learning rate decay\n    Args:\n        learning_rate(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        epochs(int): total training epochs\n        cycle(int): period of the cosine learning rate\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "OneCycle",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class OneCycle(object):\n    \"\"\"\n    One Cycle learning rate decay\n    Args:\n        max_lr(float): Upper learning rate boundaries\n        epochs(int): total training epochs\n        step_each_epoch(int): steps each epoch\n        anneal_strategy(str): {‘cos’, ‘linear’} Specifies the annealing strategy: “cos” for cosine annealing, “linear” for linear annealing. \n            Default: ‘cos’\n        three_phase(bool): If True, use a third phase of the schedule to annihilate the learning rate according to ‘final_div_factor’ ",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "Const",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class Const(object):\n    \"\"\"\n    Const learning rate decay\n    Args:\n        learning_rate(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.\n    \"\"\"\n    def __init__(self,\n                 learning_rate,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "DecayLearningRate",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class DecayLearningRate(object):\n    \"\"\"\n    DecayLearningRate learning rate decay\n    new_lr = (lr - end_lr) * (1 - epoch/decay_steps)**power + end_lr\n    Args:\n        learning_rate(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        epochs(int): total training epochs\n        factor(float): Power of polynomial, should greater than 0.0 to get learning rate decay. Default: 0.9\n        end_lr(float): The minimum final learning rate. Default: 0.0.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "MultiStepDecay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class MultiStepDecay(object):\n    \"\"\"\n    Piecewise learning rate decay\n    Args:\n        step_each_epoch(int): steps each epoch\n        learning_rate (float): The initial learning rate. It is a python float number.\n        step_size (int): the interval to update.\n        gamma (float, optional): The Ratio that the learning rate will be reduced. ``new_lr = origin_lr * gamma`` .\n            It should be less than 1.0. Default: 0.1.\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "TwoStepCosine",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "peekOfCode": "class TwoStepCosine(object):\n    \"\"\"\n    Cosine learning rate decay\n    lr = 0.05 * (math.cos(epoch * (math.pi / epochs)) + 1)\n    Args:\n        lr(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        epochs(int): total training epochs\n        last_epoch (int, optional):  The index of last epoch. Can be set to restart training. Default: -1, means initial learning rate.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.learning_rate",
        "documentation": {}
    },
    {
        "label": "CyclicalCosineDecay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "peekOfCode": "class CyclicalCosineDecay(LRScheduler):\n    def __init__(self,\n                 learning_rate,\n                 T_max,\n                 cycle=1,\n                 last_epoch=-1,\n                 eta_min=0.0,\n                 verbose=False):\n        \"\"\"\n        Cyclical cosine learning rate decay",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "documentation": {}
    },
    {
        "label": "OneCycleDecay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "peekOfCode": "class OneCycleDecay(LRScheduler):\n    \"\"\"\n    One Cycle learning rate decay\n    A learning rate which can be referred in https://arxiv.org/abs/1708.07120\n    Code refered in https://pytorch.org/docs/stable/_modules/torch/optim/lr_scheduler.html#OneCycleLR\n    \"\"\"\n    def __init__(self,\n                 max_lr,\n                 epochs=None,\n                 steps_per_epoch=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "documentation": {}
    },
    {
        "label": "TwoStepCosineDecay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "peekOfCode": "class TwoStepCosineDecay(LRScheduler):\n    def __init__(self,\n                 learning_rate,\n                 T_max1,\n                 T_max2,\n                 eta_min=0,\n                 last_epoch=-1,\n                 verbose=False):\n        if not isinstance(T_max1, int):\n            raise TypeError(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.lr_scheduler",
        "documentation": {}
    },
    {
        "label": "Momentum",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "peekOfCode": "class Momentum(object):\n    \"\"\"\n    Simple Momentum optimizer with velocity state.\n    Args:\n        learning_rate (float|Variable) - The learning rate used to update parameters.\n            Can be a float value or a Variable with one float value as data element.\n        momentum (float) - Momentum factor.\n        regularization (WeightDecayRegularizer, optional) - The strategy of regularization.\n    \"\"\"\n    def __init__(self,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "documentation": {}
    },
    {
        "label": "Adam",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "peekOfCode": "class Adam(object):\n    def __init__(self,\n                 learning_rate=0.001,\n                 beta1=0.9,\n                 beta2=0.999,\n                 epsilon=1e-08,\n                 parameter_list=None,\n                 weight_decay=None,\n                 grad_clip=None,\n                 name=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "documentation": {}
    },
    {
        "label": "RMSProp",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "peekOfCode": "class RMSProp(object):\n    \"\"\"\n    Root Mean Squared Propagation (RMSProp) is an unpublished, adaptive learning rate method.\n    Args:\n        learning_rate (float|Variable) - The learning rate used to update parameters.\n            Can be a float value or a Variable with one float value as data element.\n        momentum (float) - Momentum factor.\n        rho (float) - rho value in equation.\n        epsilon (float) - avoid division by zero, default is 1e-6.\n        regularization (WeightDecayRegularizer, optional) - The strategy of regularization.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "documentation": {}
    },
    {
        "label": "Adadelta",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "peekOfCode": "class Adadelta(object):\n    def __init__(self,\n                 learning_rate=0.001,\n                 epsilon=1e-08,\n                 rho=0.95,\n                 parameter_list=None,\n                 weight_decay=None,\n                 grad_clip=None,\n                 name=None,\n                 **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "documentation": {}
    },
    {
        "label": "AdamW",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "peekOfCode": "class AdamW(object):\n    def __init__(self,\n                 learning_rate=0.001,\n                 beta1=0.9,\n                 beta2=0.999,\n                 epsilon=1e-8,\n                 weight_decay=0.01,\n                 multi_precision=False,\n                 grad_clip=None,\n                 no_weight_decay_name=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.optimizer",
        "documentation": {}
    },
    {
        "label": "L1Decay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.regularizer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.regularizer",
        "peekOfCode": "class L1Decay(object):\n    \"\"\"\n    L1 Weight Decay Regularization, which encourages the weights to be sparse.\n    Args:\n        factor(float): regularization coeff. Default:0.0.\n    \"\"\"\n    def __init__(self, factor=0.0):\n        super(L1Decay, self).__init__()\n        self.coeff = factor\n    def __call__(self):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.regularizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.optimizer.regularizer",
        "description": "Vision.Paddle.PaddleOCR.ppocr.optimizer.regularizer",
        "peekOfCode": "class L2Decay(object):\n    \"\"\"\n    L2 Weight Decay Regularization, which helps to prevent the model over-fitting.\n    Args:\n        factor(float): regularization coeff. Default:0.0.\n    \"\"\"\n    def __init__(self, factor=0.0):\n        super(L2Decay, self).__init__()\n        self.coeff = float(factor)\n    def __call__(self):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.optimizer.regularizer",
        "documentation": {}
    },
    {
        "label": "PSEPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pse_postprocess.pse_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pse_postprocess.pse_postprocess",
        "peekOfCode": "class PSEPostProcess(object):\n    \"\"\"\n    The post process for PSE.\n    \"\"\"\n    def __init__(self,\n                 thresh=0.5,\n                 box_thresh=0.85,\n                 min_area=16,\n                 box_type='quad',\n                 scale=4,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pse_postprocess.pse_postprocess",
        "documentation": {}
    },
    {
        "label": "ClsPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.cls_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.cls_postprocess",
        "peekOfCode": "class ClsPostProcess(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, label_list=None, key=None, **kwargs):\n        super(ClsPostProcess, self).__init__()\n        self.label_list = label_list\n        self.key = key\n    def __call__(self, preds, label=None, *args, **kwargs):\n        if self.key is not None:\n            preds = preds[self.key]\n        label_list = self.label_list",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.cls_postprocess",
        "documentation": {}
    },
    {
        "label": "CTPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.ct_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.ct_postprocess",
        "peekOfCode": "class CTPostProcess(object):\n    \"\"\"\n    The post process for Centripetal Text (CT).\n    \"\"\"\n    def __init__(self, min_score=0.88, min_area=16, box_type='poly', **kwargs):\n        self.min_score = min_score\n        self.min_area = min_area\n        self.box_type = box_type\n        self.coord = np.zeros((2, 300, 300), dtype=np.int32)\n        for i in range(300):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.ct_postprocess",
        "documentation": {}
    },
    {
        "label": "DBPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.db_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.db_postprocess",
        "peekOfCode": "class DBPostProcess(object):\n    \"\"\"\n    The post process for Differentiable Binarization (DB).\n    \"\"\"\n    def __init__(self,\n                 thresh=0.3,\n                 box_thresh=0.7,\n                 max_candidates=1000,\n                 unclip_ratio=2.0,\n                 use_dilation=False,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.db_postprocess",
        "documentation": {}
    },
    {
        "label": "DistillationDBPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.db_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.db_postprocess",
        "peekOfCode": "class DistillationDBPostProcess(object):\n    def __init__(self,\n                 model_name=[\"student\"],\n                 key=None,\n                 thresh=0.3,\n                 box_thresh=0.6,\n                 max_candidates=1000,\n                 unclip_ratio=1.5,\n                 use_dilation=False,\n                 score_mode=\"fast\",",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.db_postprocess",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "class Node:\n    def __init__(self, ind):\n        self.__ind = ind\n        self.__links = set()\n    @property\n    def ind(self):\n        return self.__ind\n    @property\n    def links(self):\n        return set(self.__links)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "DRRGPostprocess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "class DRRGPostprocess(object):\n    \"\"\"Merge text components and construct boundaries of text instances.\n    Args:\n        link_thr (float): The edge score threshold.\n    \"\"\"\n    def __init__(self, link_thr, **kwargs):\n        assert isinstance(link_thr, float)\n        self.link_thr = link_thr\n    def __call__(self, preds, shape_list):\n        \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "graph_propagation",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def graph_propagation(edges, scores, text_comps, edge_len_thr=50.):\n    assert edges.ndim == 2\n    assert edges.shape[1] == 2\n    assert edges.shape[0] == scores.shape[0]\n    assert text_comps.ndim == 2\n    assert isinstance(edge_len_thr, float)\n    edges = np.sort(edges, axis=1)\n    score_dict = {}\n    for i, edge in enumerate(edges):\n        if text_comps is not None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "connected_components",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def connected_components(nodes, score_dict, link_thr):\n    assert isinstance(nodes, list)\n    assert all([isinstance(node, Node) for node in nodes])\n    assert isinstance(score_dict, dict)\n    assert isinstance(link_thr, float)\n    clusters = []\n    nodes = set(nodes)\n    while nodes:\n        node = nodes.pop()\n        cluster = {node}",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "clusters2labels",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def clusters2labels(clusters, num_nodes):\n    assert isinstance(clusters, list)\n    assert all([isinstance(cluster, list) for cluster in clusters])\n    assert all(\n        [isinstance(node, Node) for cluster in clusters for node in cluster])\n    assert isinstance(num_nodes, int)\n    node_labels = np.zeros(num_nodes)\n    for cluster_ind, cluster in enumerate(clusters):\n        for node in cluster:\n            node_labels[node.ind] = cluster_ind",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "remove_single",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def remove_single(text_comps, comp_pred_labels):\n    assert text_comps.ndim == 2\n    assert text_comps.shape[0] == comp_pred_labels.shape[0]\n    single_flags = np.zeros_like(comp_pred_labels)\n    pred_labels = np.unique(comp_pred_labels)\n    for label in pred_labels:\n        current_label_flag = (comp_pred_labels == label)\n        if np.sum(current_label_flag) == 1:\n            single_flags[np.where(current_label_flag)[0][0]] = 1\n    keep_ind = [i for i in range(len(comp_pred_labels)) if not single_flags[i]]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "norm2",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def norm2(point1, point2):\n    return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5\ndef min_connect_path(points):\n    assert isinstance(points, list)\n    assert all([isinstance(point, list) for point in points])\n    assert all([isinstance(coord, int) for point in points for coord in point])\n    points_queue = points.copy()\n    shortest_path = []\n    current_edge = [[], []]\n    edge_dict0 = {}",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "min_connect_path",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def min_connect_path(points):\n    assert isinstance(points, list)\n    assert all([isinstance(point, list) for point in points])\n    assert all([isinstance(coord, int) for point in points for coord in point])\n    points_queue = points.copy()\n    shortest_path = []\n    current_edge = [[], []]\n    edge_dict0 = {}\n    edge_dict1 = {}\n    current_edge[0] = points_queue[0]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "in_contour",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def in_contour(cont, point):\n    x, y = point\n    is_inner = cv2.pointPolygonTest(cont, (int(x), int(y)), False) > 0.5\n    return is_inner\ndef fix_corner(top_line, bot_line, start_box, end_box):\n    assert isinstance(top_line, list)\n    assert all(isinstance(point, list) for point in top_line)\n    assert isinstance(bot_line, list)\n    assert all(isinstance(point, list) for point in bot_line)\n    assert start_box.shape == end_box.shape == (4, 2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "fix_corner",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def fix_corner(top_line, bot_line, start_box, end_box):\n    assert isinstance(top_line, list)\n    assert all(isinstance(point, list) for point in top_line)\n    assert isinstance(bot_line, list)\n    assert all(isinstance(point, list) for point in bot_line)\n    assert start_box.shape == end_box.shape == (4, 2)\n    contour = np.array(top_line + bot_line[::-1])\n    start_left_mid = (start_box[0] + start_box[3]) / 2\n    start_right_mid = (start_box[1] + start_box[2]) / 2\n    end_left_mid = (end_box[0] + end_box[3]) / 2",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "comps2boundaries",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "peekOfCode": "def comps2boundaries(text_comps, comp_pred_labels):\n    assert text_comps.ndim == 2\n    assert len(text_comps) == len(comp_pred_labels)\n    boundaries = []\n    if len(text_comps) < 1:\n        return boundaries\n    for cluster_ind in range(0, int(np.max(comp_pred_labels)) + 1):\n        cluster_comp_inds = np.where(comp_pred_labels == cluster_ind)\n        text_comp_boxes = text_comps[cluster_comp_inds, :8].reshape(\n            (-1, 4, 2)).astype(np.int32)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.drrg_postprocess",
        "documentation": {}
    },
    {
        "label": "EASTPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.east_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.east_postprocess",
        "peekOfCode": "class EASTPostProcess(object):\n    \"\"\"\n    The post process for EAST.\n    \"\"\"\n    def __init__(self,\n                 score_thresh=0.8,\n                 cover_thresh=0.1,\n                 nms_thresh=0.2,\n                 **kwargs):\n        self.score_thresh = score_thresh",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.east_postprocess",
        "documentation": {}
    },
    {
        "label": "FCEPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "peekOfCode": "class FCEPostProcess(object):\n    \"\"\"\n    The post process for FCENet.\n    \"\"\"\n    def __init__(self,\n                 scales,\n                 fourier_degree=5,\n                 num_reconstr_points=50,\n                 decoding_type='fcenet',\n                 score_thr=0.3,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "documentation": {}
    },
    {
        "label": "fill_hole",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "peekOfCode": "def fill_hole(input_mask):\n    h, w = input_mask.shape\n    canvas = np.zeros((h + 2, w + 2), np.uint8)\n    canvas[1:h + 1, 1:w + 1] = input_mask.copy()\n    mask = np.zeros((h + 4, w + 4), np.uint8)\n    cv2.floodFill(canvas, mask, (0, 0), 1)\n    canvas = canvas[1:h + 1, 1:w + 1].astype(np.bool_)\n    return ~canvas | input_mask\ndef fourier2poly(fourier_coeff, num_reconstr_points=50):\n    \"\"\" Inverse Fourier transform",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "documentation": {}
    },
    {
        "label": "fourier2poly",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "peekOfCode": "def fourier2poly(fourier_coeff, num_reconstr_points=50):\n    \"\"\" Inverse Fourier transform\n        Args:\n            fourier_coeff (ndarray): Fourier coefficients shaped (n, 2k+1),\n                with n and k being candidates number and Fourier degree\n                respectively.\n            num_reconstr_points (int): Number of reconstructed polygon points.\n        Returns:\n            Polygons (ndarray): The reconstructed polygons shaped (n, n')\n        \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.fce_postprocess",
        "documentation": {}
    },
    {
        "label": "intersection",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def intersection(g, p):\n    \"\"\"\n    Intersection.\n    \"\"\"\n    g = Polygon(g[:8].reshape((4, 2)))\n    p = Polygon(p[:8].reshape((4, 2)))\n    g = g.buffer(0)\n    p = p.buffer(0)\n    if not g.is_valid or not p.is_valid:\n        return 0",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "intersection_iog",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def intersection_iog(g, p):\n    \"\"\"\n    Intersection_iog.\n    \"\"\"\n    g = Polygon(g[:8].reshape((4, 2)))\n    p = Polygon(p[:8].reshape((4, 2)))\n    if not g.is_valid or not p.is_valid:\n        return 0\n    inter = Polygon(g).intersection(Polygon(p)).area\n    #union = g.area + p.area - inter",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "weighted_merge",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def weighted_merge(g, p):\n    \"\"\"\n    Weighted merge.\n    \"\"\"\n    g[:8] = (g[8] * g[:8] + p[8] * p[:8]) / (g[8] + p[8])\n    g[8] = (g[8] + p[8])\n    return g\ndef standard_nms(S, thres):\n    \"\"\"\n    Standard nms.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "standard_nms",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def standard_nms(S, thres):\n    \"\"\"\n    Standard nms.\n    \"\"\"\n    order = np.argsort(S[:, 8])[::-1]\n    keep = []\n    while order.size > 0:\n        i = order[0]\n        keep.append(i)\n        ovr = np.array([intersection(S[i], S[t]) for t in order[1:]])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "standard_nms_inds",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def standard_nms_inds(S, thres):\n    \"\"\"\n    Standard nms, retun inds.\n    \"\"\"\n    order = np.argsort(S[:, 8])[::-1]\n    keep = []\n    while order.size > 0:\n        i = order[0]\n        keep.append(i)\n        ovr = np.array([intersection(S[i], S[t]) for t in order[1:]])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "nms",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def nms(S, thres):\n    \"\"\"\n    nms.\n    \"\"\"\n    order = np.argsort(S[:, 8])[::-1]\n    keep = []\n    while order.size > 0:\n        i = order[0]\n        keep.append(i)\n        ovr = np.array([intersection(S[i], S[t]) for t in order[1:]])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "soft_nms",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def soft_nms(boxes_in, Nt_thres=0.3, threshold=0.8, sigma=0.5, method=2):\n    \"\"\"\n    soft_nms\n    :para boxes_in, N x 9 (coords + score)\n    :para threshould, eliminate cases min score(0.001)\n    :para Nt_thres, iou_threshi\n    :para sigma, gaussian weght\n    :method, linear or gaussian\n    \"\"\"\n    boxes = boxes_in.copy()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "nms_locality",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "peekOfCode": "def nms_locality(polys, thres=0.3):\n    \"\"\"\n    locality aware nms of EAST\n    :param polys: a N*9 numpy array. first 8 coordinates, then prob\n    :return: boxes after nms\n    \"\"\"\n    S = []\n    p = None\n    for g in polys:\n        if p is not None and intersection(g, p) > thres:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.locality_aware_nms",
        "documentation": {}
    },
    {
        "label": "PGPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pg_postprocess",
        "peekOfCode": "class PGPostProcess(object):\n    \"\"\"\n    The post process for PGNet.\n    \"\"\"\n    def __init__(self,\n                 character_dict_path,\n                 valid_set,\n                 score_thresh,\n                 mode,\n                 point_gather_mode=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pg_postprocess",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pg_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pg_postprocess",
        "peekOfCode": "__dir__ = os.path.dirname(__file__)\nsys.path.append(__dir__)\nsys.path.append(os.path.join(__dir__, '..'))\nfrom ppocr.utils.e2e_utils.pgnet_pp_utils import PGNet_PostProcess\nclass PGPostProcess(object):\n    \"\"\"\n    The post process for PGNet.\n    \"\"\"\n    def __init__(self,\n                 character_dict_path,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.pg_postprocess",
        "documentation": {}
    },
    {
        "label": "PicoDetPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "peekOfCode": "class PicoDetPostProcess(object):\n    \"\"\"\n    Args:\n        input_shape (int): network input image size\n        ori_shape (int): ori image shape of before padding\n        scale_factor (float): scale factor of ori image\n        enable_mkldnn (bool): whether to open MKLDNN\n    \"\"\"\n    def __init__(self,\n                 layout_dict_path,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "documentation": {}
    },
    {
        "label": "hard_nms",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "peekOfCode": "def hard_nms(box_scores, iou_threshold, top_k=-1, candidate_size=200):\n    \"\"\"\n    Args:\n        box_scores (N, 5): boxes in corner-form and probabilities.\n        iou_threshold: intersection over union threshold.\n        top_k: keep top_k results. If k <= 0, keep all the results.\n        candidate_size: only consider the candidates with the highest scores.\n    Returns:\n         picked: a list of indexes of the kept boxes\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "documentation": {}
    },
    {
        "label": "iou_of",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "peekOfCode": "def iou_of(boxes0, boxes1, eps=1e-5):\n    \"\"\"Return intersection-over-union (Jaccard index) of boxes.\n    Args:\n        boxes0 (N, 4): ground truth boxes.\n        boxes1 (N or 1, 4): predicted boxes.\n        eps: a small number to avoid 0 as denominator.\n    Returns:\n        iou (N): IoU values.\n    \"\"\"\n    overlap_left_top = np.maximum(boxes0[..., :2], boxes1[..., :2])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "documentation": {}
    },
    {
        "label": "area_of",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "peekOfCode": "def area_of(left_top, right_bottom):\n    \"\"\"Compute the areas of rectangles given two corners.\n    Args:\n        left_top (N, 2): left top corner.\n        right_bottom (N, 2): right bottom corner.\n    Returns:\n        area (N): return the area.\n    \"\"\"\n    hw = np.clip(right_bottom - left_top, 0.0, None)\n    return hw[..., 0] * hw[..., 1]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.picodet_postprocess",
        "documentation": {}
    },
    {
        "label": "BaseRecLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class BaseRecLabelDecode(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False):\n        self.beg_str = \"sos\"\n        self.end_str = \"eos\"\n        self.reverse = False\n        self.character_str = []\n        if character_dict_path is None:\n            self.character_str = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n            dict_character = list(self.character_str)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "CTCLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class CTCLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(CTCLabelDecode, self).__init__(character_dict_path,\n                                             use_space_char)\n    def __call__(self, preds, label=None, *args, **kwargs):\n        if isinstance(preds, tuple) or isinstance(preds, list):\n            preds = preds[-1]\n        if isinstance(preds, paddle.Tensor):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "DistillationCTCLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class DistillationCTCLabelDecode(CTCLabelDecode):\n    \"\"\"\n    Convert \n    Convert between text-label and text-index\n    \"\"\"\n    def __init__(self,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 model_name=[\"student\"],\n                 key=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "AttnLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class AttnLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(AttnLabelDecode, self).__init__(character_dict_path,\n                                              use_space_char)\n    def add_special_char(self, dict_character):\n        self.beg_str = \"sos\"\n        self.end_str = \"eos\"\n        dict_character = dict_character",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "RFLLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class RFLLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(RFLLabelDecode, self).__init__(character_dict_path,\n                                             use_space_char)\n    def add_special_char(self, dict_character):\n        self.beg_str = \"sos\"\n        self.end_str = \"eos\"\n        dict_character = dict_character",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "SEEDLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class SEEDLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(SEEDLabelDecode, self).__init__(character_dict_path,\n                                              use_space_char)\n    def add_special_char(self, dict_character):\n        self.padding_str = \"padding\"\n        self.end_str = \"eos\"\n        self.unknown = \"unknown\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "SRNLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class SRNLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(SRNLabelDecode, self).__init__(character_dict_path,\n                                             use_space_char)\n        self.max_text_length = kwargs.get('max_text_length', 25)\n    def __call__(self, preds, label=None, *args, **kwargs):\n        pred = preds['predict']\n        char_num = len(self.character_str) + 2",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "SARLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class SARLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(SARLabelDecode, self).__init__(character_dict_path,\n                                             use_space_char)\n        self.rm_symbol = kwargs.get('rm_symbol', False)\n    def add_special_char(self, dict_character):\n        beg_end_str = \"<BOS/EOS>\"\n        unknown_str = \"<UKN>\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "SATRNLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class SATRNLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(SATRNLabelDecode, self).__init__(character_dict_path,\n                                               use_space_char)\n        self.rm_symbol = kwargs.get('rm_symbol', False)\n    def add_special_char(self, dict_character):\n        beg_end_str = \"<BOS/EOS>\"\n        unknown_str = \"<UKN>\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "DistillationSARLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class DistillationSARLabelDecode(SARLabelDecode):\n    \"\"\"\n    Convert \n    Convert between text-label and text-index\n    \"\"\"\n    def __init__(self,\n                 character_dict_path=None,\n                 use_space_char=False,\n                 model_name=[\"student\"],\n                 key=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "PRENLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class PRENLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(PRENLabelDecode, self).__init__(character_dict_path,\n                                              use_space_char)\n    def add_special_char(self, dict_character):\n        padding_str = '<PAD>'  # 0 \n        end_str = '<EOS>'  # 1\n        unknown_str = '<UNK>'  # 2",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "NRTRLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class NRTRLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=True, **kwargs):\n        super(NRTRLabelDecode, self).__init__(character_dict_path,\n                                              use_space_char)\n    def __call__(self, preds, label=None, *args, **kwargs):\n        if len(preds) == 2:\n            preds_id = preds[0]\n            preds_prob = preds[1]\n            if isinstance(preds_id, paddle.Tensor):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "ViTSTRLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class ViTSTRLabelDecode(NRTRLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(ViTSTRLabelDecode, self).__init__(character_dict_path,\n                                                use_space_char)\n    def __call__(self, preds, label=None, *args, **kwargs):\n        if isinstance(preds, paddle.Tensor):\n            preds = preds[:, 1:].numpy()\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "ABINetLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class ABINetLabelDecode(NRTRLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(ABINetLabelDecode, self).__init__(character_dict_path,\n                                                use_space_char)\n    def __call__(self, preds, label=None, *args, **kwargs):\n        if isinstance(preds, dict):\n            preds = preds['align'][-1].numpy()\n        elif isinstance(preds, paddle.Tensor):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "SPINLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class SPINLabelDecode(AttnLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(SPINLabelDecode, self).__init__(character_dict_path,\n                                              use_space_char)\n    def add_special_char(self, dict_character):\n        self.beg_str = \"sos\"\n        self.end_str = \"eos\"\n        dict_character = dict_character",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "VLLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class VLLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(VLLabelDecode, self).__init__(character_dict_path, use_space_char)\n        self.max_text_length = kwargs.get('max_text_length', 25)\n        self.nclass = len(self.character) + 1\n    def decode(self, text_index, text_prob=None, is_remove_duplicate=False):\n        \"\"\" convert text-index into text-label. \"\"\"\n        result_list = []",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "CANLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "peekOfCode": "class CANLabelDecode(BaseRecLabelDecode):\n    \"\"\" Convert between latex-symbol and symbol-index \"\"\"\n    def __init__(self, character_dict_path=None, use_space_char=False,\n                 **kwargs):\n        super(CANLabelDecode, self).__init__(character_dict_path,\n                                             use_space_char)\n    def decode(self, text_index, preds_prob=None):\n        result_list = []\n        batch_size = len(text_index)\n        for batch_idx in range(batch_size):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.rec_postprocess",
        "documentation": {}
    },
    {
        "label": "SASTPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.sast_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.sast_postprocess",
        "peekOfCode": "class SASTPostProcess(object):\n    \"\"\"\n    The post process for SAST.\n    \"\"\"\n    def __init__(self,\n                 score_thresh=0.5,\n                 nms_thresh=0.2,\n                 sample_pts_num=2,\n                 shrink_ratio_of_width=0.3,\n                 expand_scale=1.0,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.sast_postprocess",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.sast_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.sast_postprocess",
        "peekOfCode": "__dir__ = os.path.dirname(__file__)\nsys.path.append(__dir__)\nsys.path.append(os.path.join(__dir__, '..'))\nimport numpy as np\nfrom .locality_aware_nms import nms_locality\nimport paddle\nimport cv2\nimport time\nclass SASTPostProcess(object):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.sast_postprocess",
        "documentation": {}
    },
    {
        "label": "TableLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.table_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.table_postprocess",
        "peekOfCode": "class TableLabelDecode(AttnLabelDecode):\n    \"\"\"  \"\"\"\n    def __init__(self,\n                 character_dict_path,\n                 merge_no_span_structure=False,\n                 **kwargs):\n        dict_character = []\n        with open(character_dict_path, \"rb\") as fin:\n            lines = fin.readlines()\n            for line in lines:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.table_postprocess",
        "documentation": {}
    },
    {
        "label": "TableMasterLabelDecode",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.table_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.table_postprocess",
        "peekOfCode": "class TableMasterLabelDecode(TableLabelDecode):\n    \"\"\"  \"\"\"\n    def __init__(self,\n                 character_dict_path,\n                 box_shape='ori',\n                 merge_no_span_structure=True,\n                 **kwargs):\n        super(TableMasterLabelDecode, self).__init__(character_dict_path,\n                                                     merge_no_span_structure)\n        self.box_shape = box_shape",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.table_postprocess",
        "documentation": {}
    },
    {
        "label": "VQAReTokenLayoutLMPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_re_layoutlm_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_re_layoutlm_postprocess",
        "peekOfCode": "class VQAReTokenLayoutLMPostProcess(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, **kwargs):\n        super(VQAReTokenLayoutLMPostProcess, self).__init__()\n    def __call__(self, preds, label=None, *args, **kwargs):\n        pred_relations = preds['pred_relations']\n        if isinstance(preds['pred_relations'], paddle.Tensor):\n            pred_relations = pred_relations.numpy()\n        pred_relations = self.decode_pred(pred_relations)\n        if label is not None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_re_layoutlm_postprocess",
        "documentation": {}
    },
    {
        "label": "DistillationRePostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_re_layoutlm_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_re_layoutlm_postprocess",
        "peekOfCode": "class DistillationRePostProcess(VQAReTokenLayoutLMPostProcess):\n    \"\"\"\n    DistillationRePostProcess\n    \"\"\"\n    def __init__(self, model_name=[\"Student\"], key=None, **kwargs):\n        super().__init__(**kwargs)\n        if not isinstance(model_name, list):\n            model_name = [model_name]\n        self.model_name = model_name\n        self.key = key",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_re_layoutlm_postprocess",
        "documentation": {}
    },
    {
        "label": "VQASerTokenLayoutLMPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_ser_layoutlm_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_ser_layoutlm_postprocess",
        "peekOfCode": "class VQASerTokenLayoutLMPostProcess(object):\n    \"\"\" Convert between text-label and text-index \"\"\"\n    def __init__(self, class_path, **kwargs):\n        super(VQASerTokenLayoutLMPostProcess, self).__init__()\n        label2id_map, self.id2label_map = load_vqa_bio_label_maps(class_path)\n        self.label2id_map_for_draw = dict()\n        for key in label2id_map:\n            if key.startswith(\"I-\"):\n                self.label2id_map_for_draw[key] = label2id_map[\"B\" + key[1:]]\n            else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_ser_layoutlm_postprocess",
        "documentation": {}
    },
    {
        "label": "DistillationSerPostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_ser_layoutlm_postprocess",
        "description": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_ser_layoutlm_postprocess",
        "peekOfCode": "class DistillationSerPostProcess(VQASerTokenLayoutLMPostProcess):\n    \"\"\"\n    DistillationSerPostProcess\n    \"\"\"\n    def __init__(self, class_path, model_name=[\"Student\"], key=None, **kwargs):\n        super().__init__(class_path, **kwargs)\n        if not isinstance(model_name, list):\n            model_name = [model_name]\n        self.model_name = model_name\n        self.key = key",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.postprocess.vqa_token_ser_layoutlm_postprocess",
        "documentation": {}
    },
    {
        "label": "get_socre_A",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "peekOfCode": "def get_socre_A(gt_dir, pred_dict):\n    allInputs = 1\n    def input_reading_mod(pred_dict):\n        \"\"\"This helper reads input from txt files\"\"\"\n        det = []\n        n = len(pred_dict)\n        for i in range(n):\n            points = pred_dict[i]['points']\n            text = pred_dict[i]['texts']\n            point = \",\".join(map(str, points.reshape(-1, )))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "get_socre_B",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "peekOfCode": "def get_socre_B(gt_dir, img_id, pred_dict):\n    allInputs = 1\n    def input_reading_mod(pred_dict):\n        \"\"\"This helper reads input from txt files\"\"\"\n        det = []\n        n = len(pred_dict)\n        for i in range(n):\n            points = pred_dict[i]['points']\n            text = pred_dict[i]['texts']\n            point = \",\".join(map(str, points.reshape(-1, )))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "get_score_C",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "peekOfCode": "def get_score_C(gt_label, text, pred_bboxes):\n    \"\"\"\n    get score for CentripetalText (CT) prediction.\n    \"\"\"\n    check_install(\"Polygon\", \"Polygon3\")\n    import Polygon as plg\n    def gt_reading_mod(gt_label, text):\n        \"\"\"This helper reads groundtruths from mat files\"\"\"\n        groundtruths = []\n        nbox = len(gt_label)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "combine_results",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "peekOfCode": "def combine_results(all_data, rec_flag=True):\n    tr = 0.7\n    tp = 0.6\n    fsc_k = 0.8\n    k = 2\n    global_sigma = []\n    global_tau = []\n    global_pred_str = []\n    global_gt_str = []\n    for data in all_data:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.Deteval",
        "documentation": {}
    },
    {
        "label": "area",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "peekOfCode": "def area(x, y):\n    polygon = Polygon(np.stack([x, y], axis=1))\n    return float(polygon.area)\ndef approx_area_of_intersection(det_x, det_y, gt_x, gt_y):\n    \"\"\"\n    This helper determine if both polygons are intersecting with each others with an approximation method.\n    Area of intersection represented by the minimum bounding rectangular [xmin, ymin, xmax, ymax]\n    \"\"\"\n    det_ymax = np.max(det_y)\n    det_xmax = np.max(det_x)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "approx_area_of_intersection",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "peekOfCode": "def approx_area_of_intersection(det_x, det_y, gt_x, gt_y):\n    \"\"\"\n    This helper determine if both polygons are intersecting with each others with an approximation method.\n    Area of intersection represented by the minimum bounding rectangular [xmin, ymin, xmax, ymax]\n    \"\"\"\n    det_ymax = np.max(det_y)\n    det_xmax = np.max(det_x)\n    det_ymin = np.min(det_y)\n    det_xmin = np.min(det_x)\n    gt_ymax = np.max(gt_y)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "area_of_intersection",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "peekOfCode": "def area_of_intersection(det_x, det_y, gt_x, gt_y):\n    p1 = Polygon(np.stack([det_x, det_y], axis=1)).buffer(0)\n    p2 = Polygon(np.stack([gt_x, gt_y], axis=1)).buffer(0)\n    return float(p1.intersection(p2).area)\ndef area_of_union(det_x, det_y, gt_x, gt_y):\n    p1 = Polygon(np.stack([det_x, det_y], axis=1)).buffer(0)\n    p2 = Polygon(np.stack([gt_x, gt_y], axis=1)).buffer(0)\n    return float(p1.union(p2).area)\ndef iou(det_x, det_y, gt_x, gt_y):\n    return area_of_intersection(det_x, det_y, gt_x, gt_y) / (",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "area_of_union",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "peekOfCode": "def area_of_union(det_x, det_y, gt_x, gt_y):\n    p1 = Polygon(np.stack([det_x, det_y], axis=1)).buffer(0)\n    p2 = Polygon(np.stack([gt_x, gt_y], axis=1)).buffer(0)\n    return float(p1.union(p2).area)\ndef iou(det_x, det_y, gt_x, gt_y):\n    return area_of_intersection(det_x, det_y, gt_x, gt_y) / (\n        area_of_union(det_x, det_y, gt_x, gt_y) + 1.0)\ndef iod(det_x, det_y, gt_x, gt_y):\n    \"\"\"\n    This helper determine the fraction of intersection area over detection area",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "peekOfCode": "def iou(det_x, det_y, gt_x, gt_y):\n    return area_of_intersection(det_x, det_y, gt_x, gt_y) / (\n        area_of_union(det_x, det_y, gt_x, gt_y) + 1.0)\ndef iod(det_x, det_y, gt_x, gt_y):\n    \"\"\"\n    This helper determine the fraction of intersection area over detection area\n    \"\"\"\n    return area_of_intersection(det_x, det_y, gt_x, gt_y) / (\n        area(det_x, det_y) + 1.0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "iod",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "peekOfCode": "def iod(det_x, det_y, gt_x, gt_y):\n    \"\"\"\n    This helper determine the fraction of intersection area over detection area\n    \"\"\"\n    return area_of_intersection(det_x, det_y, gt_x, gt_y) / (\n        area(det_x, det_y) + 1.0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_metric.polygon_fast",
        "documentation": {}
    },
    {
        "label": "org_tcl_rois",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_batchsize",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_batchsize",
        "peekOfCode": "def org_tcl_rois(batch_size, pos_lists, pos_masks, label_lists, tcl_bs):\n    \"\"\"\n    \"\"\"\n    pos_lists_, pos_masks_, label_lists_ = [], [], []\n    img_bs = batch_size\n    ngpu = int(batch_size / img_bs)\n    img_ids = np.array(pos_lists, dtype=np.int32)[:, 0, 0].copy()\n    pos_lists_split, pos_masks_split, label_lists_split = [], [], []\n    for i in range(ngpu):\n        pos_lists_split.append([])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_batchsize",
        "documentation": {}
    },
    {
        "label": "pre_process",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_batchsize",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_batchsize",
        "peekOfCode": "def pre_process(label_list, pos_list, pos_mask, max_text_length, max_text_nums,\n                pad_num, tcl_bs):\n    label_list = label_list.numpy()\n    batch, _, _, _ = label_list.shape\n    pos_list = pos_list.numpy()\n    pos_mask = pos_mask.numpy()\n    pos_list_t = []\n    pos_mask_t = []\n    label_list_t = []\n    for i in range(batch):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_batchsize",
        "documentation": {}
    },
    {
        "label": "get_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def get_dict(character_dict_path):\n    character_str = \"\"\n    with open(character_dict_path, \"rb\") as fin:\n        lines = fin.readlines()\n        for line in lines:\n            line = line.decode('utf-8').strip(\"\\n\").strip(\"\\r\\n\")\n            character_str += line\n        dict_character = list(character_str)\n    return dict_character\ndef softmax(logits):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "softmax",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def softmax(logits):\n    \"\"\"\n    logits: N x d\n    \"\"\"\n    max_value = np.max(logits, axis=1, keepdims=True)\n    exp = np.exp(logits - max_value)\n    exp_sum = np.sum(exp, axis=1, keepdims=True)\n    dist = exp / exp_sum\n    return dist\ndef get_keep_pos_idxs(labels, remove_blank=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "get_keep_pos_idxs",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def get_keep_pos_idxs(labels, remove_blank=None):\n    \"\"\"\n    Remove duplicate and get pos idxs of keep items.\n    The value of keep_blank should be [None, 95].\n    \"\"\"\n    duplicate_len_list = []\n    keep_pos_idx_list = []\n    keep_char_idx_list = []\n    for k, v_ in groupby(labels):\n        current_len = len(list(v_))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "remove_blank",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def remove_blank(labels, blank=0):\n    new_labels = [x for x in labels if x != blank]\n    return new_labels\ndef insert_blank(labels, blank=0):\n    new_labels = [blank]\n    for l in labels:\n        new_labels += [l, blank]\n    return new_labels\ndef ctc_greedy_decoder(probs_seq, blank=95, keep_blank_in_idxs=True):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "insert_blank",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def insert_blank(labels, blank=0):\n    new_labels = [blank]\n    for l in labels:\n        new_labels += [l, blank]\n    return new_labels\ndef ctc_greedy_decoder(probs_seq, blank=95, keep_blank_in_idxs=True):\n    \"\"\"\n    CTC greedy (best path) decoder.\n    \"\"\"\n    raw_str = np.argmax(np.array(probs_seq), axis=1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "ctc_greedy_decoder",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def ctc_greedy_decoder(probs_seq, blank=95, keep_blank_in_idxs=True):\n    \"\"\"\n    CTC greedy (best path) decoder.\n    \"\"\"\n    raw_str = np.argmax(np.array(probs_seq), axis=1)\n    remove_blank_in_pos = None if keep_blank_in_idxs else blank\n    dedup_str, keep_idx_list = get_keep_pos_idxs(\n        raw_str, remove_blank=remove_blank_in_pos)\n    dst_str = remove_blank(dedup_str, blank=blank)\n    return dst_str, keep_idx_list",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "instance_ctc_greedy_decoder",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def instance_ctc_greedy_decoder(gather_info,\n                                logits_map,\n                                pts_num=4,\n                                point_gather_mode=None):\n    _, _, C = logits_map.shape\n    if point_gather_mode == 'align':\n        insert_num = 0\n        gather_info = np.array(gather_info)\n        length = len(gather_info) - 1\n        for index in range(length):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "ctc_decoder_for_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def ctc_decoder_for_image(gather_info_list,\n                          logits_map,\n                          Lexicon_Table,\n                          pts_num=6,\n                          point_gather_mode=None):\n    \"\"\"\n    CTC decoder using multiple processes.\n    \"\"\"\n    decoder_str = []\n    decoder_xys = []",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "sort_with_direction",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def sort_with_direction(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    def sort_part_with_direction(pos_list, point_direction):\n        pos_list = np.array(pos_list).reshape(-1, 2)\n        point_direction = np.array(point_direction).reshape(-1, 2)\n        average_direction = np.mean(point_direction, axis=0, keepdims=True)\n        pos_proj_leng = np.sum(pos_list * average_direction, axis=1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "add_id",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def add_id(pos_list, image_id=0):\n    \"\"\"\n    Add id for gather feature, for inference.\n    \"\"\"\n    new_list = []\n    for item in pos_list:\n        new_list.append((image_id, item[0], item[1]))\n    return new_list\ndef sort_and_expand_with_direction(pos_list, f_direction):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "sort_and_expand_with_direction",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def sort_and_expand_with_direction(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    h, w, _ = f_direction.shape\n    sorted_list, point_direction = sort_with_direction(pos_list, f_direction)\n    point_num = len(sorted_list)\n    sub_direction_len = max(point_num // 3, 2)\n    left_direction = point_direction[:sub_direction_len, :]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "sort_and_expand_with_direction_v2",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def sort_and_expand_with_direction_v2(pos_list, f_direction, binary_tcl_map):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    binary_tcl_map: h x w\n    \"\"\"\n    h, w, _ = f_direction.shape\n    sorted_list, point_direction = sort_with_direction(pos_list, f_direction)\n    point_num = len(sorted_list)\n    sub_direction_len = max(point_num // 3, 2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "point_pair2poly",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def point_pair2poly(point_pair_list):\n    \"\"\"\n    Transfer vertical point_pairs into poly point in clockwise.\n    \"\"\"\n    point_num = len(point_pair_list) * 2\n    point_list = [0] * point_num\n    for idx, point_pair in enumerate(point_pair_list):\n        point_list[idx] = point_pair[0]\n        point_list[point_num - 1 - idx] = point_pair[1]\n    return np.array(point_list).reshape(-1, 2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "shrink_quad_along_width",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def shrink_quad_along_width(quad, begin_width_ratio=0., end_width_ratio=1.):\n    ratio_pair = np.array(\n        [[begin_width_ratio], [end_width_ratio]], dtype=np.float32)\n    p0_1 = quad[0] + (quad[1] - quad[0]) * ratio_pair\n    p3_2 = quad[3] + (quad[2] - quad[3]) * ratio_pair\n    return np.array([p0_1[0], p0_1[1], p3_2[1], p3_2[0]])\ndef expand_poly_along_width(poly, shrink_ratio_of_width=0.3):\n    \"\"\"\n    expand poly along width.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "expand_poly_along_width",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def expand_poly_along_width(poly, shrink_ratio_of_width=0.3):\n    \"\"\"\n    expand poly along width.\n    \"\"\"\n    point_num = poly.shape[0]\n    left_quad = np.array(\n        [poly[0], poly[1], poly[-2], poly[-1]], dtype=np.float32)\n    left_ratio = -shrink_ratio_of_width * np.linalg.norm(left_quad[0] - left_quad[3]) / \\\n                 (np.linalg.norm(left_quad[0] - left_quad[1]) + 1e-6)\n    left_quad_expand = shrink_quad_along_width(left_quad, left_ratio, 1.0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "restore_poly",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def restore_poly(instance_yxs_list, seq_strs, p_border, ratio_w, ratio_h, src_w,\n                 src_h, valid_set):\n    poly_list = []\n    keep_str_list = []\n    for yx_center_line, keep_str in zip(instance_yxs_list, seq_strs):\n        if len(keep_str) < 2:\n            print('--> too short, {}'.format(keep_str))\n            continue\n        offset_expand = 1.0\n        if valid_set == 'totaltext':",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "generate_pivot_list_fast",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def generate_pivot_list_fast(p_score,\n                             p_char_maps,\n                             f_direction,\n                             Lexicon_Table,\n                             score_thresh=0.5,\n                             point_gather_mode=None):\n    \"\"\"\n    return center point and end point of TCL instance; filter with the char maps;\n    \"\"\"\n    p_score = p_score[0]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "extract_main_direction",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def extract_main_direction(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    pos_list = np.array(pos_list)\n    point_direction = f_direction[pos_list[:, 0], pos_list[:, 1]]\n    point_direction = point_direction[:, ::-1]  # x, y -> y, x\n    average_direction = np.mean(point_direction, axis=0, keepdims=True)\n    average_direction = average_direction / (",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "sort_by_direction_with_image_id_deprecated",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def sort_by_direction_with_image_id_deprecated(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[id, y, x], [id, y, x], [id, y, x] ...]\n    \"\"\"\n    pos_list_full = np.array(pos_list).reshape(-1, 3)\n    pos_list = pos_list_full[:, 1:]\n    point_direction = f_direction[pos_list[:, 0], pos_list[:, 1]]  # x, y\n    point_direction = point_direction[:, ::-1]  # x, y -> y, x\n    average_direction = np.mean(point_direction, axis=0, keepdims=True)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "sort_by_direction_with_image_id",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "peekOfCode": "def sort_by_direction_with_image_id(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    def sort_part_with_direction(pos_list_full, point_direction):\n        pos_list_full = np.array(pos_list_full).reshape(-1, 3)\n        pos_list = pos_list_full[:, 1:]\n        point_direction = np.array(point_direction).reshape(-1, 2)\n        average_direction = np.mean(point_direction, axis=0, keepdims=True)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_fast",
        "documentation": {}
    },
    {
        "label": "get_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def get_dict(character_dict_path):\n    character_str = \"\"\n    with open(character_dict_path, \"rb\") as fin:\n        lines = fin.readlines()\n        for line in lines:\n            line = line.decode('utf-8').strip(\"\\n\").strip(\"\\r\\n\")\n            character_str += line\n        dict_character = list(character_str)\n    return dict_character\ndef point_pair2poly(point_pair_list):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "point_pair2poly",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def point_pair2poly(point_pair_list):\n    \"\"\"\n    Transfer vertical point_pairs into poly point in clockwise.\n    \"\"\"\n    pair_length_list = []\n    for point_pair in point_pair_list:\n        pair_length = np.linalg.norm(point_pair[0] - point_pair[1])\n        pair_length_list.append(pair_length)\n    pair_length_list = np.array(pair_length_list)\n    pair_info = (pair_length_list.max(), pair_length_list.min(),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "shrink_quad_along_width",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def shrink_quad_along_width(quad, begin_width_ratio=0., end_width_ratio=1.):\n    \"\"\"\n    Generate shrink_quad_along_width.\n    \"\"\"\n    ratio_pair = np.array(\n        [[begin_width_ratio], [end_width_ratio]], dtype=np.float32)\n    p0_1 = quad[0] + (quad[1] - quad[0]) * ratio_pair\n    p3_2 = quad[3] + (quad[2] - quad[3]) * ratio_pair\n    return np.array([p0_1[0], p0_1[1], p3_2[1], p3_2[0]])\ndef expand_poly_along_width(poly, shrink_ratio_of_width=0.3):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "expand_poly_along_width",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def expand_poly_along_width(poly, shrink_ratio_of_width=0.3):\n    \"\"\"\n    expand poly along width.\n    \"\"\"\n    point_num = poly.shape[0]\n    left_quad = np.array(\n        [poly[0], poly[1], poly[-2], poly[-1]], dtype=np.float32)\n    left_ratio = -shrink_ratio_of_width * np.linalg.norm(left_quad[0] - left_quad[3]) / \\\n                 (np.linalg.norm(left_quad[0] - left_quad[1]) + 1e-6)\n    left_quad_expand = shrink_quad_along_width(left_quad, left_ratio, 1.0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "softmax",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def softmax(logits):\n    \"\"\"\n    logits: N x d\n    \"\"\"\n    max_value = np.max(logits, axis=1, keepdims=True)\n    exp = np.exp(logits - max_value)\n    exp_sum = np.sum(exp, axis=1, keepdims=True)\n    dist = exp / exp_sum\n    return dist\ndef get_keep_pos_idxs(labels, remove_blank=None):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "get_keep_pos_idxs",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def get_keep_pos_idxs(labels, remove_blank=None):\n    \"\"\"\n    Remove duplicate and get pos idxs of keep items.\n    The value of keep_blank should be [None, 95].\n    \"\"\"\n    duplicate_len_list = []\n    keep_pos_idx_list = []\n    keep_char_idx_list = []\n    for k, v_ in groupby(labels):\n        current_len = len(list(v_))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "remove_blank",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def remove_blank(labels, blank=0):\n    new_labels = [x for x in labels if x != blank]\n    return new_labels\ndef insert_blank(labels, blank=0):\n    new_labels = [blank]\n    for l in labels:\n        new_labels += [l, blank]\n    return new_labels\ndef ctc_greedy_decoder(probs_seq, blank=95, keep_blank_in_idxs=True):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "insert_blank",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def insert_blank(labels, blank=0):\n    new_labels = [blank]\n    for l in labels:\n        new_labels += [l, blank]\n    return new_labels\ndef ctc_greedy_decoder(probs_seq, blank=95, keep_blank_in_idxs=True):\n    \"\"\"\n    CTC greedy (best path) decoder.\n    \"\"\"\n    raw_str = np.argmax(np.array(probs_seq), axis=1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "ctc_greedy_decoder",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def ctc_greedy_decoder(probs_seq, blank=95, keep_blank_in_idxs=True):\n    \"\"\"\n    CTC greedy (best path) decoder.\n    \"\"\"\n    raw_str = np.argmax(np.array(probs_seq), axis=1)\n    remove_blank_in_pos = None if keep_blank_in_idxs else blank\n    dedup_str, keep_idx_list = get_keep_pos_idxs(\n        raw_str, remove_blank=remove_blank_in_pos)\n    dst_str = remove_blank(dedup_str, blank=blank)\n    return dst_str, keep_idx_list",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "instance_ctc_greedy_decoder",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def instance_ctc_greedy_decoder(gather_info,\n                                logits_map,\n                                keep_blank_in_idxs=True):\n    \"\"\"\n    gather_info: [[x, y], [x, y] ...]\n    logits_map: H x W X (n_chars + 1)\n    \"\"\"\n    _, _, C = logits_map.shape\n    ys, xs = zip(*gather_info)\n    logits_seq = logits_map[list(ys), list(xs)]  # n x 96",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "ctc_decoder_for_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def ctc_decoder_for_image(gather_info_list, logits_map,\n                          keep_blank_in_idxs=True):\n    \"\"\"\n    CTC decoder using multiple processes.\n    \"\"\"\n    decoder_results = []\n    for gather_info in gather_info_list:\n        res = instance_ctc_greedy_decoder(\n            gather_info, logits_map, keep_blank_in_idxs=keep_blank_in_idxs)\n        decoder_results.append(res)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "sort_with_direction",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def sort_with_direction(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    def sort_part_with_direction(pos_list, point_direction):\n        pos_list = np.array(pos_list).reshape(-1, 2)\n        point_direction = np.array(point_direction).reshape(-1, 2)\n        average_direction = np.mean(point_direction, axis=0, keepdims=True)\n        pos_proj_leng = np.sum(pos_list * average_direction, axis=1)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "add_id",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def add_id(pos_list, image_id=0):\n    \"\"\"\n    Add id for gather feature, for inference.\n    \"\"\"\n    new_list = []\n    for item in pos_list:\n        new_list.append((image_id, item[0], item[1]))\n    return new_list\ndef sort_and_expand_with_direction(pos_list, f_direction):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "sort_and_expand_with_direction",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def sort_and_expand_with_direction(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    h, w, _ = f_direction.shape\n    sorted_list, point_direction = sort_with_direction(pos_list, f_direction)\n    # expand along\n    point_num = len(sorted_list)\n    sub_direction_len = max(point_num // 3, 2)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "sort_and_expand_with_direction_v2",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def sort_and_expand_with_direction_v2(pos_list, f_direction, binary_tcl_map):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    binary_tcl_map: h x w\n    \"\"\"\n    h, w, _ = f_direction.shape\n    sorted_list, point_direction = sort_with_direction(pos_list, f_direction)\n    # expand along\n    point_num = len(sorted_list)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "generate_pivot_list_curved",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def generate_pivot_list_curved(p_score,\n                               p_char_maps,\n                               f_direction,\n                               score_thresh=0.5,\n                               is_expand=True,\n                               is_backbone=False,\n                               image_id=0):\n    \"\"\"\n    return center point and end point of TCL instance; filter with the char maps;\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "generate_pivot_list_horizontal",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def generate_pivot_list_horizontal(p_score,\n                                   p_char_maps,\n                                   f_direction,\n                                   score_thresh=0.5,\n                                   is_backbone=False,\n                                   image_id=0):\n    \"\"\"\n    return center point and end point of TCL instance; filter with the char maps;\n    \"\"\"\n    p_score = p_score[0]",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "generate_pivot_list_slow",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def generate_pivot_list_slow(p_score,\n                             p_char_maps,\n                             f_direction,\n                             score_thresh=0.5,\n                             is_backbone=False,\n                             is_curved=True,\n                             image_id=0):\n    \"\"\"\n    Warp all the function together.\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "extract_main_direction",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def extract_main_direction(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    pos_list = np.array(pos_list)\n    point_direction = f_direction[pos_list[:, 0], pos_list[:, 1]]\n    point_direction = point_direction[:, ::-1]  # x, y -> y, x\n    average_direction = np.mean(point_direction, axis=0, keepdims=True)\n    average_direction = average_direction / (",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "sort_by_direction_with_image_id_deprecated",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def sort_by_direction_with_image_id_deprecated(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[id, y, x], [id, y, x], [id, y, x] ...]\n    \"\"\"\n    pos_list_full = np.array(pos_list).reshape(-1, 3)\n    pos_list = pos_list_full[:, 1:]\n    point_direction = f_direction[pos_list[:, 0], pos_list[:, 1]]  # x, y\n    point_direction = point_direction[:, ::-1]  # x, y -> y, x\n    average_direction = np.mean(point_direction, axis=0, keepdims=True)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "sort_by_direction_with_image_id",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def sort_by_direction_with_image_id(pos_list, f_direction):\n    \"\"\"\n    f_direction: h x w x 2\n    pos_list: [[y, x], [y, x], [y, x] ...]\n    \"\"\"\n    def sort_part_with_direction(pos_list_full, point_direction):\n        pos_list_full = np.array(pos_list_full).reshape(-1, 3)\n        pos_list = pos_list_full[:, 1:]\n        point_direction = np.array(point_direction).reshape(-1, 2)\n        average_direction = np.mean(point_direction, axis=0, keepdims=True)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "generate_pivot_list_tt_inference",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "peekOfCode": "def generate_pivot_list_tt_inference(p_score,\n                                     p_char_maps,\n                                     f_direction,\n                                     score_thresh=0.5,\n                                     is_backbone=False,\n                                     is_curved=True,\n                                     image_id=0):\n    \"\"\"\n    return center point and end point of TCL instance; filter with the char maps;\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.extract_textpoint_slow",
        "documentation": {}
    },
    {
        "label": "PGNet_PostProcess",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.pgnet_pp_utils",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.pgnet_pp_utils",
        "peekOfCode": "class PGNet_PostProcess(object):\n    # two different post-process\n    def __init__(self,\n                 character_dict_path,\n                 valid_set,\n                 score_thresh,\n                 outs_dict,\n                 shape_list,\n                 point_gather_mode=None):\n        self.Lexicon_Table = get_dict(character_dict_path)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.pgnet_pp_utils",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.pgnet_pp_utils",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.pgnet_pp_utils",
        "peekOfCode": "__dir__ = os.path.dirname(__file__)\nsys.path.append(__dir__)\nsys.path.append(os.path.join(__dir__, '..'))\nfrom extract_textpoint_slow import *\nfrom extract_textpoint_fast import generate_pivot_list_fast, restore_poly\nclass PGNet_PostProcess(object):\n    # two different post-process\n    def __init__(self,\n                 character_dict_path,\n                 valid_set,",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.pgnet_pp_utils",
        "documentation": {}
    },
    {
        "label": "resize_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def resize_image(im, max_side_len=512):\n    \"\"\"\n    resize image to a size multiple of max_stride which is required by the network\n    :param im: the resized image\n    :param max_side_len: limit of max image size to avoid out of memory in gpu\n    :return: the resized image and the resize ratio\n    \"\"\"\n    h, w, _ = im.shape\n    resize_w = w\n    resize_h = h",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "resize_image_min",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def resize_image_min(im, max_side_len=512):\n    \"\"\"\n    \"\"\"\n    h, w, _ = im.shape\n    resize_w = w\n    resize_h = h\n    if resize_h < resize_w:\n        ratio = float(max_side_len) / resize_h\n    else:\n        ratio = float(max_side_len) / resize_w",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "resize_image_for_totaltext",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def resize_image_for_totaltext(im, max_side_len=512):\n    \"\"\"\n    \"\"\"\n    h, w, _ = im.shape\n    resize_w = w\n    resize_h = h\n    ratio = 1.25\n    if h * ratio > max_side_len:\n        ratio = float(max_side_len) / resize_h\n    resize_h = int(resize_h * ratio)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "point_pair2poly",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def point_pair2poly(point_pair_list):\n    \"\"\"\n    Transfer vertical point_pairs into poly point in clockwise.\n    \"\"\"\n    pair_length_list = []\n    for point_pair in point_pair_list:\n        pair_length = np.linalg.norm(point_pair[0] - point_pair[1])\n        pair_length_list.append(pair_length)\n    pair_length_list = np.array(pair_length_list)\n    pair_info = (pair_length_list.max(), pair_length_list.min(),",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "shrink_quad_along_width",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def shrink_quad_along_width(quad, begin_width_ratio=0., end_width_ratio=1.):\n    \"\"\"\n    Generate shrink_quad_along_width.\n    \"\"\"\n    ratio_pair = np.array(\n        [[begin_width_ratio], [end_width_ratio]], dtype=np.float32)\n    p0_1 = quad[0] + (quad[1] - quad[0]) * ratio_pair\n    p3_2 = quad[3] + (quad[2] - quad[3]) * ratio_pair\n    return np.array([p0_1[0], p0_1[1], p3_2[1], p3_2[0]])\ndef expand_poly_along_width(poly, shrink_ratio_of_width=0.3):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "expand_poly_along_width",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def expand_poly_along_width(poly, shrink_ratio_of_width=0.3):\n    \"\"\"\n    expand poly along width.\n    \"\"\"\n    point_num = poly.shape[0]\n    left_quad = np.array(\n        [poly[0], poly[1], poly[-2], poly[-1]], dtype=np.float32)\n    left_ratio = -shrink_ratio_of_width * np.linalg.norm(left_quad[0] - left_quad[3]) / \\\n                 (np.linalg.norm(left_quad[0] - left_quad[1]) + 1e-6)\n    left_quad_expand = shrink_quad_along_width(left_quad, left_ratio, 1.0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "norm2",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def norm2(x, axis=None):\n    if axis:\n        return np.sqrt(np.sum(x**2, axis=axis))\n    return np.sqrt(np.sum(x**2))\ndef cos(p1, p2):\n    return (p1 * p2).sum() / (norm2(p1) * norm2(p2))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "cos",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "peekOfCode": "def cos(p1, p2):\n    return (p1 * p2).sum() / (norm2(p1) * norm2(p2))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.e2e_utils.visual",
        "documentation": {}
    },
    {
        "label": "BaseLogger",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.base_logger",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.base_logger",
        "peekOfCode": "class BaseLogger(ABC):\n    def __init__(self, save_dir):\n        self.save_dir = save_dir\n        os.makedirs(self.save_dir, exist_ok=True)\n    @abstractmethod\n    def log_metrics(self, metrics, prefix=None):\n        pass\n    @abstractmethod\n    def close(self):\n        pass",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.base_logger",
        "documentation": {}
    },
    {
        "label": "Loggers",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.loggers",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.loggers",
        "peekOfCode": "class Loggers(object):\n    def __init__(self, loggers):\n        super().__init__()\n        self.loggers = loggers\n    def log_metrics(self, metrics, prefix=None, step=None):\n        for logger in self.loggers:\n            logger.log_metrics(metrics, prefix=prefix, step=step)\n    def log_model(self, is_best, prefix, metadata=None):\n        for logger in self.loggers:\n            logger.log_model(is_best=is_best, prefix=prefix, metadata=metadata)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.loggers",
        "documentation": {}
    },
    {
        "label": "VDLLogger",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.vdl_logger",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.vdl_logger",
        "peekOfCode": "class VDLLogger(BaseLogger):\n    def __init__(self, save_dir):\n        super().__init__(save_dir)\n        self.vdl_writer = LogWriter(logdir=save_dir)\n    def log_metrics(self, metrics, prefix=None, step=None):\n        if not prefix:\n            prefix = \"\"\n        updated_metrics = {prefix + \"/\" + k: v for k, v in metrics.items()}\n        for k, v in updated_metrics.items():\n            self.vdl_writer.add_scalar(k, v, step)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.vdl_logger",
        "documentation": {}
    },
    {
        "label": "WandbLogger",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.wandb_logger",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.wandb_logger",
        "peekOfCode": "class WandbLogger(BaseLogger):\n    def __init__(self, \n        project=None, \n        name=None, \n        id=None, \n        entity=None, \n        save_dir=None, \n        config=None,\n        **kwargs):\n        try:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.loggers.wandb_logger",
        "documentation": {}
    },
    {
        "label": "gen_rec_label",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.gen_label",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.gen_label",
        "peekOfCode": "def gen_rec_label(input_path, out_label):\n    with open(out_label, 'w') as out_file:\n        with open(input_path, 'r') as f:\n            for line in f.readlines():\n                tmp = line.strip('\\n').replace(\" \", \"\").split(',')\n                img_path, label = tmp[0], tmp[1]\n                label = label.replace(\"\\\"\", \"\")\n                out_file.write(img_path + '\\t' + label + '\\n')\ndef gen_det_label(root_path, input_dir, out_label):\n    with open(out_label, 'w') as out_file:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.gen_label",
        "documentation": {}
    },
    {
        "label": "gen_det_label",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.gen_label",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.gen_label",
        "peekOfCode": "def gen_det_label(root_path, input_dir, out_label):\n    with open(out_label, 'w') as out_file:\n        for label_file in os.listdir(input_dir):\n            img_path = os.path.join(root_path, label_file[3:-4] + \".jpg\")\n            label = []\n            with open(\n                    os.path.join(input_dir, label_file), 'r',\n                    encoding='utf-8-sig') as f:\n                for line in f.readlines():\n                    tmp = line.strip(\"\\n\\r\").replace(\"\\xef\\xbb\\xbf\",",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.gen_label",
        "documentation": {}
    },
    {
        "label": "iou_single",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "peekOfCode": "def iou_single(a, b, mask, n_class):\n    valid = mask == 1\n    a = a.masked_select(valid)\n    b = b.masked_select(valid)\n    miou = []\n    for i in range(n_class):\n        if a.shape == [0] and a.shape == b.shape:\n            inter = paddle.to_tensor(0.0)\n            union = paddle.to_tensor(0.0)\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "documentation": {}
    },
    {
        "label": "iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "peekOfCode": "def iou(a, b, mask, n_class=2, reduce=True):\n    batch_size = a.shape[0]\n    a = a.reshape([batch_size, -1])\n    b = b.reshape([batch_size, -1])\n    mask = mask.reshape([batch_size, -1])\n    iou = paddle.zeros((batch_size, ), dtype='float32')\n    for i in range(batch_size):\n        iou[i] = iou_single(a[i], b[i], mask[i], n_class)\n    if reduce:\n        iou = paddle.mean(iou)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "documentation": {}
    },
    {
        "label": "EPS",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "peekOfCode": "EPS = 1e-6\ndef iou_single(a, b, mask, n_class):\n    valid = mask == 1\n    a = a.masked_select(valid)\n    b = b.masked_select(valid)\n    miou = []\n    for i in range(n_class):\n        if a.shape == [0] and a.shape == b.shape:\n            inter = paddle.to_tensor(0.0)\n            union = paddle.to_tensor(0.0)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.iou",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.logging",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.logging",
        "peekOfCode": "def get_logger(name='ppocr', log_file=None, log_level=logging.DEBUG):\n    \"\"\"Initialize and get a logger by name.\n    If the logger has not been initialized, this method will initialize the\n    logger by adding one or two handlers, otherwise the initialized logger will\n    be directly returned. During initialization, a StreamHandler will always be\n    added. If `log_file` is specified a FileHandler will also be added.\n    Args:\n        name (str): Logger name.\n        log_file (str | None): The log filename. If specified, a FileHandler\n            will be added to the logger.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger_initialized",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.logging",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.logging",
        "peekOfCode": "logger_initialized = {}\n@functools.lru_cache()\ndef get_logger(name='ppocr', log_file=None, log_level=logging.DEBUG):\n    \"\"\"Initialize and get a logger by name.\n    If the logger has not been initialized, this method will initialize the\n    logger by adding one or two handlers, otherwise the initialized logger will\n    be directly returned. During initialization, a StreamHandler will always be\n    added. If `log_file` is specified a FileHandler will also be added.\n    Args:\n        name (str): Logger name.",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.logging",
        "documentation": {}
    },
    {
        "label": "download_with_progressbar",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "peekOfCode": "def download_with_progressbar(url, save_path):\n    logger = get_logger()\n    response = requests.get(url, stream=True)\n    if response.status_code == 200:\n        total_size_in_bytes = int(response.headers.get('content-length', 1))\n        block_size = 1024  # 1 Kibibyte\n        progress_bar = tqdm(\n            total=total_size_in_bytes, unit='iB', unit_scale=True)\n        with open(save_path, 'wb') as file:\n            for data in response.iter_content(block_size):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "maybe_download",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "peekOfCode": "def maybe_download(model_storage_directory, url):\n    # using custom model\n    tar_file_name_list = ['.pdiparams', '.pdiparams.info', '.pdmodel']\n    if not os.path.exists(\n            os.path.join(model_storage_directory, 'inference.pdiparams')\n    ) or not os.path.exists(\n            os.path.join(model_storage_directory, 'inference.pdmodel')):\n        assert url.endswith('.tar'), 'Only supports tar compressed package'\n        tmp_path = os.path.join(model_storage_directory, url.split('/')[-1])\n        print('download {} to {}'.format(url, tmp_path))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "maybe_download_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "peekOfCode": "def maybe_download_params(model_path):\n    if os.path.exists(model_path) or not is_link(model_path):\n        return model_path\n    else:\n        url = model_path\n    tmp_path = os.path.join(MODELS_DIR, url.split('/')[-1])\n    print('download {} to {}'.format(url, tmp_path))\n    os.makedirs(MODELS_DIR, exist_ok=True)\n    download_with_progressbar(url, tmp_path)\n    return tmp_path",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "is_link",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "peekOfCode": "def is_link(s):\n    return s is not None and s.startswith('http')\ndef confirm_model_dir_url(model_dir, default_model_dir, default_url):\n    url = default_url\n    if model_dir is None or is_link(model_dir):\n        if is_link(model_dir):\n            url = model_dir\n        file_name = url.split('/')[-1][:-4]\n        model_dir = default_model_dir\n        model_dir = os.path.join(model_dir, file_name)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "confirm_model_dir_url",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "peekOfCode": "def confirm_model_dir_url(model_dir, default_model_dir, default_url):\n    url = default_url\n    if model_dir is None or is_link(model_dir):\n        if is_link(model_dir):\n            url = model_dir\n        file_name = url.split('/')[-1][:-4]\n        model_dir = default_model_dir\n        model_dir = os.path.join(model_dir, file_name)\n    return model_dir, url",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "MODELS_DIR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "peekOfCode": "MODELS_DIR = os.path.expanduser(\"~/.paddleocr/models/\")\ndef download_with_progressbar(url, save_path):\n    logger = get_logger()\n    response = requests.get(url, stream=True)\n    if response.status_code == 200:\n        total_size_in_bytes = int(response.headers.get('content-length', 1))\n        block_size = 1024  # 1 Kibibyte\n        progress_bar = tqdm(\n            total=total_size_in_bytes, unit='iB', unit_scale=True)\n        with open(save_path, 'wb') as file:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.network",
        "documentation": {}
    },
    {
        "label": "points2polygon",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "peekOfCode": "def points2polygon(points):\n    \"\"\"Convert k points to 1 polygon.\n    Args:\n        points (ndarray or list): A ndarray or a list of shape (2k)\n            that indicates k points.\n    Returns:\n        polygon (Polygon): A polygon object.\n    \"\"\"\n    if isinstance(points, list):\n        points = np.array(points)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "poly_intersection",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "peekOfCode": "def poly_intersection(poly_det, poly_gt, buffer=0.0001):\n    \"\"\"Calculate the intersection area between two polygon.\n    Args:\n        poly_det (Polygon): A polygon predicted by detector.\n        poly_gt (Polygon): A gt polygon.\n    Returns:\n        intersection_area (float): The intersection area between two polygons.\n    \"\"\"\n    assert isinstance(poly_det, Polygon)\n    assert isinstance(poly_gt, Polygon)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "poly_union",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "peekOfCode": "def poly_union(poly_det, poly_gt):\n    \"\"\"Calculate the union area between two polygon.\n    Args:\n        poly_det (Polygon): A polygon predicted by detector.\n        poly_gt (Polygon): A gt polygon.\n    Returns:\n        union_area (float): The union area between two polygons.\n    \"\"\"\n    assert isinstance(poly_det, Polygon)\n    assert isinstance(poly_gt, Polygon)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "valid_boundary",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "peekOfCode": "def valid_boundary(x, with_score=True):\n    num = len(x)\n    if num < 8:\n        return False\n    if num % 2 == 0 and (not with_score):\n        return True\n    if num % 2 == 1 and with_score:\n        return True\n    return False\ndef boundary_iou(src, target):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "boundary_iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "peekOfCode": "def boundary_iou(src, target):\n    \"\"\"Calculate the IOU between two boundaries.\n    Args:\n       src (list): Source boundary.\n       target (list): Target boundary.\n    Returns:\n       iou (float): The iou between two boundaries.\n    \"\"\"\n    assert valid_boundary(src, False)\n    assert valid_boundary(target, False)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "poly_iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "peekOfCode": "def poly_iou(poly_det, poly_gt):\n    \"\"\"Calculate the IOU between two polygons.\n    Args:\n        poly_det (Polygon): A polygon predicted by detector.\n        poly_gt (Polygon): A gt polygon.\n    Returns:\n        iou (float): The IOU between two polygons.\n    \"\"\"\n    assert isinstance(poly_det, Polygon)\n    assert isinstance(poly_gt, Polygon)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "poly_nms",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "peekOfCode": "def poly_nms(polygons, threshold):\n    assert isinstance(polygons, list)\n    polygons = np.array(sorted(polygons, key=lambda x: x[-1]))\n    keep_poly = []\n    index = [i for i in range(polygons.shape[0])]\n    while len(index) > 0:\n        keep_poly.append(polygons[index[-1]].tolist())\n        A = polygons[index[-1]][:-1]\n        index = np.delete(index, -1)\n        iou_list = np.zeros((len(index), ))",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.poly_nms",
        "documentation": {}
    },
    {
        "label": "ProfilerOptions",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "peekOfCode": "class ProfilerOptions(object):\n    '''\n    Use a string to initialize a ProfilerOptions.\n    The string should be in the format: \"key1=value1;key2=value;key3=value3\".\n    For example:\n      \"profile_path=model.profile\"\n      \"batch_range=[50, 60]; profile_path=model.profile\"\n      \"batch_range=[50, 60]; tracer_option=OpDetail; profile_path=model.profile\"\n    ProfilerOptions supports following key-value pair:\n      batch_range      - a integer list, e.g. [100, 110].",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "documentation": {}
    },
    {
        "label": "add_profiler_step",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "peekOfCode": "def add_profiler_step(options_str=None):\n    '''\n    Enable the operator-level timing using PaddlePaddle's profiler.\n    The profiler uses a independent variable to count the profiler steps.\n    One call of this function is treated as a profiler step.\n    Args:\n      profiler_options - a string to initialize the ProfilerOptions.\n                         Default is None, and the profiler is disabled.\n    '''\n    if options_str is None:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "documentation": {}
    },
    {
        "label": "_profiler_step_id",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "peekOfCode": "_profiler_step_id = 0\n# A global variable to avoid parsing from string every time.\n_profiler_options = None\n_prof = None\nclass ProfilerOptions(object):\n    '''\n    Use a string to initialize a ProfilerOptions.\n    The string should be in the format: \"key1=value1;key2=value;key3=value3\".\n    For example:\n      \"profile_path=model.profile\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "documentation": {}
    },
    {
        "label": "_profiler_options",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "peekOfCode": "_profiler_options = None\n_prof = None\nclass ProfilerOptions(object):\n    '''\n    Use a string to initialize a ProfilerOptions.\n    The string should be in the format: \"key1=value1;key2=value;key3=value3\".\n    For example:\n      \"profile_path=model.profile\"\n      \"batch_range=[50, 60]; profile_path=model.profile\"\n      \"batch_range=[50, 60]; tracer_option=OpDetail; profile_path=model.profile\"",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "documentation": {}
    },
    {
        "label": "_prof",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "peekOfCode": "_prof = None\nclass ProfilerOptions(object):\n    '''\n    Use a string to initialize a ProfilerOptions.\n    The string should be in the format: \"key1=value1;key2=value;key3=value3\".\n    For example:\n      \"profile_path=model.profile\"\n      \"batch_range=[50, 60]; profile_path=model.profile\"\n      \"batch_range=[50, 60]; tracer_option=OpDetail; profile_path=model.profile\"\n    ProfilerOptions supports following key-value pair:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.profiler",
        "documentation": {}
    },
    {
        "label": "load_model",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "peekOfCode": "def load_model(config, model, optimizer=None, model_type='det'):\n    \"\"\"\n    load model from checkpoint or pretrained_model\n    \"\"\"\n    logger = get_logger()\n    global_config = config['Global']\n    checkpoints = global_config.get('checkpoints')\n    pretrained_model = global_config.get('pretrained_model')\n    best_model_dict = {}\n    is_float16 = False",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "load_pretrained_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "peekOfCode": "def load_pretrained_params(model, path):\n    logger = get_logger()\n    path = maybe_download_params(path)\n    if path.endswith('.pdparams'):\n        path = path.replace('.pdparams', '')\n    assert os.path.exists(path + \".pdparams\"), \\\n        \"The {}.pdparams does not exists!\".format(path)\n    params = paddle.load(path + '.pdparams')\n    state_dict = model.state_dict()\n    new_state_dict = {}",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "save_model",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "peekOfCode": "def save_model(model,\n               optimizer,\n               model_path,\n               logger,\n               config,\n               is_best=False,\n               prefix='ppocr',\n               **kwargs):\n    \"\"\"\n    save model to the target path",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "peekOfCode": "__all__ = ['load_model']\ndef _mkdir_if_not_exist(path, logger):\n    \"\"\"\n    mkdir if not exists, ignore the exception when multiprocess mkdir together\n    \"\"\"\n    if not os.path.exists(path):\n        try:\n            os.makedirs(path)\n        except OSError as e:\n            if e.errno == errno.EEXIST and os.path.isdir(path):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.save_load",
        "documentation": {}
    },
    {
        "label": "SmoothedValue",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "peekOfCode": "class SmoothedValue(object):\n    \"\"\"Track a series of values and provide access to smoothed values over a\n    window or the global series average.\n    \"\"\"\n    def __init__(self, window_size):\n        self.deque = collections.deque(maxlen=window_size)\n    def add_value(self, value):\n        self.deque.append(value)\n    def get_median_value(self):\n        return np.median(self.deque)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "documentation": {}
    },
    {
        "label": "TrainingStats",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "peekOfCode": "class TrainingStats(object):\n    def __init__(self, window_size, stats_keys):\n        self.window_size = window_size\n        self.smoothed_losses_and_metrics = {\n            key: SmoothedValue(window_size)\n            for key in stats_keys\n        }\n    def update(self, stats):\n        for k, v in stats.items():\n            if k not in self.smoothed_losses_and_metrics:",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "documentation": {}
    },
    {
        "label": "Time",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "peekOfCode": "def Time():\n    return datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')\nclass TrainingStats(object):\n    def __init__(self, window_size, stats_keys):\n        self.window_size = window_size\n        self.smoothed_losses_and_metrics = {\n            key: SmoothedValue(window_size)\n            for key in stats_keys\n        }\n    def update(self, stats):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "peekOfCode": "__all__ = ['TrainingStats', 'Time']\nclass SmoothedValue(object):\n    \"\"\"Track a series of values and provide access to smoothed values over a\n    window or the global series average.\n    \"\"\"\n    def __init__(self, window_size):\n        self.deque = collections.deque(maxlen=window_size)\n    def add_value(self, value):\n        self.deque.append(value)\n    def get_median_value(self):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.stats",
        "documentation": {}
    },
    {
        "label": "AverageMeter",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "class AverageMeter:\n    def __init__(self):\n        self.reset()\n    def reset(self):\n        \"\"\"reset\"\"\"\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n    def update(self, val, n=1):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "print_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def print_dict(d, logger, delimiter=0):\n    \"\"\"\n    Recursively visualize a dict and\n    indenting acrrording by the relationship of keys.\n    \"\"\"\n    for k, v in sorted(d.items()):\n        if isinstance(v, dict):\n            logger.info(\"{}{} : \".format(delimiter * \" \", str(k)))\n            print_dict(v, logger, delimiter + 4)\n        elif isinstance(v, list) and len(v) >= 1 and isinstance(v[0], dict):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_check_global_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def get_check_global_params(mode):\n    check_params = ['use_gpu', 'max_text_length', 'image_shape', \\\n                    'image_shape', 'character_type', 'loss_type']\n    if mode == \"train_eval\":\n        check_params = check_params + [ \\\n            'train_batch_size_per_card', 'test_batch_size_per_card']\n    elif mode == \"test\":\n        check_params = check_params + ['test_batch_size_per_card']\n    return check_params\ndef _check_image_file(path):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "get_image_file_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def get_image_file_list(img_file):\n    imgs_lists = []\n    if img_file is None or not os.path.exists(img_file):\n        raise Exception(\"not found any img file in {}\".format(img_file))\n    img_end = {'jpg', 'bmp', 'png', 'jpeg', 'rgb', 'tif', 'tiff', 'gif', 'pdf'}\n    if os.path.isfile(img_file) and _check_image_file(img_file):\n        imgs_lists.append(img_file)\n    elif os.path.isdir(img_file):\n        for single_file in os.listdir(img_file):\n            file_path = os.path.join(img_file, single_file)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "binarize_img",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def binarize_img(img):\n    if len(img.shape) == 3 and img.shape[2] == 3:\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # conversion to grayscale image\n        # use cv2 threshold binarization\n        _, gray = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n        img = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)\n    return img\ndef alpha_to_color(img, alpha_color=(255, 255, 255)):\n    if len(img.shape) == 3 and img.shape[2] == 4:\n        B, G, R, A = cv2.split(img)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "alpha_to_color",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def alpha_to_color(img, alpha_color=(255, 255, 255)):\n    if len(img.shape) == 3 and img.shape[2] == 4:\n        B, G, R, A = cv2.split(img)\n        alpha = A / 255\n        R = (alpha_color[0] * (1 - alpha) + R * alpha).astype(np.uint8)\n        G = (alpha_color[1] * (1 - alpha) + G * alpha).astype(np.uint8)\n        B = (alpha_color[2] * (1 - alpha) + B * alpha).astype(np.uint8)\n        img = cv2.merge((B, G, R))\n    return img\ndef check_and_read(img_path):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_and_read",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def check_and_read(img_path):\n    if os.path.basename(img_path)[-3:] in ['gif', 'GIF']:\n        gif = cv2.VideoCapture(img_path)\n        ret, frame = gif.read()\n        if not ret:\n            logger = logging.getLogger('ppocr')\n            logger.info(\"Cannot read {}. This gif image maybe corrupted.\")\n            return None, False\n        if len(frame.shape) == 2 or frame.shape[-1] == 1:\n            frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2RGB)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "load_vqa_bio_label_maps",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def load_vqa_bio_label_maps(label_map_path):\n    with open(label_map_path, \"r\", encoding='utf-8') as fin:\n        lines = fin.readlines()\n    old_lines = [line.strip() for line in lines]\n    lines = [\"O\"]\n    for line in old_lines:\n        # \"O\" has already been in lines\n        if line.upper() in [\"OTHER\", \"OTHERS\", \"IGNORE\"]:\n            continue\n        lines.append(line)",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "set_seed",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def set_seed(seed=1024):\n    random.seed(seed)\n    np.random.seed(seed)\n    paddle.seed(seed)\ndef check_install(module_name, install_name):\n    spec = importlib.util.find_spec(module_name)\n    if spec is None:\n        print(f'Warnning! The {module_name} module is NOT installed')\n        print(\n            f'Try install {module_name} module automatically. You can also try to install manually by pip install {install_name}.'",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "check_install",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "peekOfCode": "def check_install(module_name, install_name):\n    spec = importlib.util.find_spec(module_name)\n    if spec is None:\n        print(f'Warnning! The {module_name} module is NOT installed')\n        print(\n            f'Try install {module_name} module automatically. You can also try to install manually by pip install {install_name}.'\n        )\n        python = sys.executable\n        try:\n            subprocess.check_call(",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.utility",
        "documentation": {}
    },
    {
        "label": "draw_ser_results",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "peekOfCode": "def draw_ser_results(image,\n                     ocr_results,\n                     font_path=\"doc/fonts/simfang.ttf\",\n                     font_size=14):\n    np.random.seed(2021)\n    color = (np.random.permutation(range(255)),\n             np.random.permutation(range(255)),\n             np.random.permutation(range(255)))\n    color_map = {\n        idx: (color[0][idx], color[1][idx], color[2][idx])",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_box_txt",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "peekOfCode": "def draw_box_txt(bbox, text, draw, font, font_size, color):\n    # draw ocr results outline\n    bbox = ((bbox[0], bbox[1]), (bbox[2], bbox[3]))\n    draw.rectangle(bbox, fill=color)\n    # draw ocr results\n    left, top, right, bottom = font.getbbox(text)\n    tw, th = right - left, bottom - top\n    start_y = max(0, bbox[0][1] - th)\n    draw.rectangle(\n        [(bbox[0][0] + 1, start_y), (bbox[0][0] + tw + 1, start_y + th)],",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "trans_poly_to_bbox",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "peekOfCode": "def trans_poly_to_bbox(poly):\n    x1 = np.min([p[0] for p in poly])\n    x2 = np.max([p[0] for p in poly])\n    y1 = np.min([p[1] for p in poly])\n    y2 = np.max([p[1] for p in poly])\n    return [x1, y1, x2, y2]\ndef draw_re_results(image,\n                    result,\n                    font_path=\"doc/fonts/simfang.ttf\",\n                    font_size=18):",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_re_results",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "peekOfCode": "def draw_re_results(image,\n                    result,\n                    font_path=\"doc/fonts/simfang.ttf\",\n                    font_size=18):\n    np.random.seed(0)\n    if isinstance(image, np.ndarray):\n        image = Image.fromarray(image)\n    elif isinstance(image, str) and os.path.isfile(image):\n        image = Image.open(image).convert('RGB')\n    img_new = image.copy()",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "draw_rectangle",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "description": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "peekOfCode": "def draw_rectangle(img_path, boxes):\n    boxes = np.array(boxes)\n    img = cv2.imread(img_path)\n    img_show = img.copy()\n    for box in boxes.astype(int):\n        x1, y1, x2, y2 = box\n        cv2.rectangle(img_show, (x1, y1), (x2, y2), (255, 0, 0), 2)\n    return img_show",
        "detail": "Vision.Paddle.PaddleOCR.ppocr.utils.visual",
        "documentation": {}
    },
    {
        "label": "Worker",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "peekOfCode": "class Worker(QThread):\n    progressBarValue = pyqtSignal(int)\n    listValue = pyqtSignal(str)\n    endsignal = pyqtSignal(int, str)\n    handle = 0\n    def __init__(self, ocr, mImgList, mainThread, model):\n        super(Worker, self).__init__()\n        self.ocr = ocr\n        self.mImgList = mImgList\n        self.mainThread = mainThread",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "documentation": {}
    },
    {
        "label": "AutoDialog",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "peekOfCode": "class AutoDialog(QDialog):\n    def __init__(self, text=\"Enter object label\", parent=None, ocr=None, mImgList=None, lenbar=0):\n        super(AutoDialog, self).__init__(parent)\n        self.setFixedWidth(1000)\n        self.parent = parent\n        self.ocr = ocr\n        self.mImgList = mImgList\n        self.lender = lenbar\n        self.pb = QProgressBar()\n        self.pb.setRange(0, self.lender)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "documentation": {}
    },
    {
        "label": "BB",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "peekOfCode": "BB = QDialogButtonBox\nclass Worker(QThread):\n    progressBarValue = pyqtSignal(int)\n    listValue = pyqtSignal(str)\n    endsignal = pyqtSignal(int, str)\n    handle = 0\n    def __init__(self, ocr, mImgList, mainThread, model):\n        super(Worker, self).__init__()\n        self.ocr = ocr\n        self.mImgList = mImgList",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.autoDialog",
        "documentation": {}
    },
    {
        "label": "Canvas",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "peekOfCode": "class Canvas(QWidget):\n    zoomRequest = pyqtSignal(int)\n    scrollRequest = pyqtSignal(int, int)\n    newShape = pyqtSignal()\n    # selectionChanged = pyqtSignal(bool)\n    selectionChanged = pyqtSignal(list)\n    shapeMoved = pyqtSignal()\n    drawingPolygon = pyqtSignal(bool)\n    CREATE, EDIT = list(range(2))\n    _fill_drawing = False # draw shadows",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "documentation": {}
    },
    {
        "label": "CURSOR_DEFAULT",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "peekOfCode": "CURSOR_DEFAULT = Qt.ArrowCursor\nCURSOR_POINT = Qt.PointingHandCursor\nCURSOR_DRAW = Qt.CrossCursor\nCURSOR_MOVE = Qt.ClosedHandCursor\nCURSOR_GRAB = Qt.OpenHandCursor\nclass Canvas(QWidget):\n    zoomRequest = pyqtSignal(int)\n    scrollRequest = pyqtSignal(int, int)\n    newShape = pyqtSignal()\n    # selectionChanged = pyqtSignal(bool)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "documentation": {}
    },
    {
        "label": "CURSOR_POINT",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "peekOfCode": "CURSOR_POINT = Qt.PointingHandCursor\nCURSOR_DRAW = Qt.CrossCursor\nCURSOR_MOVE = Qt.ClosedHandCursor\nCURSOR_GRAB = Qt.OpenHandCursor\nclass Canvas(QWidget):\n    zoomRequest = pyqtSignal(int)\n    scrollRequest = pyqtSignal(int, int)\n    newShape = pyqtSignal()\n    # selectionChanged = pyqtSignal(bool)\n    selectionChanged = pyqtSignal(list)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "documentation": {}
    },
    {
        "label": "CURSOR_DRAW",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "peekOfCode": "CURSOR_DRAW = Qt.CrossCursor\nCURSOR_MOVE = Qt.ClosedHandCursor\nCURSOR_GRAB = Qt.OpenHandCursor\nclass Canvas(QWidget):\n    zoomRequest = pyqtSignal(int)\n    scrollRequest = pyqtSignal(int, int)\n    newShape = pyqtSignal()\n    # selectionChanged = pyqtSignal(bool)\n    selectionChanged = pyqtSignal(list)\n    shapeMoved = pyqtSignal()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "documentation": {}
    },
    {
        "label": "CURSOR_MOVE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "peekOfCode": "CURSOR_MOVE = Qt.ClosedHandCursor\nCURSOR_GRAB = Qt.OpenHandCursor\nclass Canvas(QWidget):\n    zoomRequest = pyqtSignal(int)\n    scrollRequest = pyqtSignal(int, int)\n    newShape = pyqtSignal()\n    # selectionChanged = pyqtSignal(bool)\n    selectionChanged = pyqtSignal(list)\n    shapeMoved = pyqtSignal()\n    drawingPolygon = pyqtSignal(bool)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "documentation": {}
    },
    {
        "label": "CURSOR_GRAB",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "peekOfCode": "CURSOR_GRAB = Qt.OpenHandCursor\nclass Canvas(QWidget):\n    zoomRequest = pyqtSignal(int)\n    scrollRequest = pyqtSignal(int, int)\n    newShape = pyqtSignal()\n    # selectionChanged = pyqtSignal(bool)\n    selectionChanged = pyqtSignal(list)\n    shapeMoved = pyqtSignal()\n    drawingPolygon = pyqtSignal(bool)\n    CREATE, EDIT = list(range(2))",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.canvas",
        "documentation": {}
    },
    {
        "label": "ColorDialog",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.colorDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.colorDialog",
        "peekOfCode": "class ColorDialog(QColorDialog):\n    def __init__(self, parent=None):\n        super(ColorDialog, self).__init__(parent)\n        self.setOption(QColorDialog.ShowAlphaChannel)\n        # The Mac native dialog does not support our restore button.\n        self.setOption(QColorDialog.DontUseNativeDialog)\n        # Add a restore defaults button.\n        # The default is set at invocation time, so that it\n        # works across dialogs for different elements.\n        self.default = None",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.colorDialog",
        "documentation": {}
    },
    {
        "label": "BB",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.colorDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.colorDialog",
        "peekOfCode": "BB = QDialogButtonBox\nclass ColorDialog(QColorDialog):\n    def __init__(self, parent=None):\n        super(ColorDialog, self).__init__(parent)\n        self.setOption(QColorDialog.ShowAlphaChannel)\n        # The Mac native dialog does not support our restore button.\n        self.setOption(QColorDialog.DontUseNativeDialog)\n        # Add a restore defaults button.\n        # The default is set at invocation time, so that it\n        # works across dialogs for different elements.",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.colorDialog",
        "documentation": {}
    },
    {
        "label": "SETTING_FILENAME",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_FILENAME = 'filename'\nSETTING_RECENT_FILES = 'recentFiles'\nSETTING_WIN_SIZE = 'window/size'\nSETTING_WIN_POSE = 'window/position'\nSETTING_WIN_GEOMETRY = 'window/geometry'\nSETTING_LINE_COLOR = 'line/color'\nSETTING_FILL_COLOR = 'fill/color'\nSETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_RECENT_FILES",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_RECENT_FILES = 'recentFiles'\nSETTING_WIN_SIZE = 'window/size'\nSETTING_WIN_POSE = 'window/position'\nSETTING_WIN_GEOMETRY = 'window/geometry'\nSETTING_LINE_COLOR = 'line/color'\nSETTING_FILL_COLOR = 'fill/color'\nSETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_WIN_SIZE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_WIN_SIZE = 'window/size'\nSETTING_WIN_POSE = 'window/position'\nSETTING_WIN_GEOMETRY = 'window/geometry'\nSETTING_LINE_COLOR = 'line/color'\nSETTING_FILL_COLOR = 'fill/color'\nSETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_WIN_POSE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_WIN_POSE = 'window/position'\nSETTING_WIN_GEOMETRY = 'window/geometry'\nSETTING_LINE_COLOR = 'line/color'\nSETTING_FILL_COLOR = 'fill/color'\nSETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_WIN_GEOMETRY",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_WIN_GEOMETRY = 'window/geometry'\nSETTING_LINE_COLOR = 'line/color'\nSETTING_FILL_COLOR = 'fill/color'\nSETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_LINE_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_LINE_COLOR = 'line/color'\nSETTING_FILL_COLOR = 'fill/color'\nSETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_FILL_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_FILL_COLOR = 'fill/color'\nSETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_ADVANCE_MODE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_ADVANCE_MODE = 'advanced'\nSETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_WIN_STATE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_WIN_STATE = 'window/state'\nSETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'\nSETTING_DRAW_SQUARE = 'draw/square'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_SAVE_DIR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_SAVE_DIR = 'savedir'\nSETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'\nSETTING_DRAW_SQUARE = 'draw/square'\nSETTING_LABEL_FILE_FORMAT= 'labelFileFormat'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_PAINT_LABEL",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_PAINT_LABEL = 'paintlabel'\nSETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'\nSETTING_DRAW_SQUARE = 'draw/square'\nSETTING_LABEL_FILE_FORMAT= 'labelFileFormat'\nDEFAULT_ENCODING = 'utf-8'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_PAINT_INDEX",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_PAINT_INDEX = 'paintindex'\nSETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'\nSETTING_DRAW_SQUARE = 'draw/square'\nSETTING_LABEL_FILE_FORMAT= 'labelFileFormat'\nDEFAULT_ENCODING = 'utf-8'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_LAST_OPEN_DIR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_LAST_OPEN_DIR = 'lastOpenDir'\nSETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'\nSETTING_DRAW_SQUARE = 'draw/square'\nSETTING_LABEL_FILE_FORMAT= 'labelFileFormat'\nDEFAULT_ENCODING = 'utf-8'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_AUTO_SAVE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_AUTO_SAVE = 'autosave'\nSETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'\nSETTING_DRAW_SQUARE = 'draw/square'\nSETTING_LABEL_FILE_FORMAT= 'labelFileFormat'\nDEFAULT_ENCODING = 'utf-8'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_SINGLE_CLASS",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_SINGLE_CLASS = 'singleclass'\nFORMAT_PASCALVOC='PascalVOC'\nFORMAT_YOLO='YOLO'\nSETTING_DRAW_SQUARE = 'draw/square'\nSETTING_LABEL_FILE_FORMAT= 'labelFileFormat'\nDEFAULT_ENCODING = 'utf-8'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "SETTING_DRAW_SQUARE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "SETTING_DRAW_SQUARE = 'draw/square'\nSETTING_LABEL_FILE_FORMAT= 'labelFileFormat'\nDEFAULT_ENCODING = 'utf-8'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENCODING",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "peekOfCode": "DEFAULT_ENCODING = 'utf-8'",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.constants",
        "documentation": {}
    },
    {
        "label": "CreateMLWriter",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "peekOfCode": "class CreateMLWriter:\n    def __init__(self, foldername, filename, imgsize, shapes, outputfile, databasesrc='Unknown', localimgpath=None):\n        self.foldername = foldername\n        self.filename = filename\n        self.databasesrc = databasesrc\n        self.imgsize = imgsize\n        self.boxlist = []\n        self.localimgpath = localimgpath\n        self.verified = False\n        self.shapes = shapes",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "documentation": {}
    },
    {
        "label": "CreateMLReader",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "peekOfCode": "class CreateMLReader:\n    def __init__(self, jsonpath, filepath):\n        self.jsonpath = jsonpath\n        self.shapes = []\n        self.verified = False\n        self.filename = filepath.split(\"/\")[-1:][0]\n        try:\n            self.parse_json()\n        except ValueError:\n            print(\"JSON decoding failed\")",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "documentation": {}
    },
    {
        "label": "JSON_EXT",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "peekOfCode": "JSON_EXT = '.json'\nENCODE_METHOD = DEFAULT_ENCODING\nclass CreateMLWriter:\n    def __init__(self, foldername, filename, imgsize, shapes, outputfile, databasesrc='Unknown', localimgpath=None):\n        self.foldername = foldername\n        self.filename = filename\n        self.databasesrc = databasesrc\n        self.imgsize = imgsize\n        self.boxlist = []\n        self.localimgpath = localimgpath",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "documentation": {}
    },
    {
        "label": "ENCODE_METHOD",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "peekOfCode": "ENCODE_METHOD = DEFAULT_ENCODING\nclass CreateMLWriter:\n    def __init__(self, foldername, filename, imgsize, shapes, outputfile, databasesrc='Unknown', localimgpath=None):\n        self.foldername = foldername\n        self.filename = filename\n        self.databasesrc = databasesrc\n        self.imgsize = imgsize\n        self.boxlist = []\n        self.localimgpath = localimgpath\n        self.verified = False",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.create_ml_io",
        "documentation": {}
    },
    {
        "label": "EditInList",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.editinlist",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.editinlist",
        "peekOfCode": "class EditInList(QListWidget):\n    def __init__(self):\n        super(EditInList, self).__init__()\n        self.edited_item = None\n    def item_clicked(self, modelindex: QModelIndex):\n        try:\n            if self.edited_item is not None:\n                self.closePersistentEditor(self.edited_item)\n        except:\n            self.edited_item = self.currentItem()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.editinlist",
        "documentation": {}
    },
    {
        "label": "HashableQListWidgetItem",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.hashableQListWidgetItem",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.hashableQListWidgetItem",
        "peekOfCode": "class HashableQListWidgetItem(QListWidgetItem):\n    def __init__(self, *args):\n        super(HashableQListWidgetItem, self).__init__(*args)\n    def __hash__(self):\n        return hash(id(self))",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.hashableQListWidgetItem",
        "documentation": {}
    },
    {
        "label": "KeyQLineEdit",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "peekOfCode": "class KeyQLineEdit(QtWidgets.QLineEdit):\n    def setListWidget(self, list_widget):\n        self.list_widget = list_widget\n    def keyPressEvent(self, e):\n        if e.key() in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Down]:\n            self.list_widget.keyPressEvent(e)\n        else:\n            super(KeyQLineEdit, self).keyPressEvent(e)\nclass KeyDialog(QtWidgets.QDialog):\n    def __init__(",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "documentation": {}
    },
    {
        "label": "KeyDialog",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "peekOfCode": "class KeyDialog(QtWidgets.QDialog):\n    def __init__(\n            self,\n            text=\"Enter object label\",\n            parent=None,\n            labels=None,\n            sort_labels=True,\n            show_text_field=True,\n            completion=\"startswith\",\n            fit_to_content=None,",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "documentation": {}
    },
    {
        "label": "QT5",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "peekOfCode": "QT5 = QT_VERSION_STR[0] == '5'\n# TODO(unknown):\n# - Calculate optimal position so as not to go out of screen area.\nclass KeyQLineEdit(QtWidgets.QLineEdit):\n    def setListWidget(self, list_widget):\n        self.list_widget = list_widget\n    def keyPressEvent(self, e):\n        if e.key() in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Down]:\n            self.list_widget.keyPressEvent(e)\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.keyDialog",
        "documentation": {}
    },
    {
        "label": "rgb2hsv",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "peekOfCode": "def rgb2hsv(rgb):\n    # type: (np.ndarray) -> np.ndarray\n    \"\"\"Convert rgb to hsv.\n    Parameters\n    ----------\n    rgb: numpy.ndarray, (H, W, 3), np.uint8\n        Input rgb image.\n    Returns\n    -------\n    hsv: numpy.ndarray, (H, W, 3), np.uint8",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "documentation": {}
    },
    {
        "label": "hsv2rgb",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "peekOfCode": "def hsv2rgb(hsv):\n    # type: (np.ndarray) -> np.ndarray\n    \"\"\"Convert hsv to rgb.\n    Parameters\n    ----------\n    hsv: numpy.ndarray, (H, W, 3), np.uint8\n        Input hsv image.\n    Returns\n    -------\n    rgb: numpy.ndarray, (H, W, 3), np.uint8",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "documentation": {}
    },
    {
        "label": "label_colormap",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "peekOfCode": "def label_colormap(n_label=256, value=None):\n    \"\"\"Label colormap.\n    Parameters\n    ----------\n    n_label: int\n        Number of labels (default: 256).\n    value: float or int\n        Value scale or value of label color in HSV space.\n    Returns\n    -------",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelColor",
        "documentation": {}
    },
    {
        "label": "LabelDialog",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelDialog",
        "peekOfCode": "class LabelDialog(QDialog):\n    def __init__(self, text=\"Enter object label\", parent=None, listItem=None):\n        super(LabelDialog, self).__init__(parent)\n        self.edit = QLineEdit()  # OLD\n        # self.edit = QTextEdit()\n        self.edit.setText(text)\n        # self.edit.setValidator(labelValidator()) # 验证有效性\n        self.edit.editingFinished.connect(self.postProcess)\n        model = QStringListModel()\n        model.setStringList(listItem)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelDialog",
        "documentation": {}
    },
    {
        "label": "BB",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelDialog",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelDialog",
        "peekOfCode": "BB = QDialogButtonBox\nclass LabelDialog(QDialog):\n    def __init__(self, text=\"Enter object label\", parent=None, listItem=None):\n        super(LabelDialog, self).__init__(parent)\n        self.edit = QLineEdit()  # OLD\n        # self.edit = QTextEdit()\n        self.edit.setText(text)\n        # self.edit.setValidator(labelValidator()) # 验证有效性\n        self.edit.editingFinished.connect(self.postProcess)\n        model = QStringListModel()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.labelDialog",
        "documentation": {}
    },
    {
        "label": "qInitResources",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "peekOfCode": "def qInitResources():\n    QtCore.qRegisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\ndef qCleanupResources():\n    QtCore.qUnregisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\nqInitResources()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "documentation": {}
    },
    {
        "label": "qCleanupResources",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "peekOfCode": "def qCleanupResources():\n    QtCore.qUnregisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\nqInitResources()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "documentation": {}
    },
    {
        "label": "qt_resource_data",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "peekOfCode": "qt_resource_data = b\"\\\n\\x00\\x00\\x08\\x19\\\n\\x89\\\n\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0d\\x49\\x48\\x44\\x52\\x00\\\n\\x00\\x00\\x20\\x00\\x00\\x00\\x20\\x08\\x06\\x00\\x00\\x00\\x73\\x7a\\x7a\\xf4\\\n\\x00\\x00\\x00\\x04\\x67\\x41\\x4d\\x41\\x00\\x00\\xd6\\xd8\\xd4\\x4f\\x58\\x32\\\n\\x00\\x00\\x00\\x19\\x74\\x45\\x58\\x74\\x53\\x6f\\x66\\x74\\x77\\x61\\x72\\x65\\\n\\x00\\x41\\x64\\x6f\\x62\\x65\\x20\\x49\\x6d\\x61\\x67\\x65\\x52\\x65\\x61\\x64\\\n\\x79\\x71\\xc9\\x65\\x3c\\x00\\x00\\x07\\xab\\x49\\x44\\x41\\x54\\x58\\xc3\\xad\\\n\\x57\\x5b\\x50\\x93\\x67\\x1a\\xf6\\xca\\xce\\xec\\xcc\\xf6\\x62\\x2f\\xbc\\xd9\\",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "documentation": {}
    },
    {
        "label": "qt_resource_name",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "peekOfCode": "qt_resource_name = b\"\\\n\\x00\\x04\\\n\\x00\\x07\\x66\\xbe\\\n\\x00\\x6f\\\n\\x00\\x70\\x00\\x65\\x00\\x6e\\\n\\x00\\x0d\\\n\\x03\\x22\\xb9\\x5e\\\n\\x00\\x73\\\n\\x00\\x74\\x00\\x72\\x00\\x69\\x00\\x6e\\x00\\x67\\x00\\x73\\x00\\x2d\\x00\\x7a\\x00\\x68\\x00\\x2d\\x00\\x43\\x00\\x4e\\\n\\x00\\x05\\",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "documentation": {}
    },
    {
        "label": "qt_resource_struct_v1",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "peekOfCode": "qt_resource_struct_v1 = b\"\\\n\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x24\\x00\\x00\\x00\\x01\\\n\\x00\\x00\\x01\\xb0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x12\\x96\\\n\\x00\\x00\\x01\\x54\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x79\\xa3\\\n\\x00\\x00\\x01\\x2a\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x70\\x4a\\\n\\x00\\x00\\x01\\x38\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x72\\x25\\\n\\x00\\x00\\x00\\xba\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x43\\x1b\\\n\\x00\\x00\\x02\\x2c\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x02\\x27\\xee\\\n\\x00\\x00\\x01\\xfe\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x02\\x14\\x91\\\n\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x5b\\x41\\",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "documentation": {}
    },
    {
        "label": "qt_resource_struct_v2",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "peekOfCode": "qt_resource_struct_v2 = b\"\\\n\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x24\\x00\\x00\\x00\\x01\\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\n\\x00\\x00\\x01\\xb0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x12\\x96\\\n\\x00\\x00\\x01\\x7a\\x50\\x6d\\xd4\\x88\\\n\\x00\\x00\\x01\\x54\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x79\\xa3\\\n\\x00\\x00\\x01\\x7a\\x50\\x6d\\xd4\\x88\\\n\\x00\\x00\\x01\\x2a\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x70\\x4a\\\n\\x00\\x00\\x01\\x7a\\x50\\x6d\\xd4\\x88\\\n\\x00\\x00\\x01\\x38\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x72\\x25\\",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "documentation": {}
    },
    {
        "label": "qt_version",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "peekOfCode": "qt_version = [int(v) for v in QtCore.qVersion().split('.')]\nif qt_version < [5, 8, 0]:\n    rcc_version = 1\n    qt_resource_struct = qt_resource_struct_v1\nelse:\n    rcc_version = 2\n    qt_resource_struct = qt_resource_struct_v2\ndef qInitResources():\n    QtCore.qRegisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)\ndef qCleanupResources():",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.resources",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.settings",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.settings",
        "peekOfCode": "class Settings(object):\n    def __init__(self):\n        # Be default, the home will be in the same folder as labelImg\n        home = os.path.expanduser(\"~\")\n        self.data = {}\n        # self.path = os.path.join(home, '.labelImgSettings.pkl')\n        self.path = os.path.join(home, '.autoOCRSettings.pkl')\n    def __setitem__(self, key, value):\n        self.data[key] = value\n    def __getitem__(self, key):",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.settings",
        "documentation": {}
    },
    {
        "label": "Shape",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "class Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)\n    # The following class variables influence the drawing\n    # of _all_ shape objects.\n    line_color = DEFAULT_LINE_COLOR\n    fill_color = DEFAULT_FILL_COLOR\n    select_line_color = DEFAULT_SELECT_LINE_COLOR\n    select_fill_color = DEFAULT_SELECT_FILL_COLOR\n    vertex_fill_color = DEFAULT_VERTEX_FILL_COLOR",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LINE_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "DEFAULT_LINE_COLOR = QColor(0, 255, 0, 128)\nDEFAULT_FILL_COLOR = QColor(255, 0, 0, 128)\nDEFAULT_SELECT_LINE_COLOR = QColor(255, 255, 255)\nDEFAULT_SELECT_FILL_COLOR = QColor(0, 128, 255, 155)\nDEFAULT_VERTEX_FILL_COLOR = QColor(0, 255, 0, 255)\nDEFAULT_HVERTEX_FILL_COLOR = QColor(255, 0, 0)\nDEFAULT_LOCK_COLOR = QColor(255, 0, 255)\nMIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FILL_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "DEFAULT_FILL_COLOR = QColor(255, 0, 0, 128)\nDEFAULT_SELECT_LINE_COLOR = QColor(255, 255, 255)\nDEFAULT_SELECT_FILL_COLOR = QColor(0, 128, 255, 155)\nDEFAULT_VERTEX_FILL_COLOR = QColor(0, 255, 0, 255)\nDEFAULT_HVERTEX_FILL_COLOR = QColor(255, 0, 0)\nDEFAULT_LOCK_COLOR = QColor(255, 0, 255)\nMIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SELECT_LINE_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "DEFAULT_SELECT_LINE_COLOR = QColor(255, 255, 255)\nDEFAULT_SELECT_FILL_COLOR = QColor(0, 128, 255, 155)\nDEFAULT_VERTEX_FILL_COLOR = QColor(0, 255, 0, 255)\nDEFAULT_HVERTEX_FILL_COLOR = QColor(255, 0, 0)\nDEFAULT_LOCK_COLOR = QColor(255, 0, 255)\nMIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)\n    # The following class variables influence the drawing",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SELECT_FILL_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "DEFAULT_SELECT_FILL_COLOR = QColor(0, 128, 255, 155)\nDEFAULT_VERTEX_FILL_COLOR = QColor(0, 255, 0, 255)\nDEFAULT_HVERTEX_FILL_COLOR = QColor(255, 0, 0)\nDEFAULT_LOCK_COLOR = QColor(255, 0, 255)\nMIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)\n    # The following class variables influence the drawing\n    # of _all_ shape objects.",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_VERTEX_FILL_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "DEFAULT_VERTEX_FILL_COLOR = QColor(0, 255, 0, 255)\nDEFAULT_HVERTEX_FILL_COLOR = QColor(255, 0, 0)\nDEFAULT_LOCK_COLOR = QColor(255, 0, 255)\nMIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)\n    # The following class variables influence the drawing\n    # of _all_ shape objects.\n    line_color = DEFAULT_LINE_COLOR",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_HVERTEX_FILL_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "DEFAULT_HVERTEX_FILL_COLOR = QColor(255, 0, 0)\nDEFAULT_LOCK_COLOR = QColor(255, 0, 255)\nMIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)\n    # The following class variables influence the drawing\n    # of _all_ shape objects.\n    line_color = DEFAULT_LINE_COLOR\n    fill_color = DEFAULT_FILL_COLOR",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOCK_COLOR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "DEFAULT_LOCK_COLOR = QColor(255, 0, 255)\nMIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)\n    # The following class variables influence the drawing\n    # of _all_ shape objects.\n    line_color = DEFAULT_LINE_COLOR\n    fill_color = DEFAULT_FILL_COLOR\n    select_line_color = DEFAULT_SELECT_LINE_COLOR",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "MIN_Y_LABEL",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "peekOfCode": "MIN_Y_LABEL = 10\nclass Shape(object):\n    P_SQUARE, P_ROUND = range(2)\n    MOVE_VERTEX, NEAR_VERTEX = range(2)\n    # The following class variables influence the drawing\n    # of _all_ shape objects.\n    line_color = DEFAULT_LINE_COLOR\n    fill_color = DEFAULT_FILL_COLOR\n    select_line_color = DEFAULT_SELECT_LINE_COLOR\n    select_fill_color = DEFAULT_SELECT_FILL_COLOR",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.shape",
        "documentation": {}
    },
    {
        "label": "StringBundle",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "peekOfCode": "class StringBundle:\n    __create_key = object()\n    def __init__(self, create_key, localeStr):\n        assert(create_key == StringBundle.__create_key), \"StringBundle must be created using StringBundle.getBundle\"\n        self.idToMessage = {}\n        paths = self.__createLookupFallbackList(localeStr)\n        for path in paths:\n            self.__loadBundle(path)\n    @classmethod\n    def getBundle(cls, localeStr=None):",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__)) # 获取本程序文件路径\n__dirpath__ = os.path.abspath(os.path.join(__dir__, '../resources/strings'))\ntry:\n    from PyQt5.QtCore import *\nexcept ImportError:\n    if sys.version_info.major >= 3:\n        import sip\n        sip.setapi('QVariant', 2)\n    from PyQt4.QtCore import *\nclass StringBundle:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "documentation": {}
    },
    {
        "label": "__dirpath__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "peekOfCode": "__dirpath__ = os.path.abspath(os.path.join(__dir__, '../resources/strings'))\ntry:\n    from PyQt5.QtCore import *\nexcept ImportError:\n    if sys.version_info.major >= 3:\n        import sip\n        sip.setapi('QVariant', 2)\n    from PyQt4.QtCore import *\nclass StringBundle:\n    __create_key = object()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.stringBundle",
        "documentation": {}
    },
    {
        "label": "ToolBar",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.toolBar",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.toolBar",
        "peekOfCode": "class ToolBar(QToolBar):\n    def __init__(self, title):\n        super(ToolBar, self).__init__(title)\n        layout = self.layout()\n        m = (0, 0, 0, 0)\n        layout.setSpacing(0)\n        layout.setContentsMargins(*m)\n        self.setContentsMargins(*m)\n        self.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)\n    def addAction(self, action):",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.toolBar",
        "documentation": {}
    },
    {
        "label": "ToolButton",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.toolBar",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.toolBar",
        "peekOfCode": "class ToolButton(QToolButton):\n    \"\"\"ToolBar companion class which ensures all buttons have the same size.\"\"\"\n    minSize = (60, 60)\n    def minimumSizeHint(self):\n        ms = super(ToolButton, self).minimumSizeHint()\n        w1, h1 = ms.width(), ms.height()\n        w2, h2 = self.minSize\n        ToolButton.minSize = max(w1, w2), max(h1, h2)\n        return QSize(*ToolButton.minSize)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.toolBar",
        "documentation": {}
    },
    {
        "label": "EscapableQListWidget",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.unique_label_qlist_widget",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.unique_label_qlist_widget",
        "peekOfCode": "class EscapableQListWidget(QtWidgets.QListWidget):\n    def keyPressEvent(self, event):\n        super(EscapableQListWidget, self).keyPressEvent(event)\n        if event.key() == Qt.Key_Escape:\n            self.clearSelection()\nclass UniqueLabelQListWidget(EscapableQListWidget):\n    def mousePressEvent(self, event):\n        super(UniqueLabelQListWidget, self).mousePressEvent(event)\n        if not self.indexAt(event.pos()).isValid():\n            self.clearSelection()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.unique_label_qlist_widget",
        "documentation": {}
    },
    {
        "label": "UniqueLabelQListWidget",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.unique_label_qlist_widget",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.unique_label_qlist_widget",
        "peekOfCode": "class UniqueLabelQListWidget(EscapableQListWidget):\n    def mousePressEvent(self, event):\n        super(UniqueLabelQListWidget, self).mousePressEvent(event)\n        if not self.indexAt(event.pos()).isValid():\n            self.clearSelection()\n    def findItemsByLabel(self, label, get_row=False):\n        items = []\n        for row in range(self.count()):\n            item = self.item(row)\n            if item.data(Qt.UserRole) == label:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.unique_label_qlist_widget",
        "documentation": {}
    },
    {
        "label": "ustr",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.ustr",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.ustr",
        "peekOfCode": "def ustr(x):\n    '''py2/py3 unicode helper'''\n    if sys.version_info < (3, 0, 0):\n        from PyQt4.QtCore import QString\n        if type(x) == str:\n            return x.decode(DEFAULT_ENCODING)\n        if type(x) == QString:\n            #https://blog.csdn.net/friendan/article/details/51088476\n            #https://blog.csdn.net/xxm524/article/details/74937308\n            return unicode(x.toUtf8(), DEFAULT_ENCODING, 'ignore')",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.ustr",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "class struct(object):\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\ndef distance(p):\n    return sqrt(p.x() * p.x() + p.y() * p.y())\ndef fmtShortcut(text):\n    mod, key = text.split('+', 1)\n    return '<b>%s</b>+<b>%s</b>' % (mod, key)\ndef generateColorByText(text):\n    s = ustr(text)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "newIcon",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def newIcon(icon, iconSize=None):\n    if iconSize is not None:\n        return QIcon(QIcon(__iconpath__ + \"/\" + icon + \".png\").pixmap(iconSize, iconSize))\n    else:\n        return QIcon(__iconpath__ + \"/\" + icon + \".png\")\ndef newButton(text, icon=None, slot=None):\n    b = QPushButton(text)\n    if icon is not None:\n        b.setIcon(newIcon(icon))\n    if slot is not None:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "newButton",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def newButton(text, icon=None, slot=None):\n    b = QPushButton(text)\n    if icon is not None:\n        b.setIcon(newIcon(icon))\n    if slot is not None:\n        b.clicked.connect(slot)\n    return b\ndef newAction(parent, text, slot=None, shortcut=None, icon=None,\n              tip=None, checkable=False, enabled=True, iconSize=None):\n    \"\"\"Create a new action and assign callbacks, shortcuts, etc.\"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "newAction",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def newAction(parent, text, slot=None, shortcut=None, icon=None,\n              tip=None, checkable=False, enabled=True, iconSize=None):\n    \"\"\"Create a new action and assign callbacks, shortcuts, etc.\"\"\"\n    a = QAction(text, parent)\n    if icon is not None:\n        if iconSize is not None:\n            a.setIcon(newIcon(icon, iconSize))\n        else:\n            a.setIcon(newIcon(icon))\n    if shortcut is not None:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "addActions",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def addActions(widget, actions):\n    for action in actions:\n        if action is None:\n            widget.addSeparator()\n        elif isinstance(action, QMenu):\n            widget.addMenu(action)\n        else:\n            widget.addAction(action)\ndef labelValidator():\n    return QRegExpValidator(QRegExp(r'^[^ \\t].+'), None)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "labelValidator",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def labelValidator():\n    return QRegExpValidator(QRegExp(r'^[^ \\t].+'), None)\nclass struct(object):\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\ndef distance(p):\n    return sqrt(p.x() * p.x() + p.y() * p.y())\ndef fmtShortcut(text):\n    mod, key = text.split('+', 1)\n    return '<b>%s</b>+<b>%s</b>' % (mod, key)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def distance(p):\n    return sqrt(p.x() * p.x() + p.y() * p.y())\ndef fmtShortcut(text):\n    mod, key = text.split('+', 1)\n    return '<b>%s</b>+<b>%s</b>' % (mod, key)\ndef generateColorByText(text):\n    s = ustr(text)\n    hashCode = int(hashlib.sha256(s.encode('utf-8')).hexdigest(), 16)\n    r = int((hashCode / 255) % 255)\n    g = int((hashCode / 65025) % 255)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "fmtShortcut",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def fmtShortcut(text):\n    mod, key = text.split('+', 1)\n    return '<b>%s</b>+<b>%s</b>' % (mod, key)\ndef generateColorByText(text):\n    s = ustr(text)\n    hashCode = int(hashlib.sha256(s.encode('utf-8')).hexdigest(), 16)\n    r = int((hashCode / 255) % 255)\n    g = int((hashCode / 65025) % 255)\n    b = int((hashCode / 16581375) % 255)\n    return QColor(r, g, b, 100)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "generateColorByText",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def generateColorByText(text):\n    s = ustr(text)\n    hashCode = int(hashlib.sha256(s.encode('utf-8')).hexdigest(), 16)\n    r = int((hashCode / 255) % 255)\n    g = int((hashCode / 65025) % 255)\n    b = int((hashCode / 16581375) % 255)\n    return QColor(r, g, b, 100)\ndef have_qstring():\n    '''p3/qt5 get rid of QString wrapper as py3 has native unicode str type'''\n    return not (sys.version_info.major >= 3 or QT_VERSION_STR.startswith('5.'))",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "have_qstring",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def have_qstring():\n    '''p3/qt5 get rid of QString wrapper as py3 has native unicode str type'''\n    return not (sys.version_info.major >= 3 or QT_VERSION_STR.startswith('5.'))\ndef natural_sort(list, key=lambda s: s):\n    \"\"\"\n    Sort the list into natural alphanumeric order.\n    \"\"\"\n    def get_alphanum_key_func(key):\n        convert = lambda text: int(text) if text.isdigit() else text\n        return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))]",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "natural_sort",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def natural_sort(list, key=lambda s: s):\n    \"\"\"\n    Sort the list into natural alphanumeric order.\n    \"\"\"\n    def get_alphanum_key_func(key):\n        convert = lambda text: int(text) if text.isdigit() else text\n        return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))]\n    sort_key = get_alphanum_key_func(key)\n    list.sort(key=sort_key)\ndef get_rotate_crop_image(img, points):",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "get_rotate_crop_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def get_rotate_crop_image(img, points):\n    # Use Green's theory to judge clockwise or counterclockwise\n    # author: biyanhua\n    d = 0.0\n    for index in range(-1, 3):\n        d += -0.5 * (points[index + 1][1] + points[index][1]) * (\n                points[index + 1][0] - points[index][0])\n    if d < 0:  # counterclockwise\n        tmp = np.array(points)\n        points[1], points[3] = tmp[3], tmp[1]",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "boxPad",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def boxPad(box, imgShape, pad : int) -> np.array:\n    \"\"\"\n    Pad a box with [pad] pixels on each side.\n    \"\"\"\n    box = np.array(box, dtype=np.int32)\n    box[0][0], box[0][1] = box[0][0] - pad, box[0][1] - pad\n    box[1][0], box[1][1] = box[1][0] + pad, box[1][1] - pad\n    box[2][0], box[2][1] = box[2][0] + pad, box[2][1] + pad\n    box[3][0], box[3][1] = box[3][0] - pad, box[3][1] + pad\n    h, w, _ = imgShape",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "expand_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def expand_list(merged, html_list):\n    '''\n    Fill blanks according to merged cells\n    '''\n    sr, er, sc, ec = merged\n    for i in range(sr, er):\n        for j in range(sc, ec):\n            html_list[i][j] = None\n    html_list[sr][sc] = ''\n    if ec - sc > 1:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "convert_token",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def convert_token(html_list):\n    '''\n    Convert raw html to label format\n    '''\n    token_list = [\"<tbody>\"]\n    # final html list:\n    for row in html_list:\n        token_list.append(\"<tr>\")\n        for col in row:\n            if col == None:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "rebuild_html_from_ppstructure_label",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def rebuild_html_from_ppstructure_label(label_info):\n        from html import escape\n        html_code = label_info['html']['structure']['tokens'].copy()\n        to_insert = [\n            i for i, tag in enumerate(html_code) if tag in ('<td>', '>')\n        ]\n        for i, cell in zip(to_insert[::-1], label_info['html']['cells'][::-1]):\n            if cell['tokens']:\n                cell = [\n                    escape(token) if len(token) == 1 else token",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "stepsInfo",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def stepsInfo(lang='en'):\n    if lang == 'ch':\n        msg = \"1. 安装与运行：使用上述命令安装与运行程序。\\n\" \\\n              \"2. 打开文件夹：在菜单栏点击 “文件” - 打开目录 选择待标记图片的文件夹.\\n\" \\\n              \"3. 自动标注：点击 ”自动标注“，使用PPOCR超轻量模型对图片文件名前图片状态为 “X” 的图片进行自动标注。\\n\" \\\n              \"4. 手动标注：点击 “矩形标注”（推荐直接在英文模式下点击键盘中的 “W”)，用户可对当前图片中模型未检出的部分进行手动\" \\\n              \"绘制标记框。点击键盘P，则使用四点标注模式（或点击“编辑” - “四点标注”），用户依次点击4个点后，双击左键表示标注完成。\\n\" \\\n              \"5. 标记框绘制完成后，用户点击 “确认”，检测框会先被预分配一个 “待识别” 标签。\\n\" \\\n              \"6. 重新识别：将图片中的所有检测画绘制/调整完成后，点击 “重新识别”，PPOCR模型会对当前图片中的**所有检测框**重新识别。\\n\" \\\n              \"7. 内容更改：双击识别结果，对不准确的识别结果进行手动更改。\\n\" \\",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "keysInfo",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "def keysInfo(lang='en'):\n    if lang == 'ch':\n        msg = \"快捷键\\t\\t\\t说明\\n\" \\\n              \"———————————————————————\\n\" \\\n              \"Ctrl + shift + R\\t\\t对当前图片的所有标记重新识别\\n\" \\\n              \"W\\t\\t\\t新建矩形框\\n\" \\\n              \"Q\\t\\t\\t新建四点框\\n\" \\\n              \"Ctrl + E\\t\\t编辑所选框标签\\n\" \\\n              \"Ctrl + R\\t\\t重新识别所选标记\\n\" \\\n              \"Ctrl + C\\t\\t复制并粘贴选中的标记框\\n\" \\",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))  # 获取本程序文件路径\n__iconpath__ = os.path.abspath(os.path.join(__dir__, '../resources/icons'))\ndef newIcon(icon, iconSize=None):\n    if iconSize is not None:\n        return QIcon(QIcon(__iconpath__ + \"/\" + icon + \".png\").pixmap(iconSize, iconSize))\n    else:\n        return QIcon(__iconpath__ + \"/\" + icon + \".png\")\ndef newButton(text, icon=None, slot=None):\n    b = QPushButton(text)\n    if icon is not None:",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "__iconpath__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "peekOfCode": "__iconpath__ = os.path.abspath(os.path.join(__dir__, '../resources/icons'))\ndef newIcon(icon, iconSize=None):\n    if iconSize is not None:\n        return QIcon(QIcon(__iconpath__ + \"/\" + icon + \".png\").pixmap(iconSize, iconSize))\n    else:\n        return QIcon(__iconpath__ + \"/\" + icon + \".png\")\ndef newButton(text, icon=None, slot=None):\n    b = QPushButton(text)\n    if icon is not None:\n        b.setIcon(newIcon(icon))",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.utils",
        "documentation": {}
    },
    {
        "label": "ZoomWidget",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.zoomWidget",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.zoomWidget",
        "peekOfCode": "class ZoomWidget(QSpinBox):\n    def __init__(self, value=100):\n        super(ZoomWidget, self).__init__()\n        self.setButtonSymbols(QAbstractSpinBox.NoButtons)\n        self.setRange(1, 500)\n        self.setSuffix(' %')\n        self.setValue(value)\n        self.setToolTip(u'Zoom Level')\n        self.setStatusTip(self.toolTip())\n        self.setAlignment(Qt.AlignCenter)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.libs.zoomWidget",
        "documentation": {}
    },
    {
        "label": "isCreateOrDeleteFolder",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "peekOfCode": "def isCreateOrDeleteFolder(path, flag):\n    flagPath = os.path.join(path, flag)\n    if os.path.exists(flagPath):\n        shutil.rmtree(flagPath)\n    os.makedirs(flagPath)\n    flagAbsPath = os.path.abspath(flagPath)\n    return flagAbsPath\ndef splitTrainVal(root, absTrainRootPath, absValRootPath, absTestRootPath, trainTxt, valTxt, testTxt, flag):\n    # 按照指定的比例划分训练集、验证集、测试集\n    dataAbsPath = os.path.abspath(root)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "documentation": {}
    },
    {
        "label": "splitTrainVal",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "peekOfCode": "def splitTrainVal(root, absTrainRootPath, absValRootPath, absTestRootPath, trainTxt, valTxt, testTxt, flag):\n    # 按照指定的比例划分训练集、验证集、测试集\n    dataAbsPath = os.path.abspath(root)\n    if flag == \"det\":\n        labelFilePath = os.path.join(dataAbsPath, args.detLabelFileName)\n    elif flag == \"rec\":\n        labelFilePath = os.path.join(dataAbsPath, args.recLabelFileName)\n    labelFileRead = open(labelFilePath, \"r\", encoding=\"UTF-8\")\n    labelFileContent = labelFileRead.readlines()\n    random.shuffle(labelFileContent)",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "documentation": {}
    },
    {
        "label": "removeFile",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "peekOfCode": "def removeFile(path):\n    if os.path.exists(path):\n        os.remove(path)\ndef genDetRecTrainVal(args):\n    detAbsTrainRootPath = isCreateOrDeleteFolder(args.detRootPath, \"train\")\n    detAbsValRootPath = isCreateOrDeleteFolder(args.detRootPath, \"val\")\n    detAbsTestRootPath = isCreateOrDeleteFolder(args.detRootPath, \"test\")\n    recAbsTrainRootPath = isCreateOrDeleteFolder(args.recRootPath, \"train\")\n    recAbsValRootPath = isCreateOrDeleteFolder(args.recRootPath, \"val\")\n    recAbsTestRootPath = isCreateOrDeleteFolder(args.recRootPath, \"test\")",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "documentation": {}
    },
    {
        "label": "genDetRecTrainVal",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "peekOfCode": "def genDetRecTrainVal(args):\n    detAbsTrainRootPath = isCreateOrDeleteFolder(args.detRootPath, \"train\")\n    detAbsValRootPath = isCreateOrDeleteFolder(args.detRootPath, \"val\")\n    detAbsTestRootPath = isCreateOrDeleteFolder(args.detRootPath, \"test\")\n    recAbsTrainRootPath = isCreateOrDeleteFolder(args.recRootPath, \"train\")\n    recAbsValRootPath = isCreateOrDeleteFolder(args.recRootPath, \"val\")\n    recAbsTestRootPath = isCreateOrDeleteFolder(args.recRootPath, \"test\")\n    removeFile(os.path.join(args.detRootPath, \"train.txt\"))\n    removeFile(os.path.join(args.detRootPath, \"val.txt\"))\n    removeFile(os.path.join(args.detRootPath, \"test.txt\"))",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.gen_ocr_train_val_test",
        "documentation": {}
    },
    {
        "label": "MainWindow",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "class MainWindow(QMainWindow):\n    FIT_WINDOW, FIT_WIDTH, MANUAL_ZOOM = list(range(3))\n    def __init__(self,\n                 lang=\"ch\",\n                 gpu=False,\n                 kie_mode=False,\n                 default_filename=None,\n                 default_predefined_class_file=None,\n                 default_save_dir=None):\n        super(MainWindow, self).__init__()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "inverted",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "def inverted(color):\n    return QColor(*[255 - v for v in color.getRgb()])\ndef read(filename, default=None):\n    try:\n        with open(filename, 'rb') as f:\n            return f.read()\n    except:\n        return default\ndef str2bool(v):\n    return v.lower() in (\"true\", \"t\", \"1\")",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "def read(filename, default=None):\n    try:\n        with open(filename, 'rb') as f:\n            return f.read()\n    except:\n        return default\ndef str2bool(v):\n    return v.lower() in (\"true\", \"t\", \"1\")\ndef get_main_app(argv=[]):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "def str2bool(v):\n    return v.lower() in (\"true\", \"t\", \"1\")\ndef get_main_app(argv=[]):\n    \"\"\"\n    Standard boilerplate Qt application code.\n    Do everything but app.exec_() -- so that we can test the application in one thread\n    \"\"\"\n    app = QApplication(argv)\n    app.setApplicationName(__appname__)\n    app.setWindowIcon(newIcon(\"app\"))",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "get_main_app",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "def get_main_app(argv=[]):\n    \"\"\"\n    Standard boilerplate Qt application code.\n    Do everything but app.exec_() -- so that we can test the application in one thread\n    \"\"\"\n    app = QApplication(argv)\n    app.setApplicationName(__appname__)\n    app.setWindowIcon(newIcon(\"app\"))\n    # Tzutalin 201705+: Accept extra arguments to change predefined class file\n    arg_parser = argparse.ArgumentParser()",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "def main():\n    \"\"\"construct main app and run it\"\"\"\n    app, _win = get_main_app(sys.argv)\n    return app.exec_()\nif __name__ == '__main__':\n    resource_file = './libs/resources.py'\n    if not os.path.exists(resource_file):\n        output = os.system('pyrcc5 -o libs/resources.py resources.qrc')\n        assert output == 0, \"operate the cmd have some problems ,please check  whether there is a in the lib \" \\\n                            \"directory resources.py \"",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.append(os.path.abspath(os.path.join(__dir__, '../..')))\nsys.path.append(os.path.abspath(os.path.join(__dir__, '../PaddleOCR')))\nsys.path.append(\"..\")\nfrom paddleocr import PaddleOCR, PPStructure\nfrom libs.constants import *\nfrom libs.utils import *\nfrom libs.labelColor import label_colormap\nfrom libs.settings import Settings",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "__appname__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "__appname__ = 'PPOCRLabel'\nLABEL_COLORMAP = label_colormap()\nclass MainWindow(QMainWindow):\n    FIT_WINDOW, FIT_WIDTH, MANUAL_ZOOM = list(range(3))\n    def __init__(self,\n                 lang=\"ch\",\n                 gpu=False,\n                 kie_mode=False,\n                 default_filename=None,\n                 default_predefined_class_file=None,",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "LABEL_COLORMAP",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "peekOfCode": "LABEL_COLORMAP = label_colormap()\nclass MainWindow(QMainWindow):\n    FIT_WINDOW, FIT_WIDTH, MANUAL_ZOOM = list(range(3))\n    def __init__(self,\n                 lang=\"ch\",\n                 gpu=False,\n                 kie_mode=False,\n                 default_filename=None,\n                 default_predefined_class_file=None,\n                 default_save_dir=None):",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.PPOCRLabel",
        "documentation": {}
    },
    {
        "label": "readme",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.PPOCRLabel.setup",
        "description": "Vision.Paddle.PaddleOCR.PPOCRLabel.setup",
        "peekOfCode": "def readme():\n    with open('README.md', encoding=\"utf-8-sig\") as f:\n        README = f.read()\n    return README\nsetup(\n    name='PPOCRLabel',\n    packages=['PPOCRLabel'],\n    package_data = {'PPOCRLabel': ['libs/*','resources/strings/*','resources/icons/*']},\n    package_dir={'PPOCRLabel': ''},\n    include_package_data=True,",
        "detail": "Vision.Paddle.PaddleOCR.PPOCRLabel.setup",
        "documentation": {}
    },
    {
        "label": "parse_ser_results_fp",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "peekOfCode": "def parse_ser_results_fp(fp, fp_type=\"gt\", ignore_background=True):\n    # img/zh_val_0.jpg        {\n    #     \"height\": 3508,\n    #     \"width\": 2480,\n    #     \"ocr_info\": [\n    #         {\"text\": \"Maribyrnong\", \"label\": \"other\", \"bbox\": [1958, 144, 2184, 198]},\n    #         {\"text\": \"CITYCOUNCIL\", \"label\": \"other\", \"bbox\": [2052, 183, 2171, 214]},\n    #     ]\n    assert fp_type in [\"gt\", \"pred\"]\n    key = \"label\" if fp_type == \"gt\" else \"pred\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "documentation": {}
    },
    {
        "label": "polygon_from_str",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "peekOfCode": "def polygon_from_str(polygon_points):\n    \"\"\"\n    Create a shapely polygon object from gt or dt line.\n    \"\"\"\n    polygon_points = np.array(polygon_points).reshape(4, 2)\n    polygon = Polygon(polygon_points).convex_hull\n    return polygon\ndef polygon_iou(poly1, poly2):\n    \"\"\"\n    Intersection over union between two shapely polygons.",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "documentation": {}
    },
    {
        "label": "polygon_iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "peekOfCode": "def polygon_iou(poly1, poly2):\n    \"\"\"\n    Intersection over union between two shapely polygons.\n    \"\"\"\n    if not poly1.intersects(\n            poly2):  # this test is fast and can accelerate calculation\n        iou = 0\n    else:\n        try:\n            inter_area = poly1.intersection(poly2).area",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "documentation": {}
    },
    {
        "label": "ed",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "peekOfCode": "def ed(args, str1, str2):\n    if args.ignore_space:\n        str1 = str1.replace(\" \", \"\")\n        str2 = str2.replace(\" \", \"\")\n    if args.ignore_case:\n        str1 = str1.lower()\n        str2 = str2.lower()\n    return Levenshtein.distance(str1, str2)\ndef convert_bbox_to_polygon(bbox):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "documentation": {}
    },
    {
        "label": "convert_bbox_to_polygon",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "peekOfCode": "def convert_bbox_to_polygon(bbox):\n    \"\"\"\n    bbox  : [x1, y1, x2, y2]\n    output: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]\n    \"\"\"\n    xmin, ymin, xmax, ymax = bbox\n    poly = [[xmin, ymin], [xmax, ymin], [xmax, ymax], [xmin, ymax]]\n    return poly\ndef eval_e2e(args):\n    # gt",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "documentation": {}
    },
    {
        "label": "eval_e2e",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "peekOfCode": "def eval_e2e(args):\n    # gt\n    gt_results = parse_ser_results_fp(args.gt_json_path, \"gt\",\n                                      args.ignore_background)\n    # pred\n    dt_results = parse_ser_results_fp(args.pred_json_path, \"pred\",\n                                      args.ignore_background)\n    iou_thresh = args.iou_thres\n    num_gt_chars = 0\n    gt_count = 0",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "peekOfCode": "def parse_args():\n    \"\"\"\n    \"\"\"\n    def str2bool(v):\n        return v.lower() in (\"true\", \"t\", \"1\")\n    parser = argparse.ArgumentParser()\n    ## Required parameters\n    parser.add_argument(\n        \"--gt_json_path\",\n        default=None,",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.eval_with_label_end2end",
        "documentation": {}
    },
    {
        "label": "trans_poly_to_bbox",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "peekOfCode": "def trans_poly_to_bbox(poly):\n    x1 = np.min([p[0] for p in poly])\n    x2 = np.max([p[0] for p in poly])\n    y1 = np.min([p[1] for p in poly])\n    y2 = np.max([p[1] for p in poly])\n    return [x1, y1, x2, y2]\ndef get_outer_poly(bbox_list):\n    x1 = min([bbox[0] for bbox in bbox_list])\n    y1 = min([bbox[1] for bbox in bbox_list])\n    x2 = max([bbox[2] for bbox in bbox_list])",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "documentation": {}
    },
    {
        "label": "get_outer_poly",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "peekOfCode": "def get_outer_poly(bbox_list):\n    x1 = min([bbox[0] for bbox in bbox_list])\n    y1 = min([bbox[1] for bbox in bbox_list])\n    x2 = max([bbox[2] for bbox in bbox_list])\n    y2 = max([bbox[3] for bbox in bbox_list])\n    return [[x1, y1], [x2, y1], [x2, y2], [x1, y2]]\ndef load_funsd_label(image_dir, anno_dir):\n    imgs = os.listdir(image_dir)\n    annos = os.listdir(anno_dir)\n    imgs = [img.replace(\".png\", \"\") for img in imgs]",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "documentation": {}
    },
    {
        "label": "load_funsd_label",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "peekOfCode": "def load_funsd_label(image_dir, anno_dir):\n    imgs = os.listdir(image_dir)\n    annos = os.listdir(anno_dir)\n    imgs = [img.replace(\".png\", \"\") for img in imgs]\n    annos = [anno.replace(\".json\", \"\") for anno in annos]\n    fn_info_map = dict()\n    for anno_fn in annos:\n        res = []\n        with open(os.path.join(anno_dir, anno_fn + \".json\"), \"r\") as fin:\n            infos = json.load(fin)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "peekOfCode": "def main():\n    test_image_dir = \"train_data/FUNSD/testing_data/images/\"\n    test_anno_dir = \"train_data/FUNSD/testing_data/annotations/\"\n    test_output_dir = \"train_data/FUNSD/test.json\"\n    fn_info_map = load_funsd_label(test_image_dir, test_anno_dir)\n    with open(test_output_dir, \"w\") as fout:\n        for fn in fn_info_map:\n            fout.write(fn + \".png\" + \"\\t\" + json.dumps(\n                fn_info_map[fn], ensure_ascii=False) + \"\\n\")\n    train_image_dir = \"train_data/FUNSD/training_data/images/\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_funsd_label",
        "documentation": {}
    },
    {
        "label": "transfer_xfun_data",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "peekOfCode": "def transfer_xfun_data(json_path=None, output_file=None):\n    with open(json_path, \"r\", encoding='utf-8') as fin:\n        lines = fin.readlines()\n    json_info = json.loads(lines[0])\n    documents = json_info[\"documents\"]\n    with open(output_file, \"w\", encoding='utf-8') as fout:\n        for idx, document in enumerate(documents):\n            label_info = []\n            img_info = document[\"img\"]\n            document = document[\"document\"]",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "documentation": {}
    },
    {
        "label": "parser_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "peekOfCode": "def parser_args():\n    import argparse\n    parser = argparse.ArgumentParser(description=\"args for paddleserving\")\n    parser.add_argument(\n        \"--ori_gt_path\", type=str, required=True, help='origin xfun gt path')\n    parser.add_argument(\n        \"--output_path\", type=str, required=True, help='path to save')\n    args = parser.parse_args()\n    return args\nargs = parser_args()",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "peekOfCode": "args = parser_args()\ntransfer_xfun_data(args.ori_gt_path, args.output_path)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.tools.trans_xfun_data",
        "documentation": {}
    },
    {
        "label": "SerPredictor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "peekOfCode": "class SerPredictor(object):\n    def __init__(self, args):\n        self.ocr_engine = PaddleOCR(\n            use_angle_cls=args.use_angle_cls,\n            det_model_dir=args.det_model_dir,\n            rec_model_dir=args.rec_model_dir,\n            show_log=False,\n            use_gpu=args.use_gpu)\n        pre_process_list = [{\n            'VQATokenLabelEncode': {",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    ser_predictor = SerPredictor(args)\n    count = 0\n    total_time = 0\n    os.makedirs(args.output, exist_ok=True)\n    with open(\n            os.path.join(args.output, 'infer.txt'), mode='w',\n            encoding='utf-8') as f_w:\n        for image_file in image_file_list:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport numpy as np\nimport time\nimport tools.infer.utility as utility\nfrom ppocr.data import create_operators, transform",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport numpy as np\nimport time\nimport tools.infer.utility as utility\nfrom ppocr.data import create_operators, transform\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.logging import get_logger\nfrom ppocr.utils.visual import draw_ser_results",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "peekOfCode": "logger = get_logger()\nclass SerPredictor(object):\n    def __init__(self, args):\n        self.ocr_engine = PaddleOCR(\n            use_angle_cls=args.use_angle_cls,\n            det_model_dir=args.det_model_dir,\n            rec_model_dir=args.rec_model_dir,\n            show_log=False,\n            use_gpu=args.use_gpu)\n        pre_process_list = [{",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "SerRePredictor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "peekOfCode": "class SerRePredictor(object):\n    def __init__(self, args):\n        self.use_visual_backbone = args.use_visual_backbone\n        self.ser_engine = SerPredictor(args)\n        if args.re_model_dir is not None:\n            postprocess_params = {'name': 'VQAReTokenLayoutLMPostProcess'}\n            self.postprocess_op = build_post_process(postprocess_params)\n            self.predictor, self.input_tensor, self.output_tensors, self.config = \\\n                utility.create_predictor(args, 're', logger)\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    ser_re_predictor = SerRePredictor(args)\n    count = 0\n    total_time = 0\n    os.makedirs(args.output, exist_ok=True)\n    with open(\n            os.path.join(args.output, 'infer.txt'), mode='w',\n            encoding='utf-8') as f_w:\n        for image_file in image_file_list:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport numpy as np\nimport time\nimport tools.infer.utility as utility\nfrom tools.infer_kie_token_ser_re import make_input",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport numpy as np\nimport time\nimport tools.infer.utility as utility\nfrom tools.infer_kie_token_ser_re import make_input\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.logging import get_logger\nfrom ppocr.utils.visual import draw_ser_results, draw_re_results",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "peekOfCode": "logger = get_logger()\nclass SerRePredictor(object):\n    def __init__(self, args):\n        self.use_visual_backbone = args.use_visual_backbone\n        self.ser_engine = SerPredictor(args)\n        if args.re_model_dir is not None:\n            postprocess_params = {'name': 'VQAReTokenLayoutLMPostProcess'}\n            self.postprocess_op = build_post_process(postprocess_params)\n            self.predictor, self.input_tensor, self.output_tensors, self.config = \\\n                utility.create_predictor(args, 're', logger)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.kie.predict_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "LayoutPredictor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "peekOfCode": "class LayoutPredictor(object):\n    def __init__(self, args):\n        pre_process_list = [{\n            'Resize': {\n                'size': [800, 608]\n            }\n        }, {\n            'NormalizeImage': {\n                'std': [0.229, 0.224, 0.225],\n                'mean': [0.485, 0.456, 0.406],",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    layout_predictor = LayoutPredictor(args)\n    count = 0\n    total_time = 0\n    repeats = 50\n    for image_file in image_file_list:\n        img, flag, _ = check_and_read(image_file)\n        if not flag:\n            img = cv2.imread(image_file)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport tools.infer.utility as utility\nfrom ppocr.data import create_operators, transform\nfrom ppocr.postprocess import build_post_process",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport tools.infer.utility as utility\nfrom ppocr.data import create_operators, transform\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.logging import get_logger\nfrom ppocr.utils.utility import get_image_file_list, check_and_read\nfrom ppstructure.utility import parse_args",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "peekOfCode": "logger = get_logger()\nclass LayoutPredictor(object):\n    def __init__(self, args):\n        pre_process_list = [{\n            'Resize': {\n                'size': [800, 608]\n            }\n        }, {\n            'NormalizeImage': {\n                'std': [0.229, 0.224, 0.225],",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.layout.predict_layout",
        "documentation": {}
    },
    {
        "label": "Worker",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "class Worker(QThread):\n    progressBarValue = Signal(int)\n    progressBarRange = Signal(int)\n    endsignal = Signal()\n    exceptedsignal = Signal(str)  #发送一个异常信号\n    loopFlag = True\n    def __init__(self, predictors, save_pdf, vis_font_path, use_pdf2docx_api):\n        super(Worker, self).__init__()\n        self.predictors = predictors\n        self.save_pdf = save_pdf",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "APP_Image2Doc",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "class APP_Image2Doc(QWidget):\n    def __init__(self):\n        super().__init__()\n        # self.setFixedHeight(100)\n        # self.setFixedWidth(520)\n        # settings\n        self.imagePaths = []\n        # self.screenShotWg = ScreenShotWidget()\n        self.screenShot = None\n        self.save_pdf = False",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "QImageToCvMat",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "def QImageToCvMat(incomingImage) -> np.array:\n    '''  \n    Converts a QImage into an opencv MAT format  \n    '''\n    incomingImage = incomingImage.convertToFormat(QImage.Format.Format_RGBA8888)\n    width = incomingImage.width()\n    height = incomingImage.height()\n    ptr = incomingImage.bits()\n    ptr.setsize(height * width * 4)\n    arr = np.frombuffer(ptr, np.uint8).reshape((height, width, 4))",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "readImage",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "def readImage(image_file) -> list:\n    if os.path.basename(image_file)[-3:] == 'pdf':\n        imgs = []\n        with fitz.open(image_file) as pdf:\n            for pg in range(0, pdf.pageCount):\n                page = pdf[pg]\n                mat = fitz.Matrix(2, 2)\n                pm = page.getPixmap(matrix=mat, alpha=False)\n                # if width or height > 2000 pixels, don't enlarge the image\n                if pm.width > 2000 or pm.height > 2000:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "def main():\n    app = QApplication(sys.argv)\n    window = APP_Image2Doc()  # 创建对象\n    window.show()  # 全屏显示窗口\n    QApplication.processEvents()\n    sys.exit(app.exec())\nif __name__ == \"__main__\":\n    main()",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "file",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "file = os.path.dirname(os.path.abspath(__file__))\nroot = os.path.abspath(os.path.join(file, '../../'))\nsys.path.append(file)\nsys.path.insert(0, root)\nfrom ppstructure.predict_system import StructureSystem, save_structure_res\nfrom ppstructure.utility import parse_args, draw_structure_result\nfrom ppocr.utils.network import download_with_progressbar\nfrom ppstructure.recovery.recovery_to_doc import sorted_layout_boxes, convert_info_docx\n# from ScreenShotWidget import ScreenShotWidget\n__APPNAME__ = \"pdf2word\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "root = os.path.abspath(os.path.join(file, '../../'))\nsys.path.append(file)\nsys.path.insert(0, root)\nfrom ppstructure.predict_system import StructureSystem, save_structure_res\nfrom ppstructure.utility import parse_args, draw_structure_result\nfrom ppocr.utils.network import download_with_progressbar\nfrom ppstructure.recovery.recovery_to_doc import sorted_layout_boxes, convert_info_docx\n# from ScreenShotWidget import ScreenShotWidget\n__APPNAME__ = \"pdf2word\"\n__VERSION__ = \"0.2.2\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "__APPNAME__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "__APPNAME__ = \"pdf2word\"\n__VERSION__ = \"0.2.2\"\nURLs_EN = {\n    # 下载超英文轻量级PP-OCRv3模型的检测模型并解压\n    \"en_PP-OCRv3_det_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_det_infer.tar\",\n    # 下载英文轻量级PP-OCRv3模型的识别模型并解压\n    \"en_PP-OCRv3_rec_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_rec_infer.tar\",\n    # 下载超轻量级英文表格英文模型并解压",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "__VERSION__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "__VERSION__ = \"0.2.2\"\nURLs_EN = {\n    # 下载超英文轻量级PP-OCRv3模型的检测模型并解压\n    \"en_PP-OCRv3_det_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_det_infer.tar\",\n    # 下载英文轻量级PP-OCRv3模型的识别模型并解压\n    \"en_PP-OCRv3_rec_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_rec_infer.tar\",\n    # 下载超轻量级英文表格英文模型并解压\n    \"en_ppstructure_mobile_v2.0_SLANet_infer\":",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "URLs_EN",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "URLs_EN = {\n    # 下载超英文轻量级PP-OCRv3模型的检测模型并解压\n    \"en_PP-OCRv3_det_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_det_infer.tar\",\n    # 下载英文轻量级PP-OCRv3模型的识别模型并解压\n    \"en_PP-OCRv3_rec_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_rec_infer.tar\",\n    # 下载超轻量级英文表格英文模型并解压\n    \"en_ppstructure_mobile_v2.0_SLANet_infer\":\n    \"https://paddleocr.bj.bcebos.com/ppstructure/models/slanet/en_ppstructure_mobile_v2.0_SLANet_infer.tar\",",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "DICT_EN",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "DICT_EN = {\n    \"rec_char_dict_path\": \"en_dict.txt\",\n    \"layout_dict_path\": \"layout_publaynet_dict.txt\",\n}\nURLs_CN = {\n    # 下载超中文轻量级PP-OCRv3模型的检测模型并解压\n    \"cn_PP-OCRv3_det_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_det_infer.tar\",\n    # 下载中文轻量级PP-OCRv3模型的识别模型并解压\n    \"cn_PP-OCRv3_rec_infer\":",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "URLs_CN",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "URLs_CN = {\n    # 下载超中文轻量级PP-OCRv3模型的检测模型并解压\n    \"cn_PP-OCRv3_det_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_det_infer.tar\",\n    # 下载中文轻量级PP-OCRv3模型的识别模型并解压\n    \"cn_PP-OCRv3_rec_infer\":\n    \"https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_rec_infer.tar\",\n    # 下载超轻量级英文表格英文模型并解压\n    \"cn_ppstructure_mobile_v2.0_SLANet_infer\":\n    \"https://paddleocr.bj.bcebos.com/ppstructure/models/slanet/en_ppstructure_mobile_v2.0_SLANet_infer.tar\",",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "DICT_CN",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "peekOfCode": "DICT_CN = {\n    \"rec_char_dict_path\": \"ppocr_keys_v1.txt\",\n    \"layout_dict_path\": \"layout_cdla_dict.txt\",\n}\ndef QImageToCvMat(incomingImage) -> np.array:\n    '''  \n    Converts a QImage into an opencv MAT format  \n    '''\n    incomingImage = incomingImage.convertToFormat(QImage.Format.Format_RGBA8888)\n    width = incomingImage.width()",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.pdf2word.pdf2word",
        "documentation": {}
    },
    {
        "label": "convert_info_docx",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "peekOfCode": "def convert_info_docx(img, res, save_folder, img_name):\n    doc = Document()\n    doc.styles['Normal'].font.name = 'Times New Roman'\n    doc.styles['Normal']._element.rPr.rFonts.set(qn('w:eastAsia'), u'宋体')\n    doc.styles['Normal'].font.size = shared.Pt(6.5)\n    flag = 1\n    for i, region in enumerate(res):\n        img_idx = region['img_idx']\n        if flag == 2 and region['layout'] == 'single':\n            section = doc.add_section(WD_SECTION.CONTINUOUS)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "documentation": {}
    },
    {
        "label": "sorted_layout_boxes",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "peekOfCode": "def sorted_layout_boxes(res, w):\n    \"\"\"\n    Sort text boxes in order from top to bottom, left to right\n    args:\n        res(list):ppstructure results\n    return:\n        sorted results(list)\n    \"\"\"\n    num_boxes = len(res)\n    if num_boxes == 1:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "peekOfCode": "logger = get_logger()\ndef convert_info_docx(img, res, save_folder, img_name):\n    doc = Document()\n    doc.styles['Normal'].font.name = 'Times New Roman'\n    doc.styles['Normal']._element.rPr.rFonts.set(qn('w:eastAsia'), u'宋体')\n    doc.styles['Normal'].font.size = shared.Pt(6.5)\n    flag = 1\n    for i, region in enumerate(res):\n        img_idx = region['img_idx']\n        if flag == 2 and region['layout'] == 'single':",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.recovery_to_doc",
        "documentation": {}
    },
    {
        "label": "HtmlToDocx",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "class HtmlToDocx(HTMLParser):\n    def __init__(self):\n        super().__init__()\n        self.options = {\n            'fix-html': True,\n            'images': True,\n            'tables': True,\n            'styles': True,\n        }\n        self.table_row_selectors = [",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "get_table_rows",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "def get_table_rows(table_soup):\n    table_row_selectors = [\n        'table > tr', 'table > thead > tr', 'table > tbody > tr',\n        'table > tfoot > tr'\n    ]\n    # If there's a header, body, footer or direct child tr tags, add row dimensions from there\n    return table_soup.select(', '.join(table_row_selectors), recursive=False)\ndef get_table_columns(row):\n    # Get all columns for the specified row tag.\n    return row.find_all(['th', 'td'], recursive=False) if row else []",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "get_table_columns",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "def get_table_columns(row):\n    # Get all columns for the specified row tag.\n    return row.find_all(['th', 'td'], recursive=False) if row else []\ndef get_table_dimensions(table_soup):\n    # Get rows for the table\n    rows = get_table_rows(table_soup)\n    # Table is either empty or has non-direct children between table and tr tags\n    # Thus the row dimensions and column dimensions are assumed to be 0\n    cols = get_table_columns(rows[0]) if rows else []\n    # Add colspan calculation column number",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "get_table_dimensions",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "def get_table_dimensions(table_soup):\n    # Get rows for the table\n    rows = get_table_rows(table_soup)\n    # Table is either empty or has non-direct children between table and tr tags\n    # Thus the row dimensions and column dimensions are assumed to be 0\n    cols = get_table_columns(rows[0]) if rows else []\n    # Add colspan calculation column number\n    col_count = 0\n    for col in cols:\n        colspan = col.attrs.get('colspan', 1)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "get_cell_html",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "def get_cell_html(soup):\n    # Returns string of td element with opening and closing <td> tags removed\n    # Cannot use find_all as it only finds element tags and does not find text which\n    # is not inside an element\n    return ' '.join([str(i) for i in soup.contents])\ndef delete_paragraph(paragraph):\n    # https://github.com/python-openxml/python-docx/issues/33#issuecomment-77661907\n    p = paragraph._element\n    p.getparent().remove(p)\n    p._p = p._element = None",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "delete_paragraph",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "def delete_paragraph(paragraph):\n    # https://github.com/python-openxml/python-docx/issues/33#issuecomment-77661907\n    p = paragraph._element\n    p.getparent().remove(p)\n    p._p = p._element = None\ndef remove_whitespace(string, leading=False, trailing=False):\n    \"\"\"Remove white space from a string.\n    Args:\n        string(str): The string to remove white space from.\n        leading(bool, optional): Remove leading new lines when True.",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "remove_whitespace",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "def remove_whitespace(string, leading=False, trailing=False):\n    \"\"\"Remove white space from a string.\n    Args:\n        string(str): The string to remove white space from.\n        leading(bool, optional): Remove leading new lines when True.\n        trailing(bool, optional): Remove trailing new lines when False.\n    Returns:\n        str: The input string with new line characters removed and white space squashed.\n    Examples:\n        Single or multiple new line characters are replaced with space.",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "font_styles",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "font_styles = {\n    'b': 'bold',\n    'strong': 'bold',\n    'em': 'italic',\n    'i': 'italic',\n    'u': 'underline',\n    's': 'strike',\n    'sup': 'superscript',\n    'sub': 'subscript',\n    'th': 'bold',",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "font_names",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "peekOfCode": "font_names = {\n    'code': 'Courier',\n    'pre': 'Courier',\n}\nclass HtmlToDocx(HTMLParser):\n    def __init__(self):\n        super().__init__()\n        self.options = {\n            'fix-html': True,\n            'images': True,",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.recovery.table_process",
        "documentation": {}
    },
    {
        "label": "StyleDict",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "class StyleDict(dict):\n    \"\"\"\n    It's like a dictionary, but it looks for items in the parent dictionary\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.parent = kwargs.pop('parent', None)\n        super(StyleDict, self).__init__(*args, **kwargs)\n    def __getitem__(self, item):\n        if item in self:\n            return super(StyleDict, self).__getitem__(item)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "Element",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "class Element(object):\n    \"\"\"\n    Our base class for representing an html element along with a cascading style.\n    The element is created along with a parent so that the StyleDict that we store\n    can point to the parent's StyleDict.\n    \"\"\"\n    def __init__(self, element, parent=None):\n        self.element = element\n        self.number_format = None\n        parent_style = parent.style_dict if parent else None",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "Table",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "class Table(Element):\n    \"\"\"\n    The concrete implementations of Elements are semantically named for the types of elements we are interested in.\n    This defines a very concrete tree structure for html tables that we expect to deal with. I prefer this compared to\n    allowing Element to have an arbitrary number of children and dealing with an abstract element tree.\n    \"\"\"\n    def __init__(self, table):\n        \"\"\"\n        takes an html table object (from lxml)\n        \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "TableHead",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "class TableHead(Element):\n    \"\"\"\n    This class maps to the `<th>` element of the html table.\n    \"\"\"\n    def __init__(self, head, parent=None):\n        super(TableHead, self).__init__(head, parent=parent)\n        self.rows = [TableRow(tr, parent=self) for tr in head.findall('tr')]\nclass TableBody(Element):\n    \"\"\"\n    This class maps to the `<tbody>` element of the html table.",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "TableBody",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "class TableBody(Element):\n    \"\"\"\n    This class maps to the `<tbody>` element of the html table.\n    \"\"\"\n    def __init__(self, body, parent=None):\n        super(TableBody, self).__init__(body, parent=parent)\n        self.rows = [TableRow(tr, parent=self) for tr in body.findall('tr')]\nclass TableRow(Element):\n    \"\"\"\n    This class maps to the `<tr>` element of the html table.",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "TableRow",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "class TableRow(Element):\n    \"\"\"\n    This class maps to the `<tr>` element of the html table.\n    \"\"\"\n    def __init__(self, tr, parent=None):\n        super(TableRow, self).__init__(tr, parent=parent)\n        self.cells = [TableCell(cell, parent=self) for cell in tr.findall('th') + tr.findall('td')]\ndef element_to_string(el):\n    return _element_to_string(el).strip()\ndef _element_to_string(el):",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "TableCell",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "class TableCell(Element):\n    \"\"\"\n    This class maps to the `<td>` element of the html table.\n    \"\"\"\n    CELL_TYPES = {'TYPE_STRING', 'TYPE_FORMULA', 'TYPE_NUMERIC', 'TYPE_BOOL', 'TYPE_CURRENCY', 'TYPE_PERCENTAGE',\n                  'TYPE_NULL', 'TYPE_INLINE', 'TYPE_ERROR', 'TYPE_FORMULA_CACHE_STRING', 'TYPE_INTEGER'}\n    def __init__(self, cell, parent=None):\n        super(TableCell, self).__init__(cell, parent=parent)\n        self.value = element_to_string(cell)\n        self.number_format = self.get_number_format()",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "colormap",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "def colormap(color):\n    \"\"\"\n    Convenience for looking up known colors\n    \"\"\"\n    cmap = {'black': BLACK}\n    return cmap.get(color, color)\ndef style_string_to_dict(style):\n    \"\"\"\n    Convert css style string to a python dictionary\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "style_string_to_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "def style_string_to_dict(style):\n    \"\"\"\n    Convert css style string to a python dictionary\n    \"\"\"\n    def clean_split(string, delim):\n        return (s.strip() for s in string.split(delim))\n    styles = [clean_split(s, \":\") for s in style.split(\";\") if \":\" in s]\n    return dict(styles)\ndef get_side(style, name):\n    return {'border_style': style.get('border-{}-style'.format(name)),",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "get_side",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "def get_side(style, name):\n    return {'border_style': style.get('border-{}-style'.format(name)),\n            'color': colormap(style.get('border-{}-color'.format(name)))}\nknown_styles = {}\ndef style_dict_to_named_style(style_dict, number_format=None):\n    \"\"\"\n    Change css style (stored in a python dictionary) to openpyxl NamedStyle\n    \"\"\"\n    style_and_format_string = str({\n        'style_dict': style_dict,",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "style_dict_to_named_style",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "def style_dict_to_named_style(style_dict, number_format=None):\n    \"\"\"\n    Change css style (stored in a python dictionary) to openpyxl NamedStyle\n    \"\"\"\n    style_and_format_string = str({\n        'style_dict': style_dict,\n        'parent': style_dict.parent,\n        'number_format': number_format,\n    })\n    if style_and_format_string not in known_styles:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "element_to_string",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "def element_to_string(el):\n    return _element_to_string(el).strip()\ndef _element_to_string(el):\n    string = ''\n    for x in el.iterchildren():\n        string += '\\n' + _element_to_string(x)\n    text = el.text.strip() if el.text else ''\n    tail = el.tail.strip() if el.tail else ''\n    return text + string + '\\n' + tail\nclass TableCell(Element):",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "FORMAT_DATE_MMDDYYYY",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "FORMAT_DATE_MMDDYYYY = 'mm/dd/yyyy'\ndef colormap(color):\n    \"\"\"\n    Convenience for looking up known colors\n    \"\"\"\n    cmap = {'black': BLACK}\n    return cmap.get(color, color)\ndef style_string_to_dict(style):\n    \"\"\"\n    Convert css style string to a python dictionary",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "known_styles",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "peekOfCode": "known_styles = {}\ndef style_dict_to_named_style(style_dict, number_format=None):\n    \"\"\"\n    Change css style (stored in a python dictionary) to openpyxl NamedStyle\n    \"\"\"\n    style_and_format_string = str({\n        'style_dict': style_dict,\n        'parent': style_dict.parent,\n        'number_format': number_format,\n    })",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.style",
        "documentation": {}
    },
    {
        "label": "string_to_int",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def string_to_int(s):\n    if s.isdigit():\n        return int(s)\n    return 0\ndef get_Tables(doc):\n    tree = html.fromstring(doc)\n    comments = tree.xpath('//comment()')\n    for comment in comments:\n        comment.drop_tag()\n    return [Table(table) for table in tree.xpath('//table')]",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "get_Tables",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def get_Tables(doc):\n    tree = html.fromstring(doc)\n    comments = tree.xpath('//comment()')\n    for comment in comments:\n        comment.drop_tag()\n    return [Table(table) for table in tree.xpath('//table')]\ndef write_rows(worksheet, elem, row, column=1):\n    \"\"\"\n    Writes every tr child element of elem to a row in the worksheet\n    returns the next row after all rows are written",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "write_rows",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def write_rows(worksheet, elem, row, column=1):\n    \"\"\"\n    Writes every tr child element of elem to a row in the worksheet\n    returns the next row after all rows are written\n    \"\"\"\n    from openpyxl.cell.cell import MergedCell\n    initial_column = column\n    for table_row in elem.rows:\n        for table_cell in table_row.cells:\n            cell = worksheet.cell(row=row, column=column)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "table_to_sheet",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def table_to_sheet(table, wb):\n    \"\"\"\n    Takes a table and workbook and writes the table to a new sheet.\n    The sheet title will be the same as the table attribute name.\n    \"\"\"\n    ws = wb.create_sheet(title=table.element.get('name'))\n    insert_table(table, ws, 1, 1)\ndef document_to_workbook(doc, wb=None, base_url=None):\n    \"\"\"\n    Takes a string representation of an html document and writes one sheet for",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "document_to_workbook",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def document_to_workbook(doc, wb=None, base_url=None):\n    \"\"\"\n    Takes a string representation of an html document and writes one sheet for\n    every table in the document.\n    The workbook is returned\n    \"\"\"\n    if not wb:\n        wb = Workbook()\n        wb.remove(wb.active)\n    inline_styles_doc = Premailer(doc, base_url=base_url, remove_classes=False).transform()",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "document_to_xl",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def document_to_xl(doc, filename, base_url=None):\n    \"\"\"\n    Takes a string representation of an html document and writes one sheet for\n    every table in the document. The workbook is written out to a file called filename\n    \"\"\"\n    wb = document_to_workbook(doc, base_url=base_url)\n    wb.save(filename)\ndef insert_table(table, worksheet, column, row):\n    if table.head:\n        row = write_rows(worksheet, table.head, row, column)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "insert_table",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def insert_table(table, worksheet, column, row):\n    if table.head:\n        row = write_rows(worksheet, table.head, row, column)\n    if table.body:\n        row = write_rows(worksheet, table.body, row, column)\ndef insert_table_at_cell(table, cell):\n    \"\"\"\n    Inserts a table at the location of an openpyxl Cell object.\n    \"\"\"\n    ws = cell.parent",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "insert_table_at_cell",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "peekOfCode": "def insert_table_at_cell(table, cell):\n    \"\"\"\n    Inserts a table at the location of an openpyxl Cell object.\n    \"\"\"\n    ws = cell.parent\n    column, row = cell.column, cell.row\n    insert_table(table, ws, column, row)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.tablepyxl.tablepyxl",
        "documentation": {}
    },
    {
        "label": "parallel_process",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.parallel",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.parallel",
        "peekOfCode": "def parallel_process(array, function, n_jobs=16, use_kwargs=False, front_num=0):\n    \"\"\"\n        A parallel version of the map function with a progress bar.\n        Args:\n            array (array-like): An array to iterate over.\n            function (function): A python function to apply to the elements of array\n            n_jobs (int, default=16): The number of cores to use\n            use_kwargs (boolean, default=False): Whether to consider the elements of array as dictionaries of\n                keyword arguments to function\n            front_num (int, default=3): The number of iterations to run serially before kicking off the parallel job.",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.parallel",
        "documentation": {}
    },
    {
        "label": "TableTree",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "peekOfCode": "class TableTree(Tree):\n    def __init__(self, tag, colspan=None, rowspan=None, content=None, *children):\n        self.tag = tag\n        self.colspan = colspan\n        self.rowspan = rowspan\n        self.content = content\n        self.children = list(children)\n    def bracket(self):\n        \"\"\"Show tree using brackets notation\"\"\"\n        if self.tag == 'td':",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "documentation": {}
    },
    {
        "label": "CustomConfig",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "peekOfCode": "class CustomConfig(Config):\n    def rename(self, node1, node2):\n        \"\"\"Compares attributes of trees\"\"\"\n        #print(node1.tag)\n        if (node1.tag != node2.tag) or (node1.colspan != node2.colspan) or (node1.rowspan != node2.rowspan):\n            return 1.\n        if node1.tag == 'td':\n            if node1.content or node2.content:\n                #print(node1.content, )\n                return Levenshtein.normalized_distance(node1.content, node2.content)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "documentation": {}
    },
    {
        "label": "CustomConfig_del_short",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "peekOfCode": "class CustomConfig_del_short(Config):\n    def rename(self, node1, node2):\n        \"\"\"Compares attributes of trees\"\"\"\n        if (node1.tag != node2.tag) or (node1.colspan != node2.colspan) or (node1.rowspan != node2.rowspan):\n            return 1.\n        if node1.tag == 'td':\n            if node1.content or node2.content:\n                #print('before')\n                #print(node1.content, node2.content)\n                #print('after')",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "documentation": {}
    },
    {
        "label": "CustomConfig_del_block",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "peekOfCode": "class CustomConfig_del_block(Config):\n    def rename(self, node1, node2):\n        \"\"\"Compares attributes of trees\"\"\"\n        if (node1.tag != node2.tag) or (node1.colspan != node2.colspan) or (node1.rowspan != node2.rowspan):\n            return 1.\n        if node1.tag == 'td':\n            if node1.content or node2.content:\n                node1_content = node1.content\n                node2_content = node2.content\n                while ' '  in node1_content:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "documentation": {}
    },
    {
        "label": "TEDS",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "peekOfCode": "class TEDS(object):\n    ''' Tree Edit Distance basead Similarity\n    '''\n    def __init__(self, structure_only=False, n_jobs=1, ignore_nodes=None):\n        assert isinstance(n_jobs, int) and (\n            n_jobs >= 1), 'n_jobs must be an integer greather than 1'\n        self.structure_only = structure_only\n        self.n_jobs = n_jobs\n        self.ignore_nodes = ignore_nodes\n        self.__tokens__ = []",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_metric.table_metric",
        "documentation": {}
    },
    {
        "label": "save_pred_txt",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "peekOfCode": "def save_pred_txt(key, val, tmp_file_path):\n    with open(tmp_file_path, 'a+', encoding='utf-8') as f:\n        f.write('{}\\t{}\\n'.format(key, val))\ndef skip_char(text, sp_char_list):\n    \"\"\"\n    skip empty cell\n    @param text: text in cell\n    @param sp_char_list: style char and special code\n    @return:\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "documentation": {}
    },
    {
        "label": "skip_char",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "peekOfCode": "def skip_char(text, sp_char_list):\n    \"\"\"\n    skip empty cell\n    @param text: text in cell\n    @param sp_char_list: style char and special code\n    @return:\n    \"\"\"\n    for sp_char in sp_char_list:\n        text = text.replace(sp_char, '')\n    return text",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "documentation": {}
    },
    {
        "label": "gen_html",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "peekOfCode": "def gen_html(img):\n    ''' \n    Formats HTML code from tokenized annotation of img\n    '''\n    html_code = img['html']['structure']['tokens'].copy()\n    to_insert = [i for i, tag in enumerate(html_code) if tag in ('<td>', '>')]\n    for i, cell in zip(to_insert[::-1], img['html']['cells'][::-1]):\n        if cell['tokens']:\n            text = ''.join(cell['tokens'])\n            # skip empty text",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "documentation": {}
    },
    {
        "label": "load_gt_data",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "peekOfCode": "def load_gt_data(gt_path):\n    \"\"\"\n    load gt\n    @param gt_path:\n    @return:\n    \"\"\"\n    data_list = {}\n    with open(gt_path, 'rb') as f:\n        lines = f.readlines()\n        for line in tqdm(lines):",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "peekOfCode": "def convert(origin_gt_path, save_path):\n    \"\"\"\n    gen html from label file\n    @param origin_gt_path:\n    @param save_path:\n    @return:\n    \"\"\"\n    data_dict = load_gt_data(origin_gt_path)\n    for img_name, gt in tqdm(data_dict.items()):\n        html = gen_html(gt)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "peekOfCode": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"args for paddleserving\")\n    parser.add_argument(\n        \"--ori_gt_path\", type=str, required=True, help=\"label gt path\")\n    parser.add_argument(\n        \"--save_path\", type=str, required=True, help=\"path to save file\")\n    args = parser.parse_args()\n    return args\nif __name__ == '__main__':\n    args = parse_args()",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.convert_label2html",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "peekOfCode": "def parse_args():\n    parser = init_args()\n    parser.add_argument(\"--gt_path\", type=str)\n    return parser.parse_args()\ndef load_txt(txt_path):\n    pred_html_dict = {}\n    if not os.path.exists(txt_path):\n        return pred_html_dict\n    with open(txt_path, encoding='utf-8') as f:\n        lines = f.readlines()",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "documentation": {}
    },
    {
        "label": "load_txt",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "peekOfCode": "def load_txt(txt_path):\n    pred_html_dict = {}\n    if not os.path.exists(txt_path):\n        return pred_html_dict\n    with open(txt_path, encoding='utf-8') as f:\n        lines = f.readlines()\n        for line in lines:\n            line = line.strip().split('\\t')\n            img_name, pred_html = line\n            pred_html_dict[img_name] = pred_html",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "documentation": {}
    },
    {
        "label": "load_result",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "peekOfCode": "def load_result(path):\n    data = {}\n    if os.path.exists(path):\n        data = pickle.load(open(path, 'rb'))\n    return data\ndef save_result(path, data):\n    old_data = load_result(path)\n    old_data.update(data)\n    with open(path, 'wb') as f:\n        pickle.dump(old_data, f)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "documentation": {}
    },
    {
        "label": "save_result",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "peekOfCode": "def save_result(path, data):\n    old_data = load_result(path)\n    old_data.update(data)\n    with open(path, 'wb') as f:\n        pickle.dump(old_data, f)\ndef main(gt_path, img_root, args):\n    os.makedirs(args.output, exist_ok=True)\n    # init TableSystem\n    text_sys = TableSystem(args)\n    # load gt and preds html result",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "peekOfCode": "def main(gt_path, img_root, args):\n    os.makedirs(args.output, exist_ok=True)\n    # init TableSystem\n    text_sys = TableSystem(args)\n    # load gt and preds html result\n    gt_html_dict = load_txt(gt_path)\n    ocr_result = load_result(os.path.join(args.output, 'ocr.pickle'))\n    structure_result = load_result(\n        os.path.join(args.output, 'structure.pickle'))\n    pred_htmls = []",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nimport cv2\nimport pickle\nimport paddle\nfrom tqdm import tqdm\nfrom ppstructure.table.table_metric import TEDS\nfrom ppstructure.table.predict_table import TableSystem\nfrom ppstructure.utility import init_args",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "peekOfCode": "logger = get_logger()\ndef parse_args():\n    parser = init_args()\n    parser.add_argument(\"--gt_path\", type=str)\n    return parser.parse_args()\ndef load_txt(txt_path):\n    pred_html_dict = {}\n    if not os.path.exists(txt_path):\n        return pred_html_dict\n    with open(txt_path, encoding='utf-8') as f:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.eval_table",
        "documentation": {}
    },
    {
        "label": "TableMatch",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "peekOfCode": "class TableMatch:\n    def __init__(self, filter_ocr_result=False, use_master=False):\n        self.filter_ocr_result = filter_ocr_result\n        self.use_master = use_master\n    def __call__(self, structure_res, dt_boxes, rec_res):\n        pred_structures, pred_bboxes = structure_res\n        if self.filter_ocr_result:\n            dt_boxes, rec_res = self._filter_ocr_result(pred_bboxes, dt_boxes,\n                                                        rec_res)\n        matched_index = self.match_result(dt_boxes, pred_bboxes)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "peekOfCode": "def distance(box_1, box_2):\n    x1, y1, x2, y2 = box_1\n    x3, y3, x4, y4 = box_2\n    dis = abs(x3 - x1) + abs(y3 - y1) + abs(x4 - x2) + abs(y4 - y2)\n    dis_2 = abs(x3 - x1) + abs(y3 - y1)\n    dis_3 = abs(x4 - x2) + abs(y4 - y2)\n    return dis + min(dis_2, dis_3)\ndef compute_iou(rec1, rec2):\n    \"\"\"\n    computing IoU",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "documentation": {}
    },
    {
        "label": "compute_iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "peekOfCode": "def compute_iou(rec1, rec2):\n    \"\"\"\n    computing IoU\n    :param rec1: (y0, x0, y1, x1), which reflects\n            (top, left, bottom, right)\n    :param rec2: (y0, x0, y1, x1)\n    :return: scala value of IoU\n    \"\"\"\n    # computing area of each rectangles\n    S_rec1 = (rec1[2] - rec1[0]) * (rec1[3] - rec1[1])",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.matcher",
        "documentation": {}
    },
    {
        "label": "TableStructurer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "peekOfCode": "class TableStructurer(object):\n    def __init__(self, args):\n        self.args = args\n        self.use_onnx = args.use_onnx\n        pre_process_list = build_pre_process_list(args)\n        if args.table_algorithm not in ['TableMaster']:\n            postprocess_params = {\n                'name': 'TableLabelDecode',\n                \"character_dict_path\": args.table_char_dict_path,\n                'merge_no_span_structure': args.merge_no_span_structure",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "documentation": {}
    },
    {
        "label": "build_pre_process_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "peekOfCode": "def build_pre_process_list(args):\n    resize_op = {'ResizeTableImage': {'max_len': args.table_max_len, }}\n    pad_op = {\n        'PaddingTableImage': {\n            'size': [args.table_max_len, args.table_max_len]\n        }\n    }\n    normalize_op = {\n        'NormalizeImage': {\n            'std': [0.229, 0.224, 0.225] if",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    table_structurer = TableStructurer(args)\n    count = 0\n    total_time = 0\n    os.makedirs(args.output, exist_ok=True)\n    with open(\n            os.path.join(args.output, 'infer.txt'), mode='w',\n            encoding='utf-8') as f_w:\n        for image_file in image_file_list:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport json\nimport tools.infer.utility as utility\nfrom ppocr.data import create_operators, transform",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport json\nimport tools.infer.utility as utility\nfrom ppocr.data import create_operators, transform\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.logging import get_logger\nfrom ppocr.utils.utility import get_image_file_list, check_and_read",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "peekOfCode": "logger = get_logger()\ndef build_pre_process_list(args):\n    resize_op = {'ResizeTableImage': {'max_len': args.table_max_len, }}\n    pad_op = {\n        'PaddingTableImage': {\n            'size': [args.table_max_len, args.table_max_len]\n        }\n    }\n    normalize_op = {\n        'NormalizeImage': {",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_structure",
        "documentation": {}
    },
    {
        "label": "TableSystem",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "peekOfCode": "class TableSystem(object):\n    def __init__(self, args, text_detector=None, text_recognizer=None):\n        self.args = args\n        if not args.show_log:\n            logger.setLevel(logging.INFO)\n        benchmark_tmp = False\n        if args.benchmark:\n            benchmark_tmp = args.benchmark\n            args.benchmark = False\n        self.text_detector = predict_det.TextDetector(copy.deepcopy(",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "expand",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "peekOfCode": "def expand(pix, det_box, shape):\n    x0, y0, x1, y1 = det_box\n    #     print(shape)\n    h, w, c = shape\n    tmp_x0 = x0 - pix\n    tmp_x1 = x1 + pix\n    tmp_y0 = y0 - pix\n    tmp_y1 = y1 + pix\n    x0_ = tmp_x0 if tmp_x0 >= 0 else 0\n    x1_ = tmp_x1 if tmp_x1 <= w else w",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "to_excel",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "peekOfCode": "def to_excel(html_table, excel_path):\n    from tablepyxl import tablepyxl\n    tablepyxl.document_to_xl(html_table, excel_path)\ndef main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    image_file_list = image_file_list[args.process_id::args.total_process_num]\n    os.makedirs(args.output, exist_ok=True)\n    table_sys = TableSystem(args)\n    img_num = len(image_file_list)\n    f_html = open(",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    image_file_list = image_file_list[args.process_id::args.total_process_num]\n    os.makedirs(args.output, exist_ok=True)\n    table_sys = TableSystem(args)\n    img_num = len(image_file_list)\n    f_html = open(\n        os.path.join(args.output, 'show.html'), mode='w', encoding='utf-8')\n    f_html.write('<html>\\n<body>\\n')\n    f_html.write('<table border=\"1\">\\n')",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport copy\nimport logging\nimport numpy as np\nimport time",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport copy\nimport logging\nimport numpy as np\nimport time\nimport tools.infer.predict_rec as predict_rec\nimport tools.infer.predict_det as predict_det\nimport tools.infer.utility as utility\nfrom tools.infer.predict_system import sorted_boxes",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "peekOfCode": "logger = get_logger()\ndef expand(pix, det_box, shape):\n    x0, y0, x1, y1 = det_box\n    #     print(shape)\n    h, w, c = shape\n    tmp_x0 = x0 - pix\n    tmp_x1 = x1 + pix\n    tmp_y0 = y0 - pix\n    tmp_y1 = y1 + pix\n    x0_ = tmp_x0 if tmp_x0 >= 0 else 0",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.predict_table",
        "documentation": {}
    },
    {
        "label": "Matcher",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "class Matcher:\n    def __init__(self, end2end_file, structure_master_file):\n        \"\"\"\n        This class process the end2end results and structure recognition results.\n        :param end2end_file: end2end results predict by end2end inference.\n        :param structure_master_file: structure recognition results predict by structure master inference.\n        \"\"\"\n        self.end2end_file = end2end_file\n        self.structure_master_file = structure_master_file\n        self.end2end_results = pickle_load(end2end_file, prefix='end2end')",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "TableMasterMatcher",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "class TableMasterMatcher(Matcher):\n    def __init__(self):\n        pass\n    def __call__(self, structure_res, dt_boxes, rec_res, img_name=1):\n        end2end_results = {img_name: []}\n        for dt_box, res in zip(dt_boxes, rec_res):\n            d = dict(\n                bbox=np.array(dt_box),\n                text=res[0], )\n            end2end_results[img_name].append(d)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "remove_empty_bboxes",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def remove_empty_bboxes(bboxes):\n    \"\"\"\n    remove [0., 0., 0., 0.] in structure master bboxes.\n    len(bboxes.shape) must be 2.\n    :param bboxes:\n    :return:\n    \"\"\"\n    new_bboxes = []\n    for bbox in bboxes:\n        if sum(bbox) == 0.:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "xywh2xyxy",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def xywh2xyxy(bboxes):\n    if len(bboxes.shape) == 1:\n        new_bboxes = np.empty_like(bboxes)\n        new_bboxes[0] = bboxes[0] - bboxes[2] / 2\n        new_bboxes[1] = bboxes[1] - bboxes[3] / 2\n        new_bboxes[2] = bboxes[0] + bboxes[2] / 2\n        new_bboxes[3] = bboxes[1] + bboxes[3] / 2\n        return new_bboxes\n    elif len(bboxes.shape) == 2:\n        new_bboxes = np.empty_like(bboxes)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def xyxy2xywh(bboxes):\n    if len(bboxes.shape) == 1:\n        new_bboxes = np.empty_like(bboxes)\n        new_bboxes[0] = bboxes[0] + (bboxes[2] - bboxes[0]) / 2\n        new_bboxes[1] = bboxes[1] + (bboxes[3] - bboxes[1]) / 2\n        new_bboxes[2] = bboxes[2] - bboxes[0]\n        new_bboxes[3] = bboxes[3] - bboxes[1]\n        return new_bboxes\n    elif len(bboxes.shape) == 2:\n        new_bboxes = np.empty_like(bboxes)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "pickle_load",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def pickle_load(path, prefix='end2end'):\n    if os.path.isfile(path):\n        data = pickle.load(open(path, 'rb'))\n    elif os.path.isdir(path):\n        data = dict()\n        search_path = os.path.join(path, '{}_*.pkl'.format(prefix))\n        pkls = glob.glob(search_path)\n        for pkl in pkls:\n            this_data = pickle.load(open(pkl, 'rb'))\n            data.update(this_data)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "convert_coord",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def convert_coord(xyxy):\n    \"\"\"\n    Convert two points format to four points format.\n    :param xyxy:\n    :return:\n    \"\"\"\n    new_bbox = np.zeros([4, 2], dtype=np.float32)\n    new_bbox[0, 0], new_bbox[0, 1] = xyxy[0], xyxy[1]\n    new_bbox[1, 0], new_bbox[1, 1] = xyxy[2], xyxy[1]\n    new_bbox[2, 0], new_bbox[2, 1] = xyxy[2], xyxy[3]",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "cal_iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def cal_iou(bbox1, bbox2):\n    bbox1_poly = Polygon(bbox1).convex_hull\n    bbox2_poly = Polygon(bbox2).convex_hull\n    union_poly = np.concatenate((bbox1, bbox2))\n    if not bbox1_poly.intersects(bbox2_poly):\n        iou = 0\n    else:\n        inter_area = bbox1_poly.intersection(bbox2_poly).area\n        union_area = MultiPoint(union_poly).convex_hull.area\n        if union_area == 0:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "cal_distance",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def cal_distance(p1, p2):\n    delta_x = p1[0] - p2[0]\n    delta_y = p1[1] - p2[1]\n    d = math.sqrt((delta_x**2) + (delta_y**2))\n    return d\ndef is_inside(center_point, corner_point):\n    \"\"\"\n    Find if center_point inside the bbox(corner_point) or not.\n    :param center_point: center point (x, y)\n    :param corner_point: corner point ((x1,y1),(x2,y2))",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "is_inside",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def is_inside(center_point, corner_point):\n    \"\"\"\n    Find if center_point inside the bbox(corner_point) or not.\n    :param center_point: center point (x, y)\n    :param corner_point: corner point ((x1,y1),(x2,y2))\n    :return:\n    \"\"\"\n    x_flag = False\n    y_flag = False\n    if (center_point[0] >= corner_point[0][0]) and (",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "find_no_match",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def find_no_match(match_list, all_end2end_nums, type='end2end'):\n    \"\"\"\n    Find out no match end2end bbox in previous match list.\n    :param match_list: matching pairs.\n    :param all_end2end_nums: numbers of end2end_xywh\n    :param type: 'end2end' corresponding to idx 0, 'master' corresponding to idx 1.\n    :return: no match pse bbox index list\n    \"\"\"\n    if type == 'end2end':\n        idx = 0",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "is_abs_lower_than_threshold",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def is_abs_lower_than_threshold(this_bbox, target_bbox, threshold=3):\n    # only consider y axis, for grouping in row.\n    delta = abs(this_bbox[1] - target_bbox[1])\n    if delta < threshold:\n        return True\n    else:\n        return False\ndef sort_line_bbox(g, bg):\n    \"\"\"\n    Sorted the bbox in the same line(group)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "sort_line_bbox",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def sort_line_bbox(g, bg):\n    \"\"\"\n    Sorted the bbox in the same line(group)\n    compare coord 'x' value, where 'y' value is closed in the same group.\n    :param g: index in the same group\n    :param bg: bbox in the same group\n    :return:\n    \"\"\"\n    xs = [bg_item[0] for bg_item in bg]\n    xs_sorted = sorted(xs)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def flatten(sorted_groups, sorted_bbox_groups):\n    idxs = []\n    bboxes = []\n    for group, bbox_group in zip(sorted_groups, sorted_bbox_groups):\n        for g, bg in zip(group, bbox_group):\n            idxs.append(g)\n            bboxes.append(bg)\n    return idxs, bboxes\ndef sort_bbox(end2end_xywh_bboxes, no_match_end2end_indexes):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "sort_bbox",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def sort_bbox(end2end_xywh_bboxes, no_match_end2end_indexes):\n    \"\"\"\n    This function will group the render end2end bboxes in row.\n    :param end2end_xywh_bboxes:\n    :param no_match_end2end_indexes:\n    :return:\n    \"\"\"\n    groups = []\n    bbox_groups = []\n    for index, end2end_xywh_bbox in zip(no_match_end2end_indexes,",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "get_bboxes_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def get_bboxes_list(end2end_result, structure_master_result):\n    \"\"\"\n    This function is use to convert end2end results and structure master results to\n    List of xyxy bbox format and List of xywh bbox format\n    :param end2end_result: bbox's format is xyxy\n    :param structure_master_result: bbox's format is xywh\n    :return: 4 kind list of bbox ()\n    \"\"\"\n    # end2end\n    end2end_xyxy_list = []",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "center_rule_match",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def center_rule_match(end2end_xywh_bboxes, structure_master_xyxy_bboxes):\n    \"\"\"\n    Judge end2end Bbox's center point is inside structure master Bbox or not,\n    if end2end Bbox's center is in structure master Bbox, get matching pair.\n    :param end2end_xywh_bboxes:\n    :param structure_master_xyxy_bboxes:\n    :return: match pairs list, e.g. [[0,1], [1,2], ...]\n    \"\"\"\n    match_pairs_list = []\n    for i, end2end_xywh in enumerate(end2end_xywh_bboxes):",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "iou_rule_match",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def iou_rule_match(end2end_xyxy_bboxes, end2end_xyxy_indexes,\n                   structure_master_xyxy_bboxes):\n    \"\"\"\n    Use iou to find matching list.\n    choose max iou value bbox as match pair.\n    :param end2end_xyxy_bboxes:\n    :param end2end_xyxy_indexes: original end2end indexes.\n    :param structure_master_xyxy_bboxes:\n    :return: match pairs list, e.g. [[0,1], [1,2], ...]\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "distance_rule_match",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def distance_rule_match(end2end_indexes, end2end_bboxes, master_indexes,\n                        master_bboxes):\n    \"\"\"\n    Get matching between no-match end2end bboxes and no-match master bboxes.\n    Use min distance to match.\n    This rule will only run (no-match end2end nums > 0) and (no-match master nums > 0)\n    It will Return master_bboxes_nums match-pairs.\n    :param end2end_indexes:\n    :param end2end_bboxes:\n    :param master_indexes:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "extra_match",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def extra_match(no_match_end2end_indexes, master_bbox_nums):\n    \"\"\"\n    This function will create some virtual master bboxes,\n    and get match with the no match end2end indexes.\n    :param no_match_end2end_indexes:\n    :param master_bbox_nums:\n    :return:\n    \"\"\"\n    end_nums = len(no_match_end2end_indexes) + master_bbox_nums\n    extra_match_list = []",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "get_match_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def get_match_dict(match_list):\n    \"\"\"\n    Convert match_list to a dict, where key is master bbox's index, value is end2end bbox index.\n    :param match_list:\n    :return:\n    \"\"\"\n    match_dict = dict()\n    for match_pair in match_list:\n        end2end_index, master_index = match_pair[0], match_pair[1]\n        if master_index not in match_dict.keys():",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "deal_successive_space",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def deal_successive_space(text):\n    \"\"\"\n    deal successive space character for text\n    1. Replace ' '*3 with '<space>' which is real space is text\n    2. Remove ' ', which is split token, not true space\n    3. Replace '<space>' with ' ', to get real text\n    :param text:\n    :return:\n    \"\"\"\n    text = text.replace(' ' * 3, '<space>')",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "reduce_repeat_bb",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def reduce_repeat_bb(text_list, break_token):\n    \"\"\"\n    convert ['<b>Local</b>', '<b>government</b>', '<b>unit</b>'] to ['<b>Local government unit</b>']\n    PS: maybe style <i>Local</i> is also exist, too. it can be processed like this.\n    :param text_list:\n    :param break_token:\n    :return:\n    \"\"\"\n    count = 0\n    for text in text_list:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "get_match_text_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def get_match_text_dict(match_dict, end2end_info, break_token=' '):\n    match_text_dict = dict()\n    for master_index, end2end_index_list in match_dict.items():\n        text_list = [\n            end2end_info[end2end_index]['text']\n            for end2end_index in end2end_index_list\n        ]\n        text_list = reduce_repeat_bb(text_list, break_token)\n        text = break_token.join(text_list)\n        match_text_dict[master_index] = text",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "merge_span_token",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def merge_span_token(master_token_list):\n    \"\"\"\n    Merge the span style token (row span or col span).\n    :param master_token_list:\n    :return:\n    \"\"\"\n    new_master_token_list = []\n    pointer = 0\n    if master_token_list[-1] != '</tbody>':\n        master_token_list.append('</tbody>')",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "deal_eb_token",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def deal_eb_token(master_token):\n    \"\"\"\n    post process with <eb></eb>, <eb1></eb1>, ...\n    emptyBboxTokenDict = {\n        \"[]\": '<eb></eb>',\n        \"[' ']\": '<eb1></eb1>',\n        \"['<b>', ' ', '</b>']\": '<eb2></eb2>',\n        \"['\\\\u2028', '\\\\u2028']\": '<eb3></eb3>',\n        \"['<sup>', ' ', '</sup>']\": '<eb4></eb4>',\n        \"['<b>', '</b>']\": '<eb5></eb5>',",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "insert_text_to_token",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def insert_text_to_token(master_token_list, match_text_dict):\n    \"\"\"\n    Insert OCR text result to structure token.\n    :param master_token_list:\n    :param match_text_dict:\n    :return:\n    \"\"\"\n    master_token_list = merge_span_token(master_token_list)\n    merged_result_list = []\n    text_count = 0",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "deal_isolate_span",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def deal_isolate_span(thead_part):\n    \"\"\"\n    Deal with isolate span cases in this function.\n    It causes by wrong prediction in structure recognition model.\n    eg. predict <td rowspan=\"2\"></td> to <td></td> rowspan=\"2\"></b></td>.\n    :param thead_part:\n    :return:\n    \"\"\"\n    # 1. find out isolate span tokens.\n    isolate_pattern = \"<td></td> rowspan=\\\"(\\d)+\\\" colspan=\\\"(\\d)+\\\"></b></td>|\" \\",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "deal_duplicate_bb",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def deal_duplicate_bb(thead_part):\n    \"\"\"\n    Deal duplicate <b> or </b> after replace.\n    Keep one <b></b> in a <td></td> token.\n    :param thead_part:\n    :return:\n    \"\"\"\n    # 1. find out <td></td> in <thead></thead>.\n    td_pattern = \"<td rowspan=\\\"(\\d)+\\\" colspan=\\\"(\\d)+\\\">(.+?)</td>|\" \\\n                 \"<td colspan=\\\"(\\d)+\\\" rowspan=\\\"(\\d)+\\\">(.+?)</td>|\" \\",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "deal_bb",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "peekOfCode": "def deal_bb(result_token):\n    \"\"\"\n    In our opinion, <b></b> always occurs in <thead></thead> text's context.\n    This function will find out all tokens in <thead></thead> and insert <b></b> by manual.\n    :param result_token:\n    :return:\n    \"\"\"\n    # find out <thead></thead> parts.\n    thead_pattern = '<thead>(.*?)</thead>'\n    if re.search(thead_pattern, result_token) is None:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.table.table_master_match",
        "documentation": {}
    },
    {
        "label": "StructureSystem",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "peekOfCode": "class StructureSystem(object):\n    def __init__(self, args):\n        self.mode = args.mode\n        self.recovery = args.recovery\n        self.image_orientation_predictor = None\n        if args.image_orientation:\n            import paddleclas\n            self.image_orientation_predictor = paddleclas.PaddleClas(\n                model_name=\"text_image_orientation\")\n        if self.mode == 'structure':",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "save_structure_res",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "peekOfCode": "def save_structure_res(res, save_folder, img_name, img_idx=0):\n    excel_save_folder = os.path.join(save_folder, img_name)\n    os.makedirs(excel_save_folder, exist_ok=True)\n    res_cp = deepcopy(res)\n    # save res\n    with open(\n            os.path.join(excel_save_folder, 'res_{}.txt'.format(img_idx)),\n            'w',\n            encoding='utf8') as f:\n        for region in res_cp:",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    image_file_list = image_file_list\n    image_file_list = image_file_list[args.process_id::args.total_process_num]\n    if not args.use_pdf2docx_api:\n        structure_sys = StructureSystem(args)\n        save_folder = os.path.join(args.output, structure_sys.mode)\n        os.makedirs(save_folder, exist_ok=True)\n    img_num = len(image_file_list)\n    for i, image_file in enumerate(image_file_list):",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport numpy as np\nimport time\nimport logging\nfrom copy import deepcopy",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport numpy as np\nimport time\nimport logging\nfrom copy import deepcopy\nfrom ppocr.utils.utility import get_image_file_list, check_and_read\nfrom ppocr.utils.logging import get_logger\nfrom ppocr.utils.visual import draw_ser_results, draw_re_results",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "peekOfCode": "logger = get_logger()\nclass StructureSystem(object):\n    def __init__(self, args):\n        self.mode = args.mode\n        self.recovery = args.recovery\n        self.image_orientation_predictor = None\n        if args.image_orientation:\n            import paddleclas\n            self.image_orientation_predictor = paddleclas.PaddleClas(\n                model_name=\"text_image_orientation\")",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.predict_system",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "peekOfCode": "def init_args():\n    parser = infer_args()\n    # params for output\n    parser.add_argument(\"--output\", type=str, default='./output')\n    # params for table structure\n    parser.add_argument(\"--table_max_len\", type=int, default=488)\n    parser.add_argument(\"--table_algorithm\", type=str, default='TableAttn')\n    parser.add_argument(\"--table_model_dir\", type=str)\n    parser.add_argument(\n        \"--merge_no_span_structure\", type=str2bool, default=True)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "peekOfCode": "def parse_args():\n    parser = init_args()\n    return parser.parse_args()\ndef draw_structure_result(image, result, font_path):\n    if isinstance(image, np.ndarray):\n        image = Image.fromarray(image)\n    boxes, txts, scores = [], [], []\n    img_layout = image.copy()\n    draw_layout = ImageDraw.Draw(img_layout)\n    text_color = (255, 255, 255)",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "draw_structure_result",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "description": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "peekOfCode": "def draw_structure_result(image, result, font_path):\n    if isinstance(image, np.ndarray):\n        image = Image.fromarray(image)\n    boxes, txts, scores = [], [], []\n    img_layout = image.copy()\n    draw_layout = ImageDraw.Draw(img_layout)\n    text_color = (255, 255, 255)\n    text_background_color = (80, 127, 255)\n    catid2color = {}\n    font_size = 15",
        "detail": "Vision.Paddle.PaddleOCR.ppstructure.utility",
        "documentation": {}
    },
    {
        "label": "CBN",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "peekOfCode": "class CBN(nn.Layer):\n    def __init__(self,\n                 name,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 padding=0,\n                 dilation=1,\n                 groups=1,",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "documentation": {}
    },
    {
        "label": "SNConv",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "peekOfCode": "class SNConv(nn.Layer):\n    def __init__(self,\n                 name,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 padding=0,\n                 dilation=1,\n                 groups=1,",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "documentation": {}
    },
    {
        "label": "SNConvTranspose",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "peekOfCode": "class SNConvTranspose(nn.Layer):\n    def __init__(self,\n                 name,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 padding=0,\n                 output_padding=0,\n                 dilation=1,",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "documentation": {}
    },
    {
        "label": "MiddleNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "peekOfCode": "class MiddleNet(nn.Layer):\n    def __init__(self, name, in_channels, mid_channels, out_channels,\n                 use_bias):\n        super(MiddleNet, self).__init__()\n        self._sn_conv1 = SNConv(\n            name=name + \"_sn_conv1\",\n            in_channels=in_channels,\n            out_channels=mid_channels,\n            kernel_size=1,\n            use_bias=use_bias,",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "peekOfCode": "class ResBlock(nn.Layer):\n    def __init__(self, name, channels, norm_layer, use_dropout, use_dilation,\n                 use_bias):\n        super(ResBlock, self).__init__()\n        if use_dilation:\n            padding_mat = [1, 1, 1, 1]\n        else:\n            padding_mat = [0, 0, 0, 0]\n        self._pad1 = nn.Pad2D(padding_mat, mode=\"replicate\")\n        self._sn_conv1 = SNConv(",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.base_module",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "peekOfCode": "class Decoder(nn.Layer):\n    def __init__(self, name, encode_dim, out_channels, use_bias, norm_layer,\n                 act, act_attr, conv_block_dropout, conv_block_num,\n                 conv_block_dilation, out_conv_act, out_conv_act_attr):\n        super(Decoder, self).__init__()\n        conv_blocks = []\n        for i in range(conv_block_num):\n            conv_blocks.append(\n                ResBlock(\n                    name=\"{}_conv_block_{}\".format(name, i),",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "documentation": {}
    },
    {
        "label": "DecoderUnet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "peekOfCode": "class DecoderUnet(nn.Layer):\n    def __init__(self, name, encode_dim, out_channels, use_bias, norm_layer,\n                 act, act_attr, conv_block_dropout, conv_block_num,\n                 conv_block_dilation, out_conv_act, out_conv_act_attr):\n        super(DecoderUnet, self).__init__()\n        conv_blocks = []\n        for i in range(conv_block_num):\n            conv_blocks.append(\n                ResBlock(\n                    name=\"{}_conv_block_{}\".format(name, i),",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "documentation": {}
    },
    {
        "label": "SingleDecoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "peekOfCode": "class SingleDecoder(nn.Layer):\n    def __init__(self, name, encode_dim, out_channels, use_bias, norm_layer,\n                 act, act_attr, conv_block_dropout, conv_block_num,\n                 conv_block_dilation, out_conv_act, out_conv_act_attr):\n        super(SingleDecoder, self).__init__()\n        conv_blocks = []\n        for i in range(conv_block_num):\n            conv_blocks.append(\n                ResBlock(\n                    name=\"{}_conv_block_{}\".format(name, i),",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.decoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.encoder",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.encoder",
        "peekOfCode": "class Encoder(nn.Layer):\n    def __init__(self, name, in_channels, encode_dim, use_bias, norm_layer,\n                 act, act_attr, conv_block_dropout, conv_block_num,\n                 conv_block_dilation):\n        super(Encoder, self).__init__()\n        self._pad2d = paddle.nn.Pad2D([3, 3, 3, 3], mode=\"replicate\")\n        self._in_conv = SNConv(\n            name=name + \"_in_conv\",\n            in_channels=in_channels,\n            out_channels=encode_dim,",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.encoder",
        "documentation": {}
    },
    {
        "label": "EncoderUnet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.encoder",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.encoder",
        "peekOfCode": "class EncoderUnet(nn.Layer):\n    def __init__(self, name, in_channels, encode_dim, use_bias, norm_layer,\n                 act, act_attr):\n        super(EncoderUnet, self).__init__()\n        self._pad2d = paddle.nn.Pad2D([3, 3, 3, 3], mode=\"replicate\")\n        self._in_conv = SNConv(\n            name=name + \"_in_conv\",\n            in_channels=in_channels,\n            out_channels=encode_dim,\n            kernel_size=7,",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.encoder",
        "documentation": {}
    },
    {
        "label": "SpectralNorm",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "peekOfCode": "class SpectralNorm(object):\n    def __init__(self, name='weight', n_power_iterations=1, dim=0, eps=1e-12):\n        self.name = name\n        self.dim = dim\n        if n_power_iterations <= 0:\n            raise ValueError('Expected n_power_iterations to be positive, but '\n                             'got n_power_iterations={}'.format(\n                                 n_power_iterations))\n        self.n_power_iterations = n_power_iterations\n        self.eps = eps",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "documentation": {}
    },
    {
        "label": "normal_",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "peekOfCode": "def normal_(x, mean=0., std=1.):\n    temp_value = paddle.normal(mean, std, shape=x.shape)\n    x.set_value(temp_value)\n    return x\nclass SpectralNorm(object):\n    def __init__(self, name='weight', n_power_iterations=1, dim=0, eps=1e-12):\n        self.name = name\n        self.dim = dim\n        if n_power_iterations <= 0:\n            raise ValueError('Expected n_power_iterations to be positive, but '",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "documentation": {}
    },
    {
        "label": "spectral_norm",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "peekOfCode": "def spectral_norm(module,\n                  name='weight',\n                  n_power_iterations=1,\n                  eps=1e-12,\n                  dim=None):\n    if dim is None:\n        if isinstance(module, (nn.Conv1DTranspose, nn.Conv2DTranspose,\n                               nn.Conv3DTranspose, nn.Linear)):\n            dim = 1\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.spectral_norm",
        "documentation": {}
    },
    {
        "label": "StyleTextRec",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "peekOfCode": "class StyleTextRec(nn.Layer):\n    def __init__(self, config):\n        super(StyleTextRec, self).__init__()\n        self.logger = get_logger()\n        self.text_generator = TextGenerator(config[\"Predictor\"][\n            \"text_generator\"])\n        self.bg_generator = BgGeneratorWithMask(config[\"Predictor\"][\n            \"bg_generator\"])\n        self.fusion_generator = FusionGeneratorSimple(config[\"Predictor\"][\n            \"fusion_generator\"])",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "documentation": {}
    },
    {
        "label": "TextGenerator",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "peekOfCode": "class TextGenerator(nn.Layer):\n    def __init__(self, config):\n        super(TextGenerator, self).__init__()\n        name = config[\"module_name\"]\n        encode_dim = config[\"encode_dim\"]\n        norm_layer = config[\"norm_layer\"]\n        conv_block_dropout = config[\"conv_block_dropout\"]\n        conv_block_num = config[\"conv_block_num\"]\n        conv_block_dilation = config[\"conv_block_dilation\"]\n        if norm_layer == \"InstanceNorm2D\":",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "documentation": {}
    },
    {
        "label": "BgGeneratorWithMask",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "peekOfCode": "class BgGeneratorWithMask(nn.Layer):\n    def __init__(self, config):\n        super(BgGeneratorWithMask, self).__init__()\n        name = config[\"module_name\"]\n        encode_dim = config[\"encode_dim\"]\n        norm_layer = config[\"norm_layer\"]\n        conv_block_dropout = config[\"conv_block_dropout\"]\n        conv_block_num = config[\"conv_block_num\"]\n        conv_block_dilation = config[\"conv_block_dilation\"]\n        self.output_factor = config.get(\"output_factor\", 1.0)",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "documentation": {}
    },
    {
        "label": "FusionGeneratorSimple",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "description": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "peekOfCode": "class FusionGeneratorSimple(nn.Layer):\n    def __init__(self, config):\n        super(FusionGeneratorSimple, self).__init__()\n        name = config[\"module_name\"]\n        encode_dim = config[\"encode_dim\"]\n        norm_layer = config[\"norm_layer\"]\n        conv_block_dropout = config[\"conv_block_dropout\"]\n        conv_block_dilation = config[\"conv_block_dilation\"]\n        if norm_layer == \"InstanceNorm2D\":\n            use_bias = True",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.arch.style_text_rec",
        "documentation": {}
    },
    {
        "label": "FileCorpus",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.corpus_generators",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.corpus_generators",
        "peekOfCode": "class FileCorpus(object):\n    def __init__(self, config):\n        self.logger = get_logger()\n        self.logger.info(\"using FileCorpus\")\n        self.char_list = \" 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n        corpus_file = config[\"CorpusGenerator\"][\"corpus_file\"]\n        self.language = config[\"CorpusGenerator\"][\"language\"]\n        with open(corpus_file, 'r') as f:\n            corpus_raw = f.read()\n        self.corpus_list = corpus_raw.split(\"\\n\")[:-1]",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.corpus_generators",
        "documentation": {}
    },
    {
        "label": "EnNumCorpus",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.corpus_generators",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.corpus_generators",
        "peekOfCode": "class EnNumCorpus(object):\n    def __init__(self, config):\n        self.logger = get_logger()\n        self.logger.info(\"using NumberCorpus\")\n        self.num_list = \"0123456789\"\n        self.en_char_list = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n        self.height = config[\"Global\"][\"image_height\"]\n        self.max_width = config[\"Global\"][\"image_width\"]\n    def generate(self, corpus_length=0):\n        corpus = \"\"",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.corpus_generators",
        "documentation": {}
    },
    {
        "label": "StyleTextRecPredictor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.predictors",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.predictors",
        "peekOfCode": "class StyleTextRecPredictor(object):\n    def __init__(self, config):\n        algorithm = config['Predictor']['algorithm']\n        assert algorithm in [\"StyleTextRec\"\n                             ], \"Generator {} not supported.\".format(algorithm)\n        use_gpu = config[\"Global\"]['use_gpu']\n        check_gpu(use_gpu)\n        paddle.set_device('gpu' if use_gpu else 'cpu')\n        self.logger = get_logger()\n        self.generator = getattr(style_text_rec, algorithm)(config)",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.predictors",
        "documentation": {}
    },
    {
        "label": "DatasetSampler",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.style_samplers",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.style_samplers",
        "peekOfCode": "class DatasetSampler(object):\n    def __init__(self, config):\n        self.image_home = config[\"StyleSampler\"][\"image_home\"]\n        label_file = config[\"StyleSampler\"][\"label_file\"]\n        self.dataset_with_label = config[\"StyleSampler\"][\"with_label\"]\n        self.height = config[\"Global\"][\"image_height\"]\n        self.index = 0\n        with open(label_file, \"r\") as f:\n            label_raw = f.read()\n            self.path_label_list = label_raw.split(\"\\n\")[:-1]",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.style_samplers",
        "documentation": {}
    },
    {
        "label": "duplicate_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.style_samplers",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.style_samplers",
        "peekOfCode": "def duplicate_image(image, width):\n    image_width = image.shape[1]\n    dup_num = width // image_width + 1\n    image = np.tile(image, reps=[1, dup_num, 1])\n    cropped_image = image[:, :width, :]\n    return cropped_image",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.style_samplers",
        "documentation": {}
    },
    {
        "label": "ImageSynthesiser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.synthesisers",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.synthesisers",
        "peekOfCode": "class ImageSynthesiser(object):\n    def __init__(self):\n        self.FLAGS = ArgsParser().parse_args()\n        self.config = load_config(self.FLAGS.config)\n        self.config = override_config(self.config, options=self.FLAGS.override)\n        self.output_dir = self.config[\"Global\"][\"output_dir\"]\n        if not os.path.exists(self.output_dir):\n            os.mkdir(self.output_dir)\n        self.logger = get_logger(\n            log_file='{}/predict.log'.format(self.output_dir))",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.synthesisers",
        "documentation": {}
    },
    {
        "label": "DatasetSynthesiser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.synthesisers",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.synthesisers",
        "peekOfCode": "class DatasetSynthesiser(ImageSynthesiser):\n    def __init__(self):\n        super(DatasetSynthesiser, self).__init__()\n        self.tag = self.FLAGS.tag\n        self.output_num = self.config[\"Global\"][\"output_num\"]\n        corpus_generator_method = self.config[\"CorpusGenerator\"][\"method\"]\n        self.corpus_generator = getattr(corpus_generators,\n                                        corpus_generator_method)(self.config)\n        style_sampler_method = self.config[\"StyleSampler\"][\"method\"]\n        assert style_sampler_method is not None",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.synthesisers",
        "documentation": {}
    },
    {
        "label": "StdTextDrawer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.text_drawers",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.text_drawers",
        "peekOfCode": "class StdTextDrawer(object):\n    def __init__(self, config):\n        self.logger = get_logger()\n        self.max_width = config[\"Global\"][\"image_width\"]\n        self.char_list = \" 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n        self.height = config[\"Global\"][\"image_height\"]\n        self.font_dict = {}\n        self.load_fonts(config[\"TextDrawer\"][\"fonts\"])\n        self.support_languages = list(self.font_dict)\n    def load_fonts(self, fonts_config):",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.text_drawers",
        "documentation": {}
    },
    {
        "label": "SimpleWriter",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.engine.writers",
        "description": "Vision.Paddle.PaddleOCR.StyleText.engine.writers",
        "peekOfCode": "class SimpleWriter(object):\n    def __init__(self, config, tag):\n        self.logger = get_logger()\n        self.output_dir = config[\"Global\"][\"output_dir\"]\n        self.counter = 0\n        self.label_dict = {}\n        self.tag = tag\n        self.label_file_index = 0\n    def save_image(self, image, text_input_label):\n        image_home = os.path.join(self.output_dir, \"images\", self.tag)",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.engine.writers",
        "documentation": {}
    },
    {
        "label": "synth_dataset",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_dataset",
        "description": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_dataset",
        "peekOfCode": "def synth_dataset():\n    dataset_synthesiser = DatasetSynthesiser()\n    dataset_synthesiser.synth_dataset()\nif __name__ == '__main__':\n    synth_dataset()",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_dataset",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_dataset",
        "description": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_dataset",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.append(os.path.abspath(os.path.join(__dir__, '..')))\nfrom engine.synthesisers import DatasetSynthesiser\ndef synth_dataset():\n    dataset_synthesiser = DatasetSynthesiser()\n    dataset_synthesiser.synth_dataset()\nif __name__ == '__main__':\n    synth_dataset()",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_dataset",
        "documentation": {}
    },
    {
        "label": "synth_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "description": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "peekOfCode": "def synth_image():\n    args = ArgsParser().parse_args()\n    image_synthesiser = ImageSynthesiser()\n    style_image_path = args.style_image\n    img = cv2.imread(style_image_path)\n    text_corpus = args.text_corpus\n    language = args.language\n    synth_result = image_synthesiser.synth_image(text_corpus, img, language)\n    fake_fusion = synth_result[\"fake_fusion\"]\n    fake_text = synth_result[\"fake_text\"]",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "documentation": {}
    },
    {
        "label": "batch_synth_images",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "description": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "peekOfCode": "def batch_synth_images():\n    image_synthesiser = ImageSynthesiser()\n    corpus_file = \"../StyleTextRec_data/test_20201208/test_text_list.txt\"\n    style_data_dir = \"../StyleTextRec_data/test_20201208/style_images/\"\n    save_path = \"./output_data/\"\n    corpus_list = []\n    with open(corpus_file, \"rb\") as fin:\n        lines = fin.readlines()\n        for line in lines:\n            substr = line.decode(\"utf-8\").strip(\"\\n\").split(\"\\t\")",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "description": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.append(os.path.abspath(os.path.join(__dir__, '..')))\nfrom utils.config import ArgsParser\nfrom engine.synthesisers import ImageSynthesiser\ndef synth_image():\n    args = ArgsParser().parse_args()\n    image_synthesiser = ImageSynthesiser()\n    style_image_path = args.style_image\n    img = cv2.imread(style_image_path)",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.tools.synth_image",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "peekOfCode": "class ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\"-c\", \"--config\", help=\"configuration file to use\")\n        self.add_argument(\n            \"-t\", \"--tag\", default=\"0\", help=\"tag for marking worker\")\n        self.add_argument(\n            '-o',\n            '--override',",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "documentation": {}
    },
    {
        "label": "override",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "peekOfCode": "def override(dl, ks, v):\n    \"\"\"\n    Recursively replace dict of list\n    Args:\n        dl(dict or list): dict or list to be replaced\n        ks(list): list of keys\n        v(str): value to be replaced\n    \"\"\"\n    def str2num(v):\n        try:",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "documentation": {}
    },
    {
        "label": "override_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "peekOfCode": "def override_config(config, options=None):\n    \"\"\"\n    Recursively override the config\n    Args:\n        config(dict): dict to be replaced\n        options(list): list of pairs(key0.key1.idx.key2=value)\n            such as: [\n                'topk=2',\n                'VALID.transforms.1.ResizeImage.resize_short=300'\n            ]",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "peekOfCode": "def load_config(file_path):\n    \"\"\"\n    Load config from yml/yaml file.\n    Args:\n        file_path (str): Path of the config file to be loaded.\n    Returns: config\n    \"\"\"\n    ext = os.path.splitext(file_path)[1]\n    assert ext in ['.yml', '.yaml'], \"only support yaml files for now\"\n    with open(file_path, 'rb') as f:",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "documentation": {}
    },
    {
        "label": "gen_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "peekOfCode": "def gen_config():\n    base_config = {\n        \"Global\": {\n            \"algorithm\": \"SRNet\",\n            \"use_gpu\": True,\n            \"start_epoch\": 1,\n            \"stage1_epoch_num\": 100,\n            \"stage2_epoch_num\": 100,\n            \"log_smooth_window\": 20,\n            \"print_batch_step\": 2,",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.config",
        "documentation": {}
    },
    {
        "label": "load_dygraph_pretrain",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.load_params",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.load_params",
        "peekOfCode": "def load_dygraph_pretrain(model, logger, path=None, load_static_weights=False):\n    if not os.path.exists(path + '.pdparams'):\n        raise ValueError(\"Model pretrain path {} does not \"\n                         \"exists.\".format(path))\n    param_state_dict = paddle.load(path + '.pdparams')\n    model.set_state_dict(param_state_dict)\n    logger.info(\"load pretrained model from {}\".format(path))\n    return",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.load_params",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.load_params",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.load_params",
        "peekOfCode": "__all__ = ['load_dygraph_pretrain']\ndef load_dygraph_pretrain(model, logger, path=None, load_static_weights=False):\n    if not os.path.exists(path + '.pdparams'):\n        raise ValueError(\"Model pretrain path {} does not \"\n                         \"exists.\".format(path))\n    param_state_dict = paddle.load(path + '.pdparams')\n    model.set_state_dict(param_state_dict)\n    logger.info(\"load pretrained model from {}\".format(path))\n    return",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.load_params",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.logging",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.logging",
        "peekOfCode": "def get_logger(name='srnet', log_file=None, log_level=logging.INFO):\n    \"\"\"Initialize and get a logger by name.\n    If the logger has not been initialized, this method will initialize the\n    logger by adding one or two handlers, otherwise the initialized logger will\n    be directly returned. During initialization, a StreamHandler will always be\n    added. If `log_file` is specified a FileHandler will also be added.\n    Args:\n        name (str): Logger name.\n        log_file (str | None): The log filename. If specified, a FileHandler\n            will be added to the logger.",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger_initialized",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.logging",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.logging",
        "peekOfCode": "logger_initialized = {}\n@functools.lru_cache()\ndef get_logger(name='srnet', log_file=None, log_level=logging.INFO):\n    \"\"\"Initialize and get a logger by name.\n    If the logger has not been initialized, this method will initialize the\n    logger by adding one or two handlers, otherwise the initialized logger will\n    be directly returned. During initialization, a StreamHandler will always be\n    added. If `log_file` is specified a FileHandler will also be added.\n    Args:\n        name (str): Logger name.",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.logging",
        "documentation": {}
    },
    {
        "label": "compute_mean_covariance",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.math_functions",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.math_functions",
        "peekOfCode": "def compute_mean_covariance(img):\n    batch_size = img.shape[0]\n    channel_num = img.shape[1]\n    height = img.shape[2]\n    width = img.shape[3]\n    num_pixels = height * width\n    # batch_size * channel_num * 1 * 1\n    mu = img.mean(2, keepdim=True).mean(3, keepdim=True)\n    # batch_size * channel_num * num_pixels\n    img_hat = img - mu.expand_as(img)",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.math_functions",
        "documentation": {}
    },
    {
        "label": "dice_coefficient",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.math_functions",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.math_functions",
        "peekOfCode": "def dice_coefficient(y_true_cls, y_pred_cls, training_mask):\n    eps = 1e-5\n    intersection = paddle.sum(y_true_cls * y_pred_cls * training_mask)\n    union = paddle.sum(y_true_cls * training_mask) + paddle.sum(\n        y_pred_cls * training_mask) + eps\n    loss = 1. - (2 * intersection / union)\n    return loss",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.math_functions",
        "documentation": {}
    },
    {
        "label": "get_check_global_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.sys_funcs",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.sys_funcs",
        "peekOfCode": "def get_check_global_params(mode):\n    check_params = [\n        'use_gpu', 'max_text_length', 'image_shape', 'image_shape',\n        'character_type', 'loss_type'\n    ]\n    if mode == \"train_eval\":\n        check_params = check_params + [\n            'train_batch_size_per_card', 'test_batch_size_per_card'\n        ]\n    elif mode == \"test\":",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.sys_funcs",
        "documentation": {}
    },
    {
        "label": "check_gpu",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.StyleText.utils.sys_funcs",
        "description": "Vision.Paddle.PaddleOCR.StyleText.utils.sys_funcs",
        "peekOfCode": "def check_gpu(use_gpu):\n    \"\"\"\n    Log error and exit when set use_gpu=true in paddlepaddle\n    cpu version.\n    \"\"\"\n    err = \"Config use_gpu cannot be set as true while you are \" \\\n          \"using paddlepaddle cpu version ! \\nPlease try: \\n\" \\\n          \"\\t1. Install paddlepaddle-gpu to run model on GPU \\n\" \\\n          \"\\t2. Set use_gpu as false in config file to run \" \\\n          \"model on CPU\"",
        "detail": "Vision.Paddle.PaddleOCR.StyleText.utils.sys_funcs",
        "documentation": {}
    },
    {
        "label": "LeNet",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "class LeNet(nn.Layer):\n    def __init__(self):\n        super(LeNet, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels=1, out_channels=6, kernel_size=5, stride=1, padding=2)\n        self.max_pool1 = nn.MaxPool2D(kernel_size=2, stride=2)\n        self.conv2 = nn.Conv2D(\n            in_channels=6, out_channels=16, kernel_size=5, stride=1)\n        self.max_pool2 = nn.MaxPool2D(kernel_size=2, stride=2)\n        self.linear1 = nn.Linear(in_features=16 * 5 * 5, out_features=120)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "EPOCH_NUM",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "EPOCH_NUM = 4\nBATCH_SIZE = 64\n# jit compile custom op\ncustom_ops = load(\n    name=\"custom_jit_ops\", sources=[\"custom_relu_op.cc\", \"custom_relu_op.cu\"])\nclass LeNet(nn.Layer):\n    def __init__(self):\n        super(LeNet, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels=1, out_channels=6, kernel_size=5, stride=1, padding=2)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "BATCH_SIZE",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "BATCH_SIZE = 64\n# jit compile custom op\ncustom_ops = load(\n    name=\"custom_jit_ops\", sources=[\"custom_relu_op.cc\", \"custom_relu_op.cu\"])\nclass LeNet(nn.Layer):\n    def __init__(self):\n        super(LeNet, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels=1, out_channels=6, kernel_size=5, stride=1, padding=2)\n        self.max_pool1 = nn.MaxPool2D(kernel_size=2, stride=2)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "custom_ops",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "custom_ops = load(\n    name=\"custom_jit_ops\", sources=[\"custom_relu_op.cc\", \"custom_relu_op.cu\"])\nclass LeNet(nn.Layer):\n    def __init__(self):\n        super(LeNet, self).__init__()\n        self.conv1 = nn.Conv2D(\n            in_channels=1, out_channels=6, kernel_size=5, stride=1, padding=2)\n        self.max_pool1 = nn.MaxPool2D(kernel_size=2, stride=2)\n        self.conv2 = nn.Conv2D(\n            in_channels=6, out_channels=16, kernel_size=5, stride=1)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "net",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "net = LeNet()\nloss_fn = nn.CrossEntropyLoss()\nopt = paddle.optimizer.Adam(learning_rate=0.001, parameters=net.parameters())\n# data loader\ntransform = Compose([Normalize(mean=[127.5], std=[127.5], data_format='CHW')])\ntrain_dataset = paddle.vision.datasets.MNIST(mode='train', transform=transform)\ntrain_loader = paddle.io.DataLoader(\n    train_dataset,\n    batch_size=BATCH_SIZE,\n    shuffle=True,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "loss_fn",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "loss_fn = nn.CrossEntropyLoss()\nopt = paddle.optimizer.Adam(learning_rate=0.001, parameters=net.parameters())\n# data loader\ntransform = Compose([Normalize(mean=[127.5], std=[127.5], data_format='CHW')])\ntrain_dataset = paddle.vision.datasets.MNIST(mode='train', transform=transform)\ntrain_loader = paddle.io.DataLoader(\n    train_dataset,\n    batch_size=BATCH_SIZE,\n    shuffle=True,\n    drop_last=True,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "opt",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "opt = paddle.optimizer.Adam(learning_rate=0.001, parameters=net.parameters())\n# data loader\ntransform = Compose([Normalize(mean=[127.5], std=[127.5], data_format='CHW')])\ntrain_dataset = paddle.vision.datasets.MNIST(mode='train', transform=transform)\ntrain_loader = paddle.io.DataLoader(\n    train_dataset,\n    batch_size=BATCH_SIZE,\n    shuffle=True,\n    drop_last=True,\n    num_workers=2)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "transform",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "transform = Compose([Normalize(mean=[127.5], std=[127.5], data_format='CHW')])\ntrain_dataset = paddle.vision.datasets.MNIST(mode='train', transform=transform)\ntrain_loader = paddle.io.DataLoader(\n    train_dataset,\n    batch_size=BATCH_SIZE,\n    shuffle=True,\n    drop_last=True,\n    num_workers=2)\n# train\nfor epoch_id in range(EPOCH_NUM):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "train_dataset",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "train_dataset = paddle.vision.datasets.MNIST(mode='train', transform=transform)\ntrain_loader = paddle.io.DataLoader(\n    train_dataset,\n    batch_size=BATCH_SIZE,\n    shuffle=True,\n    drop_last=True,\n    num_workers=2)\n# train\nfor epoch_id in range(EPOCH_NUM):\n    for batch_id, (image, label) in enumerate(train_loader()):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "train_loader",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "peekOfCode": "train_loader = paddle.io.DataLoader(\n    train_dataset,\n    batch_size=BATCH_SIZE,\n    shuffle=True,\n    drop_last=True,\n    num_workers=2)\n# train\nfor epoch_id in range(EPOCH_NUM):\n    for batch_id, (image, label) in enumerate(train_loader()):\n        out = net(image)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.custom_op.test",
        "documentation": {}
    },
    {
        "label": "prune_model",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_fpgm",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_fpgm",
        "peekOfCode": "def prune_model(model, input_shape, prune_ratio=0.1):\n    flops = paddle.flops(model, input_shape)\n    pruner = FPGMFilterPruner(model, input_shape)\n    params_sensitive = {}\n    for param in model.parameters():\n        if 'transpose' not in param.name and 'linear' not in param.name:\n            # set prune ratio as 10%. The larger the value, the more convolution weights will be cropped\n            params_sensitive[param.name] = prune_ratio\n    plan = pruner.prune_vars(params_sensitive, [0])\n    flops = paddle.flops(model, input_shape)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_fpgm",
        "documentation": {}
    },
    {
        "label": "PACT",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_quant",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_quant",
        "peekOfCode": "class PACT(paddle.nn.Layer):\n    def __init__(self):\n        super(PACT, self).__init__()\n        alpha_attr = paddle.ParamAttr(\n            name=self.full_name() + \".pact\",\n            initializer=paddle.nn.initializer.Constant(value=20),\n            learning_rate=1.0,\n            regularizer=paddle.regularizer.L2Decay(2e-5))\n        self.alpha = self.create_parameter(\n            shape=[1], attr=alpha_attr, dtype='float32')",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_quant",
        "documentation": {}
    },
    {
        "label": "quant_config",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_quant",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_quant",
        "peekOfCode": "quant_config = {\n    # weight preprocess type, default is None and no preprocessing is performed. \n    'weight_preprocess_type': None,\n    # activation preprocess type, default is None and no preprocessing is performed.\n    'activation_preprocess_type': None,\n    # weight quantize type, default is 'channel_wise_abs_max'\n    'weight_quantize_type': 'channel_wise_abs_max',\n    # activation quantize type, default is 'moving_average_abs_max'\n    'activation_quantize_type': 'moving_average_abs_max',\n    # weight quantize bit num, default is 8",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.slim.slim_quant",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "peekOfCode": "class ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\"-c\", \"--config\", help=\"configuration file to use\")\n        self.add_argument(\n            \"-o\", \"--opt\", nargs='+', help=\"set configuration options\")\n        self.add_argument(\n            '-p',\n            '--profiler_options',",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "peekOfCode": "class AttrDict(dict):\n    \"\"\"Single level attribute dict, NOT recursive\"\"\"\n    def __init__(self, **kwargs):\n        super(AttrDict, self).__init__()\n        super(AttrDict, self).update(kwargs)\n    def __getattr__(self, key):\n        if key in self:\n            return self[key]\n        raise AttributeError(\"object has no attribute '{}'\".format(key))\nglobal_config = AttrDict()",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "peekOfCode": "def load_config(file_path):\n    \"\"\"\n    Load config from yml/yaml file.\n    Args:\n        file_path (str): Path of the config file to be loaded.\n    Returns: global config\n    \"\"\"\n    merge_config(default_config)\n    _, ext = os.path.splitext(file_path)\n    assert ext in ['.yml', '.yaml'], \"only support yaml files for now\"",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "documentation": {}
    },
    {
        "label": "merge_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "peekOfCode": "def merge_config(config):\n    \"\"\"\n    Merge config into global config.\n    Args:\n        config (dict): Config to be merged.\n    Returns: global config\n    \"\"\"\n    for key, value in config.items():\n        if \".\" not in key:\n            if isinstance(value, dict) and key in global_config:",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "documentation": {}
    },
    {
        "label": "preprocess",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "peekOfCode": "def preprocess(is_train=False):\n    FLAGS = ArgsParser().parse_args()\n    profiler_options = FLAGS.profiler_options\n    config = load_config(FLAGS.config)\n    merge_config(FLAGS.opt)\n    profile_dic = {\"profiler_options\": FLAGS.profiler_options}\n    merge_config(profile_dic)\n    if is_train:\n        # save_config\n        save_model_dir = config['save_model_dir']",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "documentation": {}
    },
    {
        "label": "global_config",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "peekOfCode": "global_config = AttrDict()\ndefault_config = {'Global': {'debug': False, }}\ndef load_config(file_path):\n    \"\"\"\n    Load config from yml/yaml file.\n    Args:\n        file_path (str): Path of the config file to be loaded.\n    Returns: global config\n    \"\"\"\n    merge_config(default_config)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "documentation": {}
    },
    {
        "label": "default_config",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "peekOfCode": "default_config = {'Global': {'debug': False, }}\ndef load_config(file_path):\n    \"\"\"\n    Load config from yml/yaml file.\n    Args:\n        file_path (str): Path of the config file to be loaded.\n    Returns: global config\n    \"\"\"\n    merge_config(default_config)\n    _, ext = os.path.splitext(file_path)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.config",
        "documentation": {}
    },
    {
        "label": "DecodeImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "peekOfCode": "class DecodeImage(object):\n    \"\"\" decode image \"\"\"\n    def __init__(self, img_mode='RGB', channel_first=False, **kwargs):\n        self.img_mode = img_mode\n        self.channel_first = channel_first\n    def __call__(self, data):\n        img = data['image']\n        if six.PY2:\n            assert type(img) is str and len(\n                img) > 0, \"invalid input 'img' in DecodeImage\"",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "documentation": {}
    },
    {
        "label": "NormalizeImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "peekOfCode": "class NormalizeImage(object):\n    \"\"\" normalize image such as substract mean, divide std\n    \"\"\"\n    def __init__(self, scale=None, mean=None, std=None, order='chw', **kwargs):\n        if isinstance(scale, str):\n            scale = eval(scale)\n        self.scale = np.float32(scale if scale is not None else 1.0 / 255.0)\n        mean = mean if mean is not None else [0.485, 0.456, 0.406]\n        std = std if std is not None else [0.229, 0.224, 0.225]\n        shape = (3, 1, 1) if order == 'chw' else (1, 1, 3)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "documentation": {}
    },
    {
        "label": "ToCHWImage",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "peekOfCode": "class ToCHWImage(object):\n    \"\"\" convert hwc image to chw image\n    \"\"\"\n    def __init__(self, **kwargs):\n        pass\n    def __call__(self, data):\n        img = data['image']\n        from PIL import Image\n        if isinstance(img, Image.Image):\n            img = np.array(img)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "documentation": {}
    },
    {
        "label": "SimpleDataset",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "peekOfCode": "class SimpleDataset(nn.Dataset):\n    def __init__(self, config, mode, logger, seed=None):\n        self.logger = logger\n        self.mode = mode.lower()\n        data_dir = config['Train']['data_dir']\n        imgs_list = self.get_image_list(data_dir)\n        self.ops = create_operators(cfg['transforms'], None)\n    def get_image_list(self, img_dir):\n        imgs = glob.glob(os.path.join(img_dir, \"*.png\"))\n        if len(imgs) == 0:",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "documentation": {}
    },
    {
        "label": "transform",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "peekOfCode": "def transform(data, ops=None):\n    \"\"\" transform \"\"\"\n    if ops is None:\n        ops = []\n    for op in ops:\n        data = op(data)\n        if data is None:\n            return None\n    return data\ndef create_operators(op_param_list, global_config=None):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "documentation": {}
    },
    {
        "label": "create_operators",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "peekOfCode": "def create_operators(op_param_list, global_config=None):\n    \"\"\"\n    create operators based on the config\n    Args:\n        params(list): a dict list, used to create some operators\n    \"\"\"\n    assert isinstance(op_param_list, list), ('operator config should be a list')\n    ops = []\n    for operator in op_param_list:\n        assert isinstance(operator,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data",
        "documentation": {}
    },
    {
        "label": "term_mp",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data_loader",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data_loader",
        "peekOfCode": "def term_mp(sig_num, frame):\n    \"\"\" kill all child processes\n    \"\"\"\n    pid = os.getpid()\n    pgid = os.getpgid(os.getpid())\n    print(\"main proc {} exit, kill process group \" \"{}\".format(pid, pgid))\n    os.killpg(pgid, signal.SIGKILL)\n    return\ndef build_dataloader(mode,\n                     batch_size=4,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data_loader",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data_loader",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data_loader",
        "peekOfCode": "def build_dataloader(mode,\n                     batch_size=4,\n                     seed=None,\n                     num_workers=0,\n                     device='gpu:0'):\n    normalize = Normalize(\n        mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5], data_format='HWC')\n    if mode.lower() == \"train\":\n        dataset = Cifar100(mode=mode, transform=normalize)\n    elif mode.lower() in [\"test\", 'valid', 'eval']:",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.data_loader",
        "documentation": {}
    },
    {
        "label": "load_CIFAR_batch",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.load_cifar",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.load_cifar",
        "peekOfCode": "def load_CIFAR_batch(filename):\n    \"\"\" load single batch of cifar \"\"\"\n    with open(filename, 'rb') as f:\n        datadict = p.load(f, encoding='bytes')\n        # 以字典的形式取出数据\n        X = datadict[b'data']\n        Y = datadict[b'fine_labels']\n        try:\n            X = X.reshape(10000, 3, 32, 32)\n        except:",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.load_cifar",
        "documentation": {}
    },
    {
        "label": "Loss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "peekOfCode": "class Loss(object):\n    \"\"\"\n    Loss\n    \"\"\"\n    def __init__(self, class_dim=1000, epsilon=None):\n        assert class_dim > 1, \"class_dim=%d is not larger than 1\" % (class_dim)\n        self._class_dim = class_dim\n        if epsilon is not None and epsilon >= 0.0 and epsilon <= 1.0:\n            self._epsilon = epsilon\n            self._label_smoothing = True",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "documentation": {}
    },
    {
        "label": "LossDistill",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "peekOfCode": "class LossDistill(Loss):\n    def __init__(self, model_name_list, class_dim=1000, epsilon=None):\n        assert class_dim > 1, \"class_dim=%d is not larger than 1\" % (class_dim)\n        self._class_dim = class_dim\n        if epsilon is not None and epsilon >= 0.0 and epsilon <= 1.0:\n            self._epsilon = epsilon\n            self._label_smoothing = True\n        else:\n            self._epsilon = None\n            self._label_smoothing = False",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "documentation": {}
    },
    {
        "label": "KLJSLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "peekOfCode": "class KLJSLoss(object):\n    def __init__(self, mode='kl'):\n        assert mode in ['kl', 'js', 'KL', 'JS'\n                        ], \"mode can only be one of ['kl', 'js', 'KL', 'JS']\"\n        self.mode = mode\n    def __call__(self, p1, p2, reduction=\"mean\"):\n        p1 = F.softmax(p1, axis=-1)\n        p2 = F.softmax(p2, axis=-1)\n        loss = paddle.multiply(p2, paddle.log((p2 + 1e-5) / (p1 + 1e-5) + 1e-5))\n        if self.mode.lower() == \"js\":",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "documentation": {}
    },
    {
        "label": "DMLLoss",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "peekOfCode": "class DMLLoss(object):\n    def __init__(self, model_name_pairs, mode='js'):\n        self.model_name_pairs = self._check_model_name_pairs(model_name_pairs)\n        self.kljs_loss = KLJSLoss(mode=mode)\n    def _check_model_name_pairs(self, model_name_pairs):\n        if not isinstance(model_name_pairs, list):\n            return []\n        elif isinstance(model_name_pairs[0], list) and isinstance(\n                model_name_pairs[0][0], str):\n            return model_name_pairs",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "documentation": {}
    },
    {
        "label": "build_loss",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "peekOfCode": "def build_loss(config, epsilon=None):\n    class_dim = config['class_dim']\n    loss_func = Loss(class_dim=class_dim, epsilon=epsilon)\n    return loss_func\nclass LossDistill(Loss):\n    def __init__(self, model_name_list, class_dim=1000, epsilon=None):\n        assert class_dim > 1, \"class_dim=%d is not larger than 1\" % (class_dim)\n        self._class_dim = class_dim\n        if epsilon is not None and epsilon >= 0.0 and epsilon <= 1.0:\n            self._epsilon = epsilon",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.loss",
        "documentation": {}
    },
    {
        "label": "create_metric",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.metric",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.metric",
        "peekOfCode": "def create_metric(out,\n                  label,\n                  architecture=None,\n                  topk=5,\n                  classes_num=1000,\n                  use_distillation=False,\n                  mode=\"train\"):\n    \"\"\"\n    Create measures of model accuracy, such as top1 and top5\n    Args:",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.metric",
        "documentation": {}
    },
    {
        "label": "MobileNetV3",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "class MobileNetV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,\n                 model_name=\"small\",\n                 dropout_prob=0.2,\n                 class_dim=1000,\n                 use_custom_relu=False):\n        super(MobileNetV3, self).__init__()\n        self.use_custom_relu = use_custom_relu\n        inplanes = 16",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "ConvBNLayer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "class ConvBNLayer(nn.Layer):\n    def __init__(self,\n                 in_c,\n                 out_c,\n                 filter_size,\n                 stride,\n                 padding,\n                 num_groups=1,\n                 if_act=True,\n                 act=None,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "ResidualUnit",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "class ResidualUnit(nn.Layer):\n    def __init__(self,\n                 in_c,\n                 mid_c,\n                 out_c,\n                 filter_size,\n                 stride,\n                 use_se,\n                 act=None,\n                 name='',",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "SEModule",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "class SEModule(nn.Layer):\n    def __init__(self, channel, reduction=4, name=\"\"):\n        super(SEModule, self).__init__()\n        self.avg_pool = AdaptiveAvgPool2D(1)\n        self.conv1 = Conv2D(\n            in_channels=channel,\n            out_channels=channel // reduction,\n            kernel_size=1,\n            stride=1,\n            padding=0,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "DistillMV3",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "class DistillMV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,\n                 model_name=\"small\",\n                 dropout_prob=0.2,\n                 class_dim=1000,\n                 args=None,\n                 use_custom_relu=False):\n        super(DistillMV3, self).__init__()\n        self.student = MobileNetV3(",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "SiameseMV3",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "class SiameseMV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,\n                 model_name=\"small\",\n                 dropout_prob=0.2,\n                 class_dim=1000,\n                 args=None,\n                 use_custom_relu=False):\n        super(SiameseMV3, self).__init__()\n        self.net = MobileNetV3(",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def make_divisible(v, divisor=8, min_value=None):\n    if min_value is None:\n        min_value = divisor\n    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)\n    if new_v < 0.9 * v:\n        new_v += divisor\n    return new_v\nclass MobileNetV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_small_x0_35",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_small_x0_35(**args):\n    model = MobileNetV3(model_name=\"small\", scale=0.35, **args)\n    return model\ndef MobileNetV3_small_x0_5(**args):\n    model = MobileNetV3(model_name=\"small\", scale=0.5, **args)\n    return model\ndef MobileNetV3_small_x0_75(**args):\n    model = MobileNetV3(model_name=\"small\", scale=0.75, **args)\n    return model\ndef MobileNetV3_small_x1_0(**args):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_small_x0_5",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_small_x0_5(**args):\n    model = MobileNetV3(model_name=\"small\", scale=0.5, **args)\n    return model\ndef MobileNetV3_small_x0_75(**args):\n    model = MobileNetV3(model_name=\"small\", scale=0.75, **args)\n    return model\ndef MobileNetV3_small_x1_0(**args):\n    model = MobileNetV3(model_name=\"small\", scale=1.0, **args)\n    return model\ndef MobileNetV3_small_x1_25(**args):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_small_x0_75",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_small_x0_75(**args):\n    model = MobileNetV3(model_name=\"small\", scale=0.75, **args)\n    return model\ndef MobileNetV3_small_x1_0(**args):\n    model = MobileNetV3(model_name=\"small\", scale=1.0, **args)\n    return model\ndef MobileNetV3_small_x1_25(**args):\n    model = MobileNetV3(model_name=\"small\", scale=1.25, **args)\n    return model\ndef MobileNetV3_large_x0_35(**args):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_small_x1_0",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_small_x1_0(**args):\n    model = MobileNetV3(model_name=\"small\", scale=1.0, **args)\n    return model\ndef MobileNetV3_small_x1_25(**args):\n    model = MobileNetV3(model_name=\"small\", scale=1.25, **args)\n    return model\ndef MobileNetV3_large_x0_35(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.35, **args)\n    return model\ndef MobileNetV3_large_x0_5(**args):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_small_x1_25",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_small_x1_25(**args):\n    model = MobileNetV3(model_name=\"small\", scale=1.25, **args)\n    return model\ndef MobileNetV3_large_x0_35(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.35, **args)\n    return model\ndef MobileNetV3_large_x0_5(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.5, **args)\n    return model\ndef MobileNetV3_large_x0_75(**args):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_large_x0_35",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_large_x0_35(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.35, **args)\n    return model\ndef MobileNetV3_large_x0_5(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.5, **args)\n    return model\ndef MobileNetV3_large_x0_75(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.75, **args)\n    return model\ndef MobileNetV3_large_x1_0(**args):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_large_x0_5",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_large_x0_5(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.5, **args)\n    return model\ndef MobileNetV3_large_x0_75(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.75, **args)\n    return model\ndef MobileNetV3_large_x1_0(**args):\n    model = MobileNetV3(model_name=\"large\", scale=1.0, **args)\n    return model\ndef MobileNetV3_large_x1_25(**args):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_large_x0_75",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_large_x0_75(**args):\n    model = MobileNetV3(model_name=\"large\", scale=0.75, **args)\n    return model\ndef MobileNetV3_large_x1_0(**args):\n    model = MobileNetV3(model_name=\"large\", scale=1.0, **args)\n    return model\ndef MobileNetV3_large_x1_25(**args):\n    model = MobileNetV3(model_name=\"large\", scale=1.25, **args)\n    return\nclass DistillMV3(nn.Layer):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_large_x1_0",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_large_x1_0(**args):\n    model = MobileNetV3(model_name=\"large\", scale=1.0, **args)\n    return model\ndef MobileNetV3_large_x1_25(**args):\n    model = MobileNetV3(model_name=\"large\", scale=1.25, **args)\n    return\nclass DistillMV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,\n                 model_name=\"small\",",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "MobileNetV3_large_x1_25",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def MobileNetV3_large_x1_25(**args):\n    model = MobileNetV3(model_name=\"large\", scale=1.25, **args)\n    return\nclass DistillMV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,\n                 model_name=\"small\",\n                 dropout_prob=0.2,\n                 class_dim=1000,\n                 args=None,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "distillmv3_large_x0_5",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def distillmv3_large_x0_5(**args):\n    model = DistillMV3(model_name=\"large\", scale=0.5, **args)\n    return model\nclass SiameseMV3(nn.Layer):\n    def __init__(self,\n                 scale=1.0,\n                 model_name=\"small\",\n                 dropout_prob=0.2,\n                 class_dim=1000,\n                 args=None,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "siamese_mv3",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def siamese_mv3(class_dim, use_custom_relu):\n    model = SiameseMV3(\n        scale=0.5,\n        model_name=\"large\",\n        class_dim=class_dim,\n        use_custom_relu=use_custom_relu)\n    return model\ndef build_model(config):\n    model_type = config['model_type']\n    if model_type == \"cls\":",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "build_model",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "def build_model(config):\n    model_type = config['model_type']\n    if model_type == \"cls\":\n        class_dim = config['MODEL']['class_dim']\n        use_custom_relu = config['MODEL']['use_custom_relu']\n        if 'siamese' in config['MODEL'] and config['MODEL']['siamese'] is True:\n            model = siamese_mv3(\n                class_dim=class_dim, use_custom_relu=use_custom_relu)\n        else:\n            model = MobileNetV3_large_x0_5(",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "custom_ops",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "peekOfCode": "custom_ops = load(\n    name=\"custom_jit_ops\",\n    sources=[\"./custom_op/custom_relu_op.cc\", \"./custom_op/custom_relu_op.cu\"])\ndef make_divisible(v, divisor=8, min_value=None):\n    if min_value is None:\n        min_value = divisor\n    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)\n    if new_v < 0.9 * v:\n        new_v += divisor\n    return new_v",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.mv3",
        "documentation": {}
    },
    {
        "label": "Cosine",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class Cosine(CosineAnnealingDecay):\n    \"\"\"\n    Cosine learning rate decay\n    lr = 0.05 * (math.cos(epoch * (math.pi / epochs)) + 1)\n    Args:\n        lr(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        epochs(int): total training epochs\n    \"\"\"\n    def __init__(self, lr, step_each_epoch, epochs, **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "Piecewise",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class Piecewise(PiecewiseDecay):\n    \"\"\"\n    Piecewise learning rate decay\n    Args:\n        lr(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        decay_epochs(list): piecewise decay epochs\n        gamma(float): decay factor\n    \"\"\"\n    def __init__(self, lr, step_each_epoch, decay_epochs, gamma=0.1, **kwargs):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "CosineWarmup",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class CosineWarmup(LinearWarmup):\n    \"\"\"\n    Cosine learning rate decay with warmup\n    [0, warmup_epoch): linear warmup\n    [warmup_epoch, epochs): cosine decay\n    Args:\n        lr(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        epochs(int): total training epochs\n        warmup_epoch(int): epoch num of warmup",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "ExponentialWarmup",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class ExponentialWarmup(LinearWarmup):\n    \"\"\"\n    Exponential learning rate decay with warmup\n    [0, warmup_epoch): linear warmup\n    [warmup_epoch, epochs): Exponential decay\n    Args:\n        lr(float): initial learning rate\n        step_each_epoch(int): steps each epoch\n        decay_epochs(float): decay epochs\n        decay_rate(float): decay rate",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "LearningRateBuilder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class LearningRateBuilder():\n    \"\"\"\n    Build learning rate variable\n    https://www.paddlepaddle.org.cn/documentation/docs/zh/api_cn/layers_cn.html\n    Args:\n        function(str): class name of learning rate\n        params(dict): parameters used for init the class\n    \"\"\"\n    def __init__(self,\n                 function='Linear',",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "L1Decay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class L1Decay(object):\n    \"\"\"\n    L1 Weight Decay Regularization, which encourages the weights to be sparse.\n    Args:\n        factor(float): regularization coeff. Default:0.0.\n    \"\"\"\n    def __init__(self, factor=0.0):\n        super(L1Decay, self).__init__()\n        self.factor = factor\n    def __call__(self):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "L2Decay",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class L2Decay(object):\n    \"\"\"\n    L2 Weight Decay Regularization, which encourages the weights to be sparse.\n    Args:\n        factor(float): regularization coeff. Default:0.0.\n    \"\"\"\n    def __init__(self, factor=0.0):\n        super(L2Decay, self).__init__()\n        self.factor = factor\n    def __call__(self):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "Momentum",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class Momentum(object):\n    \"\"\"\n    Simple Momentum optimizer with velocity state.\n    Args:\n        learning_rate (float|Variable) - The learning rate used to update parameters.\n            Can be a float value or a Variable with one float value as data element.\n        momentum (float) - Momentum factor.\n        regularization (WeightDecayRegularizer, optional) - The strategy of regularization.\n    \"\"\"\n    def __init__(self,",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "RMSProp",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class RMSProp(object):\n    \"\"\"\n    Root Mean Squared Propagation (RMSProp) is an unpublished, adaptive learning rate method.\n    Args:\n        learning_rate (float|Variable) - The learning rate used to update parameters.\n            Can be a float value or a Variable with one float value as data element.\n        momentum (float) - Momentum factor.\n        rho (float) - rho value in equation.\n        epsilon (float) - avoid division by zero, default is 1e-6.\n        regularization (WeightDecayRegularizer, optional) - The strategy of regularization.",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "OptimizerBuilder",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "class OptimizerBuilder(object):\n    \"\"\"\n    Build optimizer\n    Args:\n        function(str): optimizer name of learning rate\n        params(dict): parameters used for init the class\n        regularizer (dict): parameters used for create regularization\n    \"\"\"\n    def __init__(self,\n                 function='Momentum',",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "create_optimizer",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "def create_optimizer(config, parameter_list=None):\n    \"\"\"\n    Create an optimizer using config, usually including\n    learning rate and regularization.\n    Args:\n        config(dict):  such as\n        {\n            'LEARNING_RATE':\n                {'function': 'Cosine',\n                 'params': {'lr': 0.1}",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "create_multi_optimizer",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "peekOfCode": "def create_multi_optimizer(config, parameter_list=None):\n    \"\"\"\n    \"\"\"\n    # create learning_rate instance\n    lr_config = config['LEARNING_RATE']\n    lr_config['params'].update({\n        'epochs': config['epoch'],\n        'step_each_epoch':\n        config['total_images'] // config['TRAIN']['batch_size'],\n    })",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.optimizer",
        "documentation": {}
    },
    {
        "label": "save_model",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "peekOfCode": "def save_model(model,\n               optimizer,\n               model_path,\n               logger,\n               is_best=False,\n               prefix='ppocr',\n               **kwargs):\n    \"\"\"\n    save model to the target path\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "documentation": {}
    },
    {
        "label": "amp_scaler",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "peekOfCode": "def amp_scaler(config):\n    if 'AMP' in config and config['AMP']['use_amp'] is True:\n        AMP_RELATED_FLAGS_SETTING = {\n            'FLAGS_cudnn_batchnorm_spatial_persistent': 1,\n            'FLAGS_max_inplace_grad_add': 8,\n        }\n        paddle.set_flags(AMP_RELATED_FLAGS_SETTING)\n        scale_loss = config[\"AMP\"].get(\"scale_loss\", 1.0)\n        use_dynamic_loss_scaling = config[\"AMP\"].get(\"use_dynamic_loss_scaling\",\n                                                     False)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "documentation": {}
    },
    {
        "label": "set_seed",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "peekOfCode": "def set_seed(seed):\n    paddle.seed(seed)\n    np.random.seed(seed)\ndef train(config, scaler=None):\n    EPOCH = config['epoch']\n    topk = config['topk']\n    batch_size = config['TRAIN']['batch_size']\n    num_workers = config['TRAIN']['num_workers']\n    train_loader = build_dataloader(\n        'train', batch_size=batch_size, num_workers=num_workers)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "peekOfCode": "def train(config, scaler=None):\n    EPOCH = config['epoch']\n    topk = config['topk']\n    batch_size = config['TRAIN']['batch_size']\n    num_workers = config['TRAIN']['num_workers']\n    train_loader = build_dataloader(\n        'train', batch_size=batch_size, num_workers=num_workers)\n    # build metric\n    metric_func = create_metric\n    # build model",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "documentation": {}
    },
    {
        "label": "train_distill",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "peekOfCode": "def train_distill(config, scaler=None):\n    EPOCH = config['epoch']\n    topk = config['topk']\n    batch_size = config['TRAIN']['batch_size']\n    num_workers = config['TRAIN']['num_workers']\n    train_loader = build_dataloader(\n        'train', batch_size=batch_size, num_workers=num_workers)\n    # build metric\n    metric_func = create_metric\n    # model = distillmv3_large_x0_5(class_dim=100)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "documentation": {}
    },
    {
        "label": "train_distill_multiopt",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "peekOfCode": "def train_distill_multiopt(config, scaler=None):\n    EPOCH = config['epoch']\n    topk = config['topk']\n    batch_size = config['TRAIN']['batch_size']\n    num_workers = config['TRAIN']['num_workers']\n    train_loader = build_dataloader(\n        'train', batch_size=batch_size, num_workers=num_workers)\n    # build metric\n    metric_func = create_metric\n    # model = distillmv3_large_x0_5(class_dim=100)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "documentation": {}
    },
    {
        "label": "eval",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "peekOfCode": "def eval(config, model):\n    batch_size = config['VALID']['batch_size']\n    num_workers = config['VALID']['num_workers']\n    valid_loader = build_dataloader(\n        'test', batch_size=batch_size, num_workers=num_workers)\n    # build metric\n    metric_func = create_metric\n    outs = []\n    labels = []\n    for idx, data in enumerate(valid_loader):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.train",
        "documentation": {}
    },
    {
        "label": "print_dict",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "peekOfCode": "def print_dict(d, logger, delimiter=0):\n    \"\"\"\n    Recursively visualize a dict and\n    indenting acrrording by the relationship of keys.\n    \"\"\"\n    for k, v in sorted(d.items()):\n        if isinstance(v, dict):\n            logger.info(\"{}{} : \".format(delimiter * \" \", str(k)))\n            print_dict(v, logger, delimiter + 4)\n        elif isinstance(v, list) and len(v) >= 1 and isinstance(v[0], dict):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "peekOfCode": "def get_logger(name='root', log_file=None, log_level=logging.DEBUG):\n    \"\"\"Initialize and get a logger by name.\n    If the logger has not been initialized, this method will initialize the\n    logger by adding one or two handlers, otherwise the initialized logger will\n    be directly returned. During initialization, a StreamHandler will always be\n    added. If `log_file` is specified a FileHandler will also be added.\n    Args:\n        name (str): Logger name.\n        log_file (str | None): The log filename. If specified, a FileHandler\n            will be added to the logger.",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "documentation": {}
    },
    {
        "label": "load_model",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "peekOfCode": "def load_model(config, model, optimizer=None):\n    \"\"\"\n    load model from checkpoint or pretrained_model\n    \"\"\"\n    logger = get_logger()\n    checkpoints = config.get('checkpoints')\n    pretrained_model = config.get('pretrained_model')\n    best_model_dict = {}\n    if checkpoints:\n        if checkpoints.endswith('.pdparams'):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "documentation": {}
    },
    {
        "label": "load_pretrained_params",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "peekOfCode": "def load_pretrained_params(model, path):\n    logger = get_logger()\n    if path.endswith('.pdparams'):\n        path = path.replace('.pdparams', '')\n    assert os.path.exists(path + \".pdparams\"), \\\n        \"The {}.pdparams does not exists!\".format(path)\n    params = paddle.load(path + '.pdparams')\n    state_dict = model.state_dict()\n    new_state_dict = {}\n    for k1 in params.keys():",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "documentation": {}
    },
    {
        "label": "logger_initialized",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "peekOfCode": "logger_initialized = {}\ndef print_dict(d, logger, delimiter=0):\n    \"\"\"\n    Recursively visualize a dict and\n    indenting acrrording by the relationship of keys.\n    \"\"\"\n    for k, v in sorted(d.items()):\n        if isinstance(v, dict):\n            logger.info(\"{}{} : \".format(delimiter * \" \", str(k)))\n            print_dict(v, logger, delimiter + 4)",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.supplementary.utils",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def init_args():\n    parser = argparse.ArgumentParser()\n    # params for testing assert allclose\n    parser.add_argument(\"--atol\", type=float, default=1e-3)\n    parser.add_argument(\"--rtol\", type=float, default=1e-3)\n    parser.add_argument(\"--gt_file\", type=str, default=\"\")\n    parser.add_argument(\"--log_file\", type=str, default=\"\")\n    parser.add_argument(\"--precision\", type=str, default=\"fp32\")\n    return parser\ndef parse_args():",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def parse_args():\n    parser = init_args()\n    return parser.parse_args()\ndef run_shell_command(cmd):\n    p = subprocess.Popen(\n        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    out, err = p.communicate()\n    if p.returncode == 0:\n        return out.decode('utf-8')\n    else:",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "run_shell_command",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def run_shell_command(cmd):\n    p = subprocess.Popen(\n        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    out, err = p.communicate()\n    if p.returncode == 0:\n        return out.decode('utf-8')\n    else:\n        return None\ndef parser_results_from_log_by_name(log_path, names_list):\n    if not os.path.exists(log_path):",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "parser_results_from_log_by_name",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def parser_results_from_log_by_name(log_path, names_list):\n    if not os.path.exists(log_path):\n        raise ValueError(\"The log file {} does not exists!\".format(log_path))\n    if names_list is None or len(names_list) < 1:\n        return []\n    parser_results = {}\n    for name in names_list:\n        cmd = \"grep {} {}\".format(name, log_path)\n        outs = run_shell_command(cmd)\n        outs = outs.split(\"\\n\")[0]",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "load_gt_from_file",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def load_gt_from_file(gt_file):\n    if not os.path.exists(gt_file):\n        raise ValueError(\"The log file {} does not exists!\".format(gt_file))\n    with open(gt_file, 'r') as f:\n        data = f.readlines()\n        f.close()\n    parser_gt = {}\n    for line in data:\n        image_name, result = line.strip(\"\\n\").split(\"\\t\")\n        image_name = image_name.split('/')[-1]",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "load_gt_from_txts",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def load_gt_from_txts(gt_file):\n    gt_list = glob.glob(gt_file)\n    gt_collection = {}\n    for gt_f in gt_list:\n        gt_dict = load_gt_from_file(gt_f)\n        basename = os.path.basename(gt_f)\n        if \"fp32\" in basename:\n            gt_collection[\"fp32\"] = [gt_dict, gt_f]\n        elif \"fp16\" in basename:\n            gt_collection[\"fp16\"] = [gt_dict, gt_f]",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "collect_predict_from_logs",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def collect_predict_from_logs(log_path, key_list):\n    log_list = glob.glob(log_path)\n    pred_collection = {}\n    for log_f in log_list:\n        pred_dict = parser_results_from_log_by_name(log_f, key_list)\n        key = os.path.basename(log_f)\n        pred_collection[key] = pred_dict\n    return pred_collection\ndef testing_assert_allclose(dict_x, dict_y, atol=1e-7, rtol=1e-7):\n    for k in dict_x:",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "testing_assert_allclose",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "description": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "peekOfCode": "def testing_assert_allclose(dict_x, dict_y, atol=1e-7, rtol=1e-7):\n    for k in dict_x:\n        np.testing.assert_allclose(\n            np.array(dict_x[k]), np.array(dict_y[k]), atol=atol, rtol=rtol)\nif __name__ == \"__main__\":\n    # Usage:\n    # python3.7 tests/compare_results.py --gt_file=./tests/results/*.txt  --log_file=./tests/output/infer_*.log\n    args = parse_args()\n    gt_collection = load_gt_from_txts(args.gt_file)\n    key_list = gt_collection[\"fp32\"][0].keys()",
        "detail": "Vision.Paddle.PaddleOCR.test_tipc.compare_results",
        "documentation": {}
    },
    {
        "label": "poly_to_string",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "peekOfCode": "def poly_to_string(poly):\n    if len(poly.shape) > 1:\n        poly = np.array(poly).flatten()\n    string = \"\\t\".join(str(i) for i in poly)\n    return string\ndef convert_label(label_dir, mode=\"gt\", save_dir=\"./save_results/\"):\n    if not os.path.exists(label_dir):\n        raise ValueError(f\"The file {label_dir} does not exist!\")\n    assert label_dir != save_dir, \"hahahhaha\"\n    label_file = open(label_dir, 'r')",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "documentation": {}
    },
    {
        "label": "convert_label",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "peekOfCode": "def convert_label(label_dir, mode=\"gt\", save_dir=\"./save_results/\"):\n    if not os.path.exists(label_dir):\n        raise ValueError(f\"The file {label_dir} does not exist!\")\n    assert label_dir != save_dir, \"hahahhaha\"\n    label_file = open(label_dir, 'r')\n    data = label_file.readlines()\n    gt_dict = {}\n    for line in data:\n        try:\n            tmp = line.split('\\t')",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "peekOfCode": "def parse_args():\n    import argparse\n    parser = argparse.ArgumentParser(description=\"args\")\n    parser.add_argument(\"--label_path\", type=str, required=True)\n    parser.add_argument(\"--save_folder\", type=str, required=True)\n    parser.add_argument(\"--mode\", type=str, default=False)\n    args = parser.parse_args()\n    return args\nif __name__ == \"__main__\":\n    args = parse_args()",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.convert_ppocr_label",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "peekOfCode": "def str2bool(v):\n    return v.lower() in (\"true\", \"t\", \"1\")\ndef init_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--image_dir\", type=str, default=\"\")\n    parser.add_argument(\"--save_html_path\", type=str, default=\"./default.html\")\n    parser.add_argument(\"--width\", type=int, default=640)\n    return parser\ndef parse_args():\n    parser = init_args()",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "peekOfCode": "def init_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--image_dir\", type=str, default=\"\")\n    parser.add_argument(\"--save_html_path\", type=str, default=\"./default.html\")\n    parser.add_argument(\"--width\", type=int, default=640)\n    return parser\ndef parse_args():\n    parser = init_args()\n    return parser.parse_args()\ndef draw_debug_img(args):",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "peekOfCode": "def parse_args():\n    parser = init_args()\n    return parser.parse_args()\ndef draw_debug_img(args):\n    html_path = args.save_html_path\n    err_cnt = 0\n    with open(html_path, 'w') as html:\n        html.write('<html>\\n<body>\\n')\n        html.write('<table border=\"1\">\\n')\n        html.write(",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "documentation": {}
    },
    {
        "label": "draw_debug_img",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "peekOfCode": "def draw_debug_img(args):\n    html_path = args.save_html_path\n    err_cnt = 0\n    with open(html_path, 'w') as html:\n        html.write('<html>\\n<body>\\n')\n        html.write('<table border=\"1\">\\n')\n        html.write(\n            \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\" />\"\n        )\n        image_list = []",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.draw_html",
        "documentation": {}
    },
    {
        "label": "strQ2B",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "peekOfCode": "def strQ2B(ustring):\n    rstring = \"\"\n    for uchar in ustring:\n        inside_code = ord(uchar)\n        if inside_code == 12288:\n            inside_code = 32\n        elif (inside_code >= 65281 and inside_code <= 65374):\n            inside_code -= 65248\n        rstring += chr(inside_code)\n    return rstring",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "documentation": {}
    },
    {
        "label": "polygon_from_str",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "peekOfCode": "def polygon_from_str(polygon_points):\n    \"\"\"\n    Create a shapely polygon object from gt or dt line.\n    \"\"\"\n    polygon_points = np.array(polygon_points).reshape(4, 2)\n    polygon = Polygon(polygon_points).convex_hull\n    return polygon\ndef polygon_iou(poly1, poly2):\n    \"\"\"\n    Intersection over union between two shapely polygons.",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "documentation": {}
    },
    {
        "label": "polygon_iou",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "peekOfCode": "def polygon_iou(poly1, poly2):\n    \"\"\"\n    Intersection over union between two shapely polygons.\n    \"\"\"\n    if not poly1.intersects(\n            poly2):  # this test is fast and can accelerate calculation\n        iou = 0\n    else:\n        try:\n            inter_area = poly1.intersection(poly2).area",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "documentation": {}
    },
    {
        "label": "ed",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "peekOfCode": "def ed(str1, str2):\n    return editdistance.eval(str1, str2)\ndef e2e_eval(gt_dir, res_dir, ignore_blank=False):\n    print('start testing...')\n    iou_thresh = 0.5\n    val_names = os.listdir(gt_dir)\n    num_gt_chars = 0\n    gt_count = 0\n    dt_count = 0\n    hit = 0",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "documentation": {}
    },
    {
        "label": "e2e_eval",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "description": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "peekOfCode": "def e2e_eval(gt_dir, res_dir, ignore_blank=False):\n    print('start testing...')\n    iou_thresh = 0.5\n    val_names = os.listdir(gt_dir)\n    num_gt_chars = 0\n    gt_count = 0\n    dt_count = 0\n    hit = 0\n    ed_sum = 0\n    for i, val_name in enumerate(val_names):",
        "detail": "Vision.Paddle.PaddleOCR.tools.end2end.eval_end2end",
        "documentation": {}
    },
    {
        "label": "TextClassifier",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "peekOfCode": "class TextClassifier(object):\n    def __init__(self, args):\n        self.cls_image_shape = [int(v) for v in args.cls_image_shape.split(\",\")]\n        self.cls_batch_num = args.cls_batch_num\n        self.cls_thresh = args.cls_thresh\n        postprocess_params = {\n            'name': 'ClsPostProcess',\n            \"label_list\": args.label_list,\n        }\n        self.postprocess_op = build_post_process(postprocess_params)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    text_classifier = TextClassifier(args)\n    valid_image_file_list = []\n    img_list = []\n    for image_file in image_file_list:\n        img, flag, _ = check_and_read(image_file)\n        if not flag:\n            img = cv2.imread(image_file)\n        if img is None:",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport copy\nimport numpy as np\nimport math\nimport time\nimport traceback",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport copy\nimport numpy as np\nimport math\nimport time\nimport traceback\nimport tools.infer.utility as utility\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.logging import get_logger",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "peekOfCode": "logger = get_logger()\nclass TextClassifier(object):\n    def __init__(self, args):\n        self.cls_image_shape = [int(v) for v in args.cls_image_shape.split(\",\")]\n        self.cls_batch_num = args.cls_batch_num\n        self.cls_thresh = args.cls_thresh\n        postprocess_params = {\n            'name': 'ClsPostProcess',\n            \"label_list\": args.label_list,\n        }",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_cls",
        "documentation": {}
    },
    {
        "label": "TextDetector",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "peekOfCode": "class TextDetector(object):\n    def __init__(self, args):\n        self.args = args\n        self.det_algorithm = args.det_algorithm\n        self.use_onnx = args.use_onnx\n        pre_process_list = [{\n            'DetResizeForTest': {\n                'limit_side_len': args.det_limit_side_len,\n                'limit_type': args.det_limit_type,\n            }",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport sys\nimport tools.infer.utility as utility\nfrom ppocr.utils.logging import get_logger",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport sys\nimport tools.infer.utility as utility\nfrom ppocr.utils.logging import get_logger\nfrom ppocr.utils.utility import get_image_file_list, check_and_read\nfrom ppocr.data import create_operators, transform\nfrom ppocr.postprocess import build_post_process",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "peekOfCode": "logger = get_logger()\nclass TextDetector(object):\n    def __init__(self, args):\n        self.args = args\n        self.det_algorithm = args.det_algorithm\n        self.use_onnx = args.use_onnx\n        pre_process_list = [{\n            'DetResizeForTest': {\n                'limit_side_len': args.det_limit_side_len,\n                'limit_type': args.det_limit_type,",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_det",
        "documentation": {}
    },
    {
        "label": "TextE2E",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "peekOfCode": "class TextE2E(object):\n    def __init__(self, args):\n        self.args = args\n        self.e2e_algorithm = args.e2e_algorithm\n        self.use_onnx = args.use_onnx\n        pre_process_list = [{\n            'E2EResizeForTest': {}\n        }, {\n            'NormalizeImage': {\n                'std': [0.229, 0.224, 0.225],",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport sys\nimport tools.infer.utility as utility\nfrom ppocr.utils.logging import get_logger",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport time\nimport sys\nimport tools.infer.utility as utility\nfrom ppocr.utils.logging import get_logger\nfrom ppocr.utils.utility import get_image_file_list, check_and_read\nfrom ppocr.data import create_operators, transform\nfrom ppocr.postprocess import build_post_process",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "peekOfCode": "logger = get_logger()\nclass TextE2E(object):\n    def __init__(self, args):\n        self.args = args\n        self.e2e_algorithm = args.e2e_algorithm\n        self.use_onnx = args.use_onnx\n        pre_process_list = [{\n            'E2EResizeForTest': {}\n        }, {\n            'NormalizeImage': {",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_e2e",
        "documentation": {}
    },
    {
        "label": "TextRecognizer",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "peekOfCode": "class TextRecognizer(object):\n    def __init__(self, args):\n        self.rec_image_shape = [int(v) for v in args.rec_image_shape.split(\",\")]\n        self.rec_batch_num = args.rec_batch_num\n        self.rec_algorithm = args.rec_algorithm\n        postprocess_params = {\n            'name': 'CTCLabelDecode',\n            \"character_dict_path\": args.rec_char_dict_path,\n            \"use_space_char\": args.use_space_char\n        }",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    text_recognizer = TextRecognizer(args)\n    valid_image_file_list = []\n    img_list = []\n    logger.info(\n        \"In PP-OCRv3, rec_image_shape parameter defaults to '3, 48, 320', \"\n        \"if you are using recognition model with PP-OCRv2 or an older version, please set --rec_image_shape='3,32,320\"\n    )\n    # warmup 2 times",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport math\nimport time\nimport traceback\nimport paddle",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport math\nimport time\nimport traceback\nimport paddle\nimport tools.infer.utility as utility\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.logging import get_logger",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "peekOfCode": "logger = get_logger()\nclass TextRecognizer(object):\n    def __init__(self, args):\n        self.rec_image_shape = [int(v) for v in args.rec_image_shape.split(\",\")]\n        self.rec_batch_num = args.rec_batch_num\n        self.rec_algorithm = args.rec_algorithm\n        postprocess_params = {\n            'name': 'CTCLabelDecode',\n            \"character_dict_path\": args.rec_char_dict_path,\n            \"use_space_char\": args.use_space_char",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_rec",
        "documentation": {}
    },
    {
        "label": "TextSR",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "peekOfCode": "class TextSR(object):\n    def __init__(self, args):\n        self.sr_image_shape = [int(v) for v in args.sr_image_shape.split(\",\")]\n        self.sr_batch_num = args.sr_batch_num\n        self.predictor, self.input_tensor, self.output_tensors, self.config = \\\n            utility.create_predictor(args, 'sr', logger)\n        self.benchmark = args.benchmark\n        if args.benchmark:\n            import auto_log\n            pid = os.getpid()",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    text_recognizer = TextSR(args)\n    valid_image_file_list = []\n    img_list = []\n    # warmup 2 times\n    if args.warmup:\n        img = np.random.uniform(0, 255, [16, 64, 3]).astype(np.uint8)\n        for i in range(2):\n            res = text_recognizer([img] * int(args.sr_batch_num))",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, __dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport math\nimport time\nimport traceback\nimport paddle",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport numpy as np\nimport math\nimport time\nimport traceback\nimport paddle\nimport tools.infer.utility as utility\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.logging import get_logger",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "peekOfCode": "logger = get_logger()\nclass TextSR(object):\n    def __init__(self, args):\n        self.sr_image_shape = [int(v) for v in args.sr_image_shape.split(\",\")]\n        self.sr_batch_num = args.sr_batch_num\n        self.predictor, self.input_tensor, self.output_tensors, self.config = \\\n            utility.create_predictor(args, 'sr', logger)\n        self.benchmark = args.benchmark\n        if args.benchmark:\n            import auto_log",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_sr",
        "documentation": {}
    },
    {
        "label": "TextSystem",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "peekOfCode": "class TextSystem(object):\n    def __init__(self, args):\n        if not args.show_log:\n            logger.setLevel(logging.INFO)\n        self.text_detector = predict_det.TextDetector(args)\n        self.text_recognizer = predict_rec.TextRecognizer(args)\n        self.use_angle_cls = args.use_angle_cls\n        self.drop_score = args.drop_score\n        if self.use_angle_cls:\n            self.text_classifier = predict_cls.TextClassifier(args)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "sorted_boxes",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "peekOfCode": "def sorted_boxes(dt_boxes):\n    \"\"\"\n    Sort text boxes in order from top to bottom, left to right\n    args:\n        dt_boxes(array):detected text boxes with shape [4, 2]\n    return:\n        sorted boxes(array) with shape [4, 2]\n    \"\"\"\n    num_boxes = dt_boxes.shape[0]\n    sorted_boxes = sorted(dt_boxes, key=lambda x: (x[0][1], x[0][0]))",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    image_file_list = image_file_list[args.process_id::args.total_process_num]\n    text_sys = TextSystem(args)\n    is_visualize = True\n    font_path = args.vis_font_path\n    drop_score = args.drop_score\n    draw_img_save_dir = args.draw_img_save_dir\n    os.makedirs(draw_img_save_dir, exist_ok=True)\n    save_results = []",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '../..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport copy\nimport numpy as np\nimport json\nimport time\nimport logging",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport copy\nimport numpy as np\nimport json\nimport time\nimport logging\nfrom PIL import Image\nimport tools.infer.utility as utility\nimport tools.infer.predict_rec as predict_rec",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "peekOfCode": "logger = get_logger()\nclass TextSystem(object):\n    def __init__(self, args):\n        if not args.show_log:\n            logger.setLevel(logging.INFO)\n        self.text_detector = predict_det.TextDetector(args)\n        self.text_recognizer = predict_rec.TextRecognizer(args)\n        self.use_angle_cls = args.use_angle_cls\n        self.drop_score = args.drop_score\n        if self.use_angle_cls:",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.predict_system",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def str2bool(v):\n    return v.lower() in (\"true\", \"yes\", \"t\", \"y\", \"1\")\ndef str2int_tuple(v):\n    return tuple([int(i.strip()) for i in v.split(\",\")])\ndef init_args():\n    parser = argparse.ArgumentParser()\n    # params for prediction engine\n    parser.add_argument(\"--use_gpu\", type=str2bool, default=True)\n    parser.add_argument(\"--use_xpu\", type=str2bool, default=False)\n    parser.add_argument(\"--use_npu\", type=str2bool, default=False)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "str2int_tuple",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def str2int_tuple(v):\n    return tuple([int(i.strip()) for i in v.split(\",\")])\ndef init_args():\n    parser = argparse.ArgumentParser()\n    # params for prediction engine\n    parser.add_argument(\"--use_gpu\", type=str2bool, default=True)\n    parser.add_argument(\"--use_xpu\", type=str2bool, default=False)\n    parser.add_argument(\"--use_npu\", type=str2bool, default=False)\n    parser.add_argument(\"--ir_optim\", type=str2bool, default=True)\n    parser.add_argument(\"--use_tensorrt\", type=str2bool, default=False)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "init_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def init_args():\n    parser = argparse.ArgumentParser()\n    # params for prediction engine\n    parser.add_argument(\"--use_gpu\", type=str2bool, default=True)\n    parser.add_argument(\"--use_xpu\", type=str2bool, default=False)\n    parser.add_argument(\"--use_npu\", type=str2bool, default=False)\n    parser.add_argument(\"--ir_optim\", type=str2bool, default=True)\n    parser.add_argument(\"--use_tensorrt\", type=str2bool, default=False)\n    parser.add_argument(\"--min_subgraph_size\", type=int, default=15)\n    parser.add_argument(\"--precision\", type=str, default=\"fp32\")",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def parse_args():\n    parser = init_args()\n    return parser.parse_args()\ndef create_predictor(args, mode, logger):\n    if mode == \"det\":\n        model_dir = args.det_model_dir\n    elif mode == 'cls':\n        model_dir = args.cls_model_dir\n    elif mode == 'rec':\n        model_dir = args.rec_model_dir",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "create_predictor",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def create_predictor(args, mode, logger):\n    if mode == \"det\":\n        model_dir = args.det_model_dir\n    elif mode == 'cls':\n        model_dir = args.cls_model_dir\n    elif mode == 'rec':\n        model_dir = args.rec_model_dir\n    elif mode == 'table':\n        model_dir = args.table_model_dir\n    elif mode == 'ser':",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "get_output_tensors",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def get_output_tensors(args, mode, predictor):\n    output_names = predictor.get_output_names()\n    output_tensors = []\n    if mode == \"rec\" and args.rec_algorithm in [\n            \"CRNN\", \"SVTR_LCNet\", \"SVTR_HGNet\"\n    ]:\n        output_name = 'softmax_0.tmp_0'\n        if output_name in output_names:\n            return [predictor.get_output_handle(output_name)]\n        else:",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "get_infer_gpuid",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def get_infer_gpuid():\n    sysstr = platform.system()\n    if sysstr == \"Windows\":\n        return 0\n    if not paddle.device.is_compiled_with_rocm:\n        cmd = \"env | grep CUDA_VISIBLE_DEVICES\"\n    else:\n        cmd = \"env | grep HIP_VISIBLE_DEVICES\"\n    env_cuda = os.popen(cmd).readlines()\n    if len(env_cuda) == 0:",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_e2e_res",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def draw_e2e_res(dt_boxes, strs, img_path):\n    src_im = cv2.imread(img_path)\n    for box, str in zip(dt_boxes, strs):\n        box = box.astype(np.int32).reshape((-1, 1, 2))\n        cv2.polylines(src_im, [box], True, color=(255, 255, 0), thickness=2)\n        cv2.putText(\n            src_im,\n            str,\n            org=(int(box[0, 0, 0]), int(box[0, 0, 1])),\n            fontFace=cv2.FONT_HERSHEY_COMPLEX,",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_text_det_res",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def draw_text_det_res(dt_boxes, img):\n    for box in dt_boxes:\n        box = np.array(box).astype(np.int32).reshape(-1, 2)\n        cv2.polylines(img, [box], True, color=(255, 255, 0), thickness=2)\n    return img\ndef resize_img(img, input_size=600):\n    \"\"\"\n    resize img and limit the longest side of the image to input_size\n    \"\"\"\n    img = np.array(img)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "resize_img",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def resize_img(img, input_size=600):\n    \"\"\"\n    resize img and limit the longest side of the image to input_size\n    \"\"\"\n    img = np.array(img)\n    im_shape = img.shape\n    im_size_max = np.max(im_shape[0:2])\n    im_scale = float(input_size) / float(im_size_max)\n    img = cv2.resize(img, None, None, fx=im_scale, fy=im_scale)\n    return img",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_ocr",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def draw_ocr(image,\n             boxes,\n             txts=None,\n             scores=None,\n             drop_score=0.5,\n             font_path=\"./doc/fonts/simfang.ttf\"):\n    \"\"\"\n    Visualize the results of OCR detection and recognition\n    args:\n        image(Image|array): RGB image",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_ocr_box_txt",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def draw_ocr_box_txt(image,\n                     boxes,\n                     txts=None,\n                     scores=None,\n                     drop_score=0.5,\n                     font_path=\"./doc/fonts/simfang.ttf\"):\n    h, w = image.height, image.width\n    img_left = image.copy()\n    img_right = np.ones((h, w, 3), dtype=np.uint8) * 255\n    random.seed(0)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_box_txt_fine",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def draw_box_txt_fine(img_size, box, txt, font_path=\"./doc/fonts/simfang.ttf\"):\n    box_height = int(\n        math.sqrt((box[0][0] - box[3][0])**2 + (box[0][1] - box[3][1])**2))\n    box_width = int(\n        math.sqrt((box[0][0] - box[1][0])**2 + (box[0][1] - box[1][1])**2))\n    if box_height > 2 * box_width and box_height > 30:\n        img_text = Image.new('RGB', (box_height, box_width), (255, 255, 255))\n        draw_text = ImageDraw.Draw(img_text)\n        if txt:\n            font = create_font(txt, (box_height, box_width), font_path)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "create_font",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def create_font(txt, sz, font_path=\"./doc/fonts/simfang.ttf\"):\n    font_size = int(sz[1] * 0.99)\n    font = ImageFont.truetype(font_path, font_size, encoding=\"utf-8\")\n    length = font.getlength(txt)\n    if length > sz[0]:\n        font_size = int(font_size * sz[0] / length)\n        font = ImageFont.truetype(font_path, font_size, encoding=\"utf-8\")\n    return font\ndef str_count(s):\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "str_count",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def str_count(s):\n    \"\"\"\n    Count the number of Chinese characters,\n    a single English character and a single number\n    equal to half the length of Chinese characters.\n    args:\n        s(string): the input of string\n    return(int):\n        the number of Chinese characters\n    \"\"\"",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "text_visual",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def text_visual(texts,\n                scores,\n                img_h=400,\n                img_w=600,\n                threshold=0.,\n                font_path=\"./doc/simfang.ttf\"):\n    \"\"\"\n    create new blank img and draw txt on it\n    args:\n        texts(list): the text will be draw",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "base64_to_cv2",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def base64_to_cv2(b64str):\n    import base64\n    data = base64.b64decode(b64str.encode('utf8'))\n    data = np.frombuffer(data, np.uint8)\n    data = cv2.imdecode(data, cv2.IMREAD_COLOR)\n    return data\ndef draw_boxes(image, boxes, scores=None, drop_score=0.5):\n    if scores is None:\n        scores = [1] * len(boxes)\n    for (box, score) in zip(boxes, scores):",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "draw_boxes",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def draw_boxes(image, boxes, scores=None, drop_score=0.5):\n    if scores is None:\n        scores = [1] * len(boxes)\n    for (box, score) in zip(boxes, scores):\n        if score < drop_score:\n            continue\n        box = np.reshape(np.array(box), [-1, 1, 2]).astype(np.int64)\n        image = cv2.polylines(np.array(image), [box], True, (255, 0, 0), 2)\n    return image\ndef get_rotate_crop_image(img, points):",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "get_rotate_crop_image",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def get_rotate_crop_image(img, points):\n    '''\n    img_height, img_width = img.shape[0:2]\n    left = int(np.min(points[:, 0]))\n    right = int(np.max(points[:, 0]))\n    top = int(np.min(points[:, 1]))\n    bottom = int(np.max(points[:, 1]))\n    img_crop = img[top:bottom, left:right, :].copy()\n    points[:, 0] = points[:, 0] - left\n    points[:, 1] = points[:, 1] - top",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "get_minarea_rect_crop",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def get_minarea_rect_crop(img, points):\n    bounding_box = cv2.minAreaRect(np.array(points).astype(np.int32))\n    points = sorted(list(cv2.boxPoints(bounding_box)), key=lambda x: x[0])\n    index_a, index_b, index_c, index_d = 0, 1, 2, 3\n    if points[1][1] > points[0][1]:\n        index_a = 0\n        index_d = 1\n    else:\n        index_a = 1\n        index_d = 0",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "check_gpu",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "description": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "peekOfCode": "def check_gpu(use_gpu):\n    if use_gpu and not paddle.is_compiled_with_cuda():\n        use_gpu = False\n    return use_gpu\nif __name__ == '__main__':\n    pass",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer.utility",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.eval",
        "description": "Vision.Paddle.PaddleOCR.tools.eval",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build dataloader\n    set_signal_handlers()\n    valid_dataloader = build_dataloader(config, 'Eval', device, logger)\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n    # build model\n    # for rec algorithm",
        "detail": "Vision.Paddle.PaddleOCR.tools.eval",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.eval",
        "description": "Vision.Paddle.PaddleOCR.tools.eval",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, __dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nimport paddle\nfrom ppocr.data import build_dataloader, set_signal_handlers\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.metrics import build_metric\nfrom ppocr.utils.save_load import load_model\nimport tools.program as program",
        "detail": "Vision.Paddle.PaddleOCR.tools.eval",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.export_center",
        "description": "Vision.Paddle.PaddleOCR.tools.export_center",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build dataloader\n    config['Eval']['dataset']['name'] = config['Train']['dataset']['name']\n    config['Eval']['dataset']['data_dir'] = config['Train']['dataset'][\n        'data_dir']\n    config['Eval']['dataset']['label_file_list'] = config['Train']['dataset'][\n        'label_file_list']\n    set_signal_handlers()\n    eval_dataloader = build_dataloader(config, 'Eval', device, logger)",
        "detail": "Vision.Paddle.PaddleOCR.tools.export_center",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.export_center",
        "description": "Vision.Paddle.PaddleOCR.tools.export_center",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.append(os.path.abspath(os.path.join(__dir__, '..')))\nfrom ppocr.data import build_dataloader, set_signal_handlers\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import print_dict\nimport tools.program as program\ndef main():",
        "detail": "Vision.Paddle.PaddleOCR.tools.export_center",
        "documentation": {}
    },
    {
        "label": "export_single_model",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.export_model",
        "description": "Vision.Paddle.PaddleOCR.tools.export_model",
        "peekOfCode": "def export_single_model(model,\n                        arch_config,\n                        save_path,\n                        logger,\n                        input_shape=None,\n                        quanter=None):\n    if arch_config[\"algorithm\"] == \"SRN\":\n        max_text_length = arch_config[\"Head\"][\"max_text_length\"]\n        other_shape = [\n            paddle.static.InputSpec(",
        "detail": "Vision.Paddle.PaddleOCR.tools.export_model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.export_model",
        "description": "Vision.Paddle.PaddleOCR.tools.export_model",
        "peekOfCode": "def main():\n    FLAGS = ArgsParser().parse_args()\n    config = load_config(FLAGS.config)\n    config = merge_config(config, FLAGS.opt)\n    logger = get_logger()\n    # build post process\n    post_process_class = build_post_process(config[\"PostProcess\"],\n                                            config[\"Global\"])\n    # build model\n    # for rec algorithm",
        "detail": "Vision.Paddle.PaddleOCR.tools.export_model",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.export_model",
        "description": "Vision.Paddle.PaddleOCR.tools.export_model",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, \"..\")))\nimport argparse\nimport paddle\nfrom paddle.jit import to_static\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.logging import get_logger",
        "detail": "Vision.Paddle.PaddleOCR.tools.export_model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n    # build model\n    model = build_model(config['Architecture'])\n    load_model(config, model)\n    # create data ops\n    transforms = []",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list\nimport tools.program as program\ndef main():\n    global_config = config['Global']",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_cls",
        "documentation": {}
    },
    {
        "label": "draw_det_res",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "peekOfCode": "def draw_det_res(dt_boxes, config, img, img_name, save_path):\n    import cv2\n    src_im = img\n    for box in dt_boxes:\n        box = np.array(box).astype(np.int32).reshape((-1, 1, 2))\n        cv2.polylines(src_im, [box], True, color=(255, 255, 0), thickness=2)\n    if not os.path.exists(save_path):\n        os.makedirs(save_path)\n    save_path = os.path.join(save_path, os.path.basename(img_name))\n    cv2.imwrite(save_path, src_im)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build model\n    model = build_model(config['Architecture'])\n    load_model(config, model)\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'])\n    # create data ops\n    transforms = []\n    for op in config['Eval']['dataset']['transforms']:",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list\nimport tools.program as program",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_det",
        "documentation": {}
    },
    {
        "label": "draw_e2e_res_for_chinese",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "peekOfCode": "def draw_e2e_res_for_chinese(image,\n                             boxes,\n                             txts,\n                             config,\n                             img_name,\n                             font_path=\"./doc/simfang.ttf\"):\n    h, w = image.height, image.width\n    img_left = image.copy()\n    img_right = Image.new('RGB', (w, h), (255, 255, 255))\n    import random",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "documentation": {}
    },
    {
        "label": "draw_e2e_res",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "peekOfCode": "def draw_e2e_res(dt_boxes, strs, config, img, img_name):\n    if len(dt_boxes) > 0:\n        src_im = img\n        for box, str in zip(dt_boxes, strs):\n            box = box.astype(np.int32).reshape((-1, 1, 2))\n            cv2.polylines(src_im, [box], True, color=(255, 255, 0), thickness=2)\n            cv2.putText(\n                src_im,\n                str,\n                org=(int(box[0, 0, 0]), int(box[0, 0, 1])),",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build model\n    model = build_model(config['Architecture'])\n    load_model(config, model)\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n    # create data ops\n    transforms = []",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list\nimport tools.program as program",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_e2e",
        "documentation": {}
    },
    {
        "label": "read_class_list",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "peekOfCode": "def read_class_list(filepath):\n    ret = {}\n    with open(filepath, \"r\") as f:\n        lines = f.readlines()\n        for idx, line in enumerate(lines):\n            ret[idx] = line.strip(\"\\n\")\n    return ret\ndef draw_kie_result(batch, node, idx_to_cls, count):\n    img = batch[6].copy()\n    boxes = batch[7]",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "documentation": {}
    },
    {
        "label": "draw_kie_result",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "peekOfCode": "def draw_kie_result(batch, node, idx_to_cls, count):\n    img = batch[6].copy()\n    boxes = batch[7]\n    h, w = img.shape[:2]\n    pred_img = np.ones((h, w * 2, 3), dtype=np.uint8) * 255\n    max_value, max_idx = paddle.max(node, -1), paddle.argmax(node, -1)\n    node_pred_label = max_idx.numpy().tolist()\n    node_pred_score = max_value.numpy().tolist()\n    for i, box in enumerate(boxes):\n        if i >= len(node_pred_label):",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "documentation": {}
    },
    {
        "label": "write_kie_result",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "peekOfCode": "def write_kie_result(fout, node, data):\n    \"\"\"\n    Write infer result to output file, sorted by the predict label of each line.\n    The format keeps the same as the input with additional score attribute.\n    \"\"\"\n    import json\n    label = data['label']\n    annotations = json.loads(label)\n    max_value, max_idx = paddle.max(node, -1), paddle.argmax(node, -1)\n    node_pred_label = max_idx.numpy().tolist()",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build model\n    model = build_model(config['Architecture'])\n    load_model(config, model)\n    # create data ops\n    transforms = []\n    for op in config['Eval']['dataset']['transforms']:\n        transforms.append(op)\n    data_dir = config['Eval']['dataset']['data_dir']",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.utils.save_load import load_model\nimport tools.program as program",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.utils.save_load import load_model\nimport tools.program as program\nimport time\ndef read_class_list(filepath):\n    ret = {}",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie",
        "documentation": {}
    },
    {
        "label": "SerPredictor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "peekOfCode": "class SerPredictor(object):\n    def __init__(self, config):\n        global_config = config['Global']\n        self.algorithm = config['Architecture'][\"algorithm\"]\n        # build post process\n        self.post_process_class = build_post_process(config['PostProcess'],\n                                                     global_config)\n        # build model\n        self.model = build_model(config['Architecture'])\n        load_model(",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "to_tensor",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "peekOfCode": "def to_tensor(data):\n    import numbers\n    from collections import defaultdict\n    data_dict = defaultdict(list)\n    to_tensor_idxs = []\n    for idx, v in enumerate(data):\n        if isinstance(v, (np.ndarray, paddle.Tensor, numbers.Number)):\n            if idx not in to_tensor_idxs:\n                to_tensor_idxs.append(idx)\n        data_dict[idx].append(v)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.visual import draw_ser_results\nfrom ppocr.utils.utility import get_image_file_list, load_vqa_bio_label_maps",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser",
        "documentation": {}
    },
    {
        "label": "ReArgsParser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "peekOfCode": "class ReArgsParser(ArgsParser):\n    def __init__(self):\n        super(ReArgsParser, self).__init__()\n        self.add_argument(\n            \"-c_ser\", \"--config_ser\", help=\"ser configuration file to use\")\n        self.add_argument(\n            \"-o_ser\",\n            \"--opt_ser\",\n            nargs='+',\n            help=\"set ser configuration options \")",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "SerRePredictor",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "peekOfCode": "class SerRePredictor(object):\n    def __init__(self, config, ser_config):\n        global_config = config['Global']\n        if \"infer_mode\" in global_config:\n            ser_config[\"Global\"][\"infer_mode\"] = global_config[\"infer_mode\"]\n        self.ser_engine = SerPredictor(ser_config)\n        #  init re model \n        # build post process\n        self.post_process_class = build_post_process(config['PostProcess'],\n                                                     global_config)",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "make_input",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "peekOfCode": "def make_input(ser_inputs, ser_results):\n    entities_labels = {'HEADER': 0, 'QUESTION': 1, 'ANSWER': 2}\n    batch_size, max_seq_len = ser_inputs[0].shape[:2]\n    entities = ser_inputs[8][0]\n    ser_results = ser_results[0]\n    assert len(entities) == len(ser_results)\n    # entities\n    start = []\n    end = []\n    label = []",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "preprocess",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "peekOfCode": "def preprocess():\n    FLAGS = ReArgsParser().parse_args()\n    config = load_config(FLAGS.config)\n    config = merge_config(config, FLAGS.opt)\n    ser_config = load_config(FLAGS.config_ser)\n    ser_config = merge_config(ser_config, FLAGS.opt_ser)\n    logger = get_logger()\n    # check if set use_gpu=True in paddlepaddle cpu version\n    use_gpu = config['Global']['use_gpu']\n    device = 'gpu:{}'.format(dist.ParallelEnv().dev_id) if use_gpu else 'cpu'",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nimport paddle.distributed as dist\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport cv2\nimport json\nimport paddle\nimport paddle.distributed as dist\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.visual import draw_re_results",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_kie_token_ser_re",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n    # build model\n    if hasattr(post_process_class, 'character'):\n        char_num = len(getattr(post_process_class, 'character'))\n        if config[\"Architecture\"][\"algorithm\"] in [\"Distillation\",\n                                                   ]:  # distillation model",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list\nimport tools.program as program\ndef main():\n    global_config = config['Global']",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_rec",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "peekOfCode": "def main():\n    global_config = config['Global']\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n    # sr transform\n    config['Architecture'][\"Transform\"]['infer_mode'] = True\n    model = build_model(config['Architecture'])\n    load_model(config, model)\n    # create data ops",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, __dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list\nimport tools.program as program\ndef main():\n    global_config = config['Global']",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_sr",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "peekOfCode": "def main(config, device, logger, vdl_writer):\n    global_config = config['Global']\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n    # build model\n    if hasattr(post_process_class, 'character'):\n        config['Architecture'][\"Head\"]['out_channels'] = len(\n            getattr(post_process_class, 'character'))\n    model = build_model(config['Architecture'])",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nos.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom paddle.jit import to_static\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "documentation": {}
    },
    {
        "label": "os.environ[\"FLAGS_allocator_strategy\"]",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "description": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "peekOfCode": "os.environ[\"FLAGS_allocator_strategy\"] = 'auto_growth'\nimport paddle\nfrom paddle.jit import to_static\nfrom ppocr.data import create_operators, transform\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.utils.save_load import load_model\nfrom ppocr.utils.utility import get_image_file_list\nfrom ppocr.utils.visual import draw_rectangle\nfrom tools.infer.utility import draw_boxes",
        "detail": "Vision.Paddle.PaddleOCR.tools.infer_table",
        "documentation": {}
    },
    {
        "label": "ArgsParser",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "class ArgsParser(ArgumentParser):\n    def __init__(self):\n        super(ArgsParser, self).__init__(\n            formatter_class=RawDescriptionHelpFormatter)\n        self.add_argument(\"-c\", \"--config\", help=\"configuration file to use\")\n        self.add_argument(\n            \"-o\", \"--opt\", nargs='+', help=\"set configuration options\")\n        self.add_argument(\n            '-p',\n            '--profiler_options',",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def load_config(file_path):\n    \"\"\"\n    Load config from yml/yaml file.\n    Args:\n        file_path (str): Path of the config file to be loaded.\n    Returns: global config\n    \"\"\"\n    _, ext = os.path.splitext(file_path)\n    assert ext in ['.yml', '.yaml'], \"only support yaml files for now\"\n    config = yaml.load(open(file_path, 'rb'), Loader=yaml.Loader)",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "merge_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def merge_config(config, opts):\n    \"\"\"\n    Merge config into global config.\n    Args:\n        config (dict): Config to be merged.\n    Returns: global config\n    \"\"\"\n    for key, value in opts.items():\n        if \".\" not in key:\n            if isinstance(value, dict) and key in config:",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "check_device",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def check_device(use_gpu, use_xpu=False, use_npu=False, use_mlu=False):\n    \"\"\"\n    Log error and exit when set use_gpu=true in paddlepaddle\n    cpu version.\n    \"\"\"\n    err = \"Config {} cannot be set as true while your paddle \" \\\n          \"is not compiled with {} ! \\nPlease try: \\n\" \\\n          \"\\t1. Install paddlepaddle to run model on {} \\n\" \\\n          \"\\t2. Set {} as false in config file to run \" \\\n          \"model on CPU\"",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "to_float32",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def to_float32(preds):\n    if isinstance(preds, dict):\n        for k in preds:\n            if isinstance(preds[k], dict) or isinstance(preds[k], list):\n                preds[k] = to_float32(preds[k])\n            elif isinstance(preds[k], paddle.Tensor):\n                preds[k] = preds[k].astype(paddle.float32)\n    elif isinstance(preds, list):\n        for k in range(len(preds)):\n            if isinstance(preds[k], dict):",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def train(config,\n          train_dataloader,\n          valid_dataloader,\n          device,\n          model,\n          loss_class,\n          optimizer,\n          lr_scheduler,\n          post_process_class,\n          eval_class,",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "eval",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def eval(model,\n         valid_dataloader,\n         post_process_class,\n         eval_class,\n         model_type=None,\n         extra_input=False,\n         scaler=None,\n         amp_level='O2',\n         amp_custom_black_list=[],\n         amp_custom_white_list=[],",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "update_center",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def update_center(char_center, post_result, preds):\n    result, label = post_result\n    feats, logits = preds\n    logits = paddle.argmax(logits, axis=-1)\n    feats = feats.numpy()\n    logits = logits.numpy()\n    for idx_sample in range(len(label)):\n        if result[idx_sample][0] == label[idx_sample][0]:\n            feat = feats[idx_sample]\n            logit = logits[idx_sample]",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "get_center",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def get_center(model, eval_dataloader, post_process_class):\n    pbar = tqdm(total=len(eval_dataloader), desc='get center:')\n    max_iter = len(eval_dataloader) - 1 if platform.system(\n    ) == \"Windows\" else len(eval_dataloader)\n    char_center = dict()\n    for idx, batch in enumerate(eval_dataloader):\n        if idx >= max_iter:\n            break\n        images = batch[0]\n        start = time.time()",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "preprocess",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.program",
        "description": "Vision.Paddle.PaddleOCR.tools.program",
        "peekOfCode": "def preprocess(is_train=False):\n    FLAGS = ArgsParser().parse_args()\n    profiler_options = FLAGS.profiler_options\n    config = load_config(FLAGS.config)\n    config = merge_config(config, FLAGS.opt)\n    profile_dic = {\"profiler_options\": FLAGS.profiler_options}\n    config = merge_config(config, profile_dic)\n    if is_train:\n        # save_config\n        save_model_dir = config['Global']['save_model_dir']",
        "detail": "Vision.Paddle.PaddleOCR.tools.program",
        "documentation": {}
    },
    {
        "label": "cv2_to_base64",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "description": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "peekOfCode": "def cv2_to_base64(image):\n    return base64.b64encode(image).decode('utf8')\ndef draw_server_result(image_file, res):\n    img = cv2.imread(image_file)\n    image = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))\n    if len(res) == 0:\n        return np.array(image)\n    keys = res[0].keys()\n    if 'text_region' not in keys:  # for ocr_rec, draw function is invalid \n        logger.info(\"draw function is invalid for ocr_rec!\")",
        "detail": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "documentation": {}
    },
    {
        "label": "draw_server_result",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "description": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "peekOfCode": "def draw_server_result(image_file, res):\n    img = cv2.imread(image_file)\n    image = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))\n    if len(res) == 0:\n        return np.array(image)\n    keys = res[0].keys()\n    if 'text_region' not in keys:  # for ocr_rec, draw function is invalid \n        logger.info(\"draw function is invalid for ocr_rec!\")\n        return None\n    elif 'text' not in keys:  # for ocr_det",
        "detail": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "documentation": {}
    },
    {
        "label": "save_structure_res",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "description": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "peekOfCode": "def save_structure_res(res, save_folder, image_file):\n    img = cv2.imread(image_file)\n    excel_save_folder = os.path.join(save_folder, os.path.basename(image_file))\n    os.makedirs(excel_save_folder, exist_ok=True)\n    # save res\n    with open(\n            os.path.join(excel_save_folder, 'res.txt'), 'w',\n            encoding='utf8') as f:\n        for region in res:\n            if region['type'] == 'Table':",
        "detail": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "description": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "peekOfCode": "def main(args):\n    image_file_list = get_image_file_list(args.image_dir)\n    is_visualize = False\n    headers = {\"Content-type\": \"application/json\"}\n    cnt = 0\n    total_time = 0\n    for image_file in image_file_list:\n        img = open(image_file, 'rb').read()\n        if img is None:\n            logger.info(\"error in loading image:{}\".format(image_file))",
        "detail": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "description": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "peekOfCode": "def parse_args():\n    import argparse\n    parser = argparse.ArgumentParser(description=\"args for hub serving\")\n    parser.add_argument(\"--server_url\", type=str, required=True)\n    parser.add_argument(\"--image_dir\", type=str, required=True)\n    parser.add_argument(\"--visualize\", type=str2bool, default=False)\n    parser.add_argument(\"--output\", type=str, default='./hubserving_result')\n    args = parser.parse_args()\n    return args\nif __name__ == '__main__':",
        "detail": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "description": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.append(os.path.abspath(os.path.join(__dir__, '..')))\nfrom ppocr.utils.logging import get_logger\nlogger = get_logger()\nimport cv2\nimport numpy as np\nimport time\nfrom PIL import Image\nfrom ppocr.utils.utility import get_image_file_list",
        "detail": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "description": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "peekOfCode": "logger = get_logger()\nimport cv2\nimport numpy as np\nimport time\nfrom PIL import Image\nfrom ppocr.utils.utility import get_image_file_list\nfrom tools.infer.utility import draw_ocr, draw_boxes, str2bool\nfrom ppstructure.utility import draw_structure_result\nfrom ppstructure.predict_system import to_excel\nimport requests",
        "detail": "Vision.Paddle.PaddleOCR.tools.test_hubserving",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.train",
        "description": "Vision.Paddle.PaddleOCR.tools.train",
        "peekOfCode": "def main(config, device, logger, vdl_writer):\n    # init dist environment\n    if config['Global']['distributed']:\n        dist.init_parallel_env()\n    global_config = config['Global']\n    # build dataloader\n    set_signal_handlers()\n    train_dataloader = build_dataloader(config, 'Train', device, logger)\n    if len(train_dataloader) == 0:\n        logger.error(",
        "detail": "Vision.Paddle.PaddleOCR.tools.train",
        "documentation": {}
    },
    {
        "label": "test_reader",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.tools.train",
        "description": "Vision.Paddle.PaddleOCR.tools.train",
        "peekOfCode": "def test_reader(config, device, logger):\n    loader = build_dataloader(config, 'Train', device, logger)\n    import time\n    starttime = time.time()\n    count = 0\n    try:\n        for data in loader():\n            count += 1\n            if count % 1 == 0:\n                batch_time = time.time() - starttime",
        "detail": "Vision.Paddle.PaddleOCR.tools.train",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.tools.train",
        "description": "Vision.Paddle.PaddleOCR.tools.train",
        "peekOfCode": "__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(__dir__)\nsys.path.insert(0, os.path.abspath(os.path.join(__dir__, '..')))\nimport yaml\nimport paddle\nimport paddle.distributed as dist\nfrom ppocr.data import build_dataloader, set_signal_handlers\nfrom ppocr.modeling.architectures import build_model\nfrom ppocr.losses import build_loss\nfrom ppocr.optimizer import build_optimizer",
        "detail": "Vision.Paddle.PaddleOCR.tools.train",
        "documentation": {}
    },
    {
        "label": "PaddleOCR",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "class PaddleOCR(predict_system.TextSystem):\n    def __init__(self, **kwargs):\n        \"\"\"\n        paddleocr package\n        args:\n            **kwargs: other params show in paddleocr --help\n        \"\"\"\n        params = parse_args(mMain=False)\n        params.__dict__.update(**kwargs)\n        assert params.ocr_version in SUPPORT_OCR_MODEL_VERSION, \"ocr_version must in {}, but get {}\".format(",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "PPStructure",
        "kind": 6,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "class PPStructure(StructureSystem):\n    def __init__(self, **kwargs):\n        params = parse_args(mMain=False)\n        params.__dict__.update(**kwargs)\n        assert params.structure_version in SUPPORT_STRUCTURE_MODEL_VERSION, \"structure_version must in {}, but get {}\".format(\n            SUPPORT_STRUCTURE_MODEL_VERSION, params.structure_version)\n        params.use_gpu = check_gpu(params.use_gpu)\n        params.mode = 'structure'\n        if not params.show_log:\n            logger.setLevel(logging.INFO)",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "def parse_args(mMain=True):\n    import argparse\n    parser = init_args()\n    parser.add_help = mMain\n    parser.add_argument(\"--lang\", type=str, default='ch')\n    parser.add_argument(\"--det\", type=str2bool, default=True)\n    parser.add_argument(\"--rec\", type=str2bool, default=True)\n    parser.add_argument(\"--type\", type=str, default='ocr')\n    parser.add_argument(\n        \"--ocr_version\",",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "parse_lang",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "def parse_lang(lang):\n    latin_lang = [\n        'af', 'az', 'bs', 'cs', 'cy', 'da', 'de', 'es', 'et', 'fr', 'ga', 'hr',\n        'hu', 'id', 'is', 'it', 'ku', 'la', 'lt', 'lv', 'mi', 'ms', 'mt', 'nl',\n        'no', 'oc', 'pi', 'pl', 'pt', 'ro', 'rs_latin', 'sk', 'sl', 'sq', 'sv',\n        'sw', 'tl', 'tr', 'uz', 'vi', 'french', 'german'\n    ]\n    arabic_lang = ['ar', 'fa', 'ug', 'ur']\n    cyrillic_lang = [\n        'ru', 'rs_cyrillic', 'be', 'bg', 'uk', 'mn', 'abq', 'ady', 'kbd', 'ava',",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "get_model_config",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "def get_model_config(type, version, model_type, lang):\n    if type == 'OCR':\n        DEFAULT_MODEL_VERSION = DEFAULT_OCR_MODEL_VERSION\n    elif type == 'STRUCTURE':\n        DEFAULT_MODEL_VERSION = DEFAULT_STRUCTURE_MODEL_VERSION\n    else:\n        raise NotImplementedError\n    model_urls = MODEL_URLS[type]\n    if version not in model_urls:\n        version = DEFAULT_MODEL_VERSION",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "img_decode",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "def img_decode(content: bytes):\n    np_arr = np.frombuffer(content, dtype=np.uint8)\n    return cv2.imdecode(np_arr, cv2.IMREAD_UNCHANGED)\ndef check_img(img):\n    if isinstance(img, bytes):\n        img = img_decode(img)\n    if isinstance(img, str):\n        # download net image\n        if is_link(img):\n            download_with_progressbar(img, 'tmp.jpg')",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "check_img",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "def check_img(img):\n    if isinstance(img, bytes):\n        img = img_decode(img)\n    if isinstance(img, str):\n        # download net image\n        if is_link(img):\n            download_with_progressbar(img, 'tmp.jpg')\n            img = 'tmp.jpg'\n        image_file = img\n        img, flag_gif, flag_pdf = check_and_read(image_file)",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "def main():\n    # for cmd\n    args = parse_args(mMain=True)\n    image_dir = args.image_dir\n    if is_link(image_dir):\n        download_with_progressbar(image_dir, 'tmp.jpg')\n        image_file_list = ['tmp.jpg']\n    else:\n        image_file_list = get_image_file_list(args.image_dir)\n    if len(image_file_list) == 0:",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "__dir__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "__dir__ = os.path.dirname(__file__)\nimport paddle\nsys.path.append(os.path.join(__dir__, ''))\nimport cv2\nimport logging\nimport numpy as np\nfrom pathlib import Path\nimport base64\nfrom io import BytesIO\nfrom PIL import Image",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "tools",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "tools = _import_file(\n    'tools', os.path.join(__dir__, 'tools/__init__.py'), make_importable=True)\nppocr = importlib.import_module('ppocr', 'paddleocr')\nppstructure = importlib.import_module('ppstructure', 'paddleocr')\nfrom ppocr.utils.logging import get_logger\nfrom tools.infer import predict_system\nfrom ppocr.utils.utility import check_and_read, get_image_file_list, alpha_to_color, binarize_img\nfrom ppocr.utils.network import maybe_download, download_with_progressbar, is_link, confirm_model_dir_url\nfrom tools.infer.utility import draw_ocr, str2bool, check_gpu\nfrom ppstructure.utility import init_args, draw_structure_result",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "ppocr",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "ppocr = importlib.import_module('ppocr', 'paddleocr')\nppstructure = importlib.import_module('ppstructure', 'paddleocr')\nfrom ppocr.utils.logging import get_logger\nfrom tools.infer import predict_system\nfrom ppocr.utils.utility import check_and_read, get_image_file_list, alpha_to_color, binarize_img\nfrom ppocr.utils.network import maybe_download, download_with_progressbar, is_link, confirm_model_dir_url\nfrom tools.infer.utility import draw_ocr, str2bool, check_gpu\nfrom ppstructure.utility import init_args, draw_structure_result\nfrom ppstructure.predict_system import StructureSystem, save_structure_res, to_excel\nlogger = get_logger()",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "ppstructure",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "ppstructure = importlib.import_module('ppstructure', 'paddleocr')\nfrom ppocr.utils.logging import get_logger\nfrom tools.infer import predict_system\nfrom ppocr.utils.utility import check_and_read, get_image_file_list, alpha_to_color, binarize_img\nfrom ppocr.utils.network import maybe_download, download_with_progressbar, is_link, confirm_model_dir_url\nfrom tools.infer.utility import draw_ocr, str2bool, check_gpu\nfrom ppstructure.utility import init_args, draw_structure_result\nfrom ppstructure.predict_system import StructureSystem, save_structure_res, to_excel\nlogger = get_logger()\n__all__ = [",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "logger = get_logger()\n__all__ = [\n    'PaddleOCR', 'PPStructure', 'draw_ocr', 'draw_structure_result',\n    'save_structure_res', 'download_with_progressbar', 'to_excel'\n]\nSUPPORT_DET_MODEL = ['DB']\nVERSION = '2.7.0.1'\nSUPPORT_REC_MODEL = ['CRNN', 'SVTR_LCNet']\nBASE_DIR = os.path.expanduser(\"~/.paddleocr/\")\nDEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4'",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "__all__ = [\n    'PaddleOCR', 'PPStructure', 'draw_ocr', 'draw_structure_result',\n    'save_structure_res', 'download_with_progressbar', 'to_excel'\n]\nSUPPORT_DET_MODEL = ['DB']\nVERSION = '2.7.0.1'\nSUPPORT_REC_MODEL = ['CRNN', 'SVTR_LCNet']\nBASE_DIR = os.path.expanduser(\"~/.paddleocr/\")\nDEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4'\nSUPPORT_OCR_MODEL_VERSION = ['PP-OCR', 'PP-OCRv2', 'PP-OCRv3', 'PP-OCRv4']",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "SUPPORT_DET_MODEL",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "SUPPORT_DET_MODEL = ['DB']\nVERSION = '2.7.0.1'\nSUPPORT_REC_MODEL = ['CRNN', 'SVTR_LCNet']\nBASE_DIR = os.path.expanduser(\"~/.paddleocr/\")\nDEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4'\nSUPPORT_OCR_MODEL_VERSION = ['PP-OCR', 'PP-OCRv2', 'PP-OCRv3', 'PP-OCRv4']\nDEFAULT_STRUCTURE_MODEL_VERSION = 'PP-StructureV2'\nSUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "VERSION = '2.7.0.1'\nSUPPORT_REC_MODEL = ['CRNN', 'SVTR_LCNet']\nBASE_DIR = os.path.expanduser(\"~/.paddleocr/\")\nDEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4'\nSUPPORT_OCR_MODEL_VERSION = ['PP-OCR', 'PP-OCRv2', 'PP-OCRv3', 'PP-OCRv4']\nDEFAULT_STRUCTURE_MODEL_VERSION = 'PP-StructureV2'\nSUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "SUPPORT_REC_MODEL",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "SUPPORT_REC_MODEL = ['CRNN', 'SVTR_LCNet']\nBASE_DIR = os.path.expanduser(\"~/.paddleocr/\")\nDEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4'\nSUPPORT_OCR_MODEL_VERSION = ['PP-OCR', 'PP-OCRv2', 'PP-OCRv3', 'PP-OCRv4']\nDEFAULT_STRUCTURE_MODEL_VERSION = 'PP-StructureV2'\nSUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {\n            'det': {",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "BASE_DIR = os.path.expanduser(\"~/.paddleocr/\")\nDEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4'\nSUPPORT_OCR_MODEL_VERSION = ['PP-OCR', 'PP-OCRv2', 'PP-OCRv3', 'PP-OCRv4']\nDEFAULT_STRUCTURE_MODEL_VERSION = 'PP-StructureV2'\nSUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {\n            'det': {\n                'ch': {",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OCR_MODEL_VERSION",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "DEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4'\nSUPPORT_OCR_MODEL_VERSION = ['PP-OCR', 'PP-OCRv2', 'PP-OCRv3', 'PP-OCRv4']\nDEFAULT_STRUCTURE_MODEL_VERSION = 'PP-StructureV2'\nSUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {\n            'det': {\n                'ch': {\n                    'url':",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "SUPPORT_OCR_MODEL_VERSION",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "SUPPORT_OCR_MODEL_VERSION = ['PP-OCR', 'PP-OCRv2', 'PP-OCRv3', 'PP-OCRv4']\nDEFAULT_STRUCTURE_MODEL_VERSION = 'PP-StructureV2'\nSUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {\n            'det': {\n                'ch': {\n                    'url':\n                    'https://paddleocr.bj.bcebos.com/PP-OCRv4/chinese/ch_PP-OCRv4_det_infer.tar',",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "DEFAULT_STRUCTURE_MODEL_VERSION",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "DEFAULT_STRUCTURE_MODEL_VERSION = 'PP-StructureV2'\nSUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {\n            'det': {\n                'ch': {\n                    'url':\n                    'https://paddleocr.bj.bcebos.com/PP-OCRv4/chinese/ch_PP-OCRv4_det_infer.tar',\n                },",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "SUPPORT_STRUCTURE_MODEL_VERSION",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "SUPPORT_STRUCTURE_MODEL_VERSION = ['PP-Structure', 'PP-StructureV2']\nMODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {\n            'det': {\n                'ch': {\n                    'url':\n                    'https://paddleocr.bj.bcebos.com/PP-OCRv4/chinese/ch_PP-OCRv4_det_infer.tar',\n                },\n                'en': {",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "MODEL_URLS",
        "kind": 5,
        "importPath": "Vision.Paddle.PaddleOCR.paddleocr",
        "description": "Vision.Paddle.PaddleOCR.paddleocr",
        "peekOfCode": "MODEL_URLS = {\n    'OCR': {\n        'PP-OCRv4': {\n            'det': {\n                'ch': {\n                    'url':\n                    'https://paddleocr.bj.bcebos.com/PP-OCRv4/chinese/ch_PP-OCRv4_det_infer.tar',\n                },\n                'en': {\n                    'url':",
        "detail": "Vision.Paddle.PaddleOCR.paddleocr",
        "documentation": {}
    },
    {
        "label": "load_requirements",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.setup",
        "description": "Vision.Paddle.PaddleOCR.setup",
        "peekOfCode": "def load_requirements(file_list=None):\n    if file_list is None:\n        file_list = ['requirements.txt']\n    if isinstance(file_list,str):\n        file_list = [file_list]\n    requirements = []\n    for file in file_list:\n        with open(file, encoding=\"utf-8-sig\") as f:\n            requirements.extend(f.readlines())\n    return requirements",
        "detail": "Vision.Paddle.PaddleOCR.setup",
        "documentation": {}
    },
    {
        "label": "readme",
        "kind": 2,
        "importPath": "Vision.Paddle.PaddleOCR.setup",
        "description": "Vision.Paddle.PaddleOCR.setup",
        "peekOfCode": "def readme():\n    with open('doc/doc_en/whl_en.md', encoding=\"utf-8-sig\") as f:\n        README = f.read()\n    return README\nsetup(\n    name='paddleocr',\n    packages=['paddleocr'],\n    package_dir={'paddleocr': ''},\n    include_package_data=True,\n    entry_points={\"console_scripts\": [\"paddleocr= paddleocr.paddleocr:main\"]},",
        "detail": "Vision.Paddle.PaddleOCR.setup",
        "documentation": {}
    }
]